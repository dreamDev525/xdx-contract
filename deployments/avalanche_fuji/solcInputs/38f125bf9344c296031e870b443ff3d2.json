{
  "language": "Solidity",
  "sources": {
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ncontract Governable {\n    address public gov;\n\n    constructor() public {\n        gov = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Governable: forbidden\");\n        _;\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n}\n"
    },
    "contracts/tokens/Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"../access/Governable.sol\";\n\ncontract Bridge is ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public token;\n    address public wToken;\n\n    constructor(address _token, address _wToken) public {\n        token = _token;\n        wToken = _wToken;\n    }\n\n    function wrap(uint256 _amount, address _receiver) external nonReentrant {\n        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(wToken).safeTransfer(_receiver, _amount);\n    }\n\n    function unwrap(uint256 _amount, address _receiver) external nonReentrant {\n        IERC20(wToken).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(token).safeTransfer(_receiver, _amount);\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n}\n"
    },
    "contracts/libraries/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/token/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/xdx/XdxMigrator.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IXdxIou.sol\";\nimport \"./interfaces/IAmmRouter.sol\";\nimport \"./interfaces/IXdxMigrator.sol\";\n\ncontract XdxMigrator is ReentrancyGuard, IXdxMigrator {\n    using SafeMath for uint256;\n\n    bool public isInitialized;\n    bool public isMigrationActive = true;\n    bool public hasMaxMigrationLimit = false;\n\n    uint256 public minAuthorizations;\n\n    address public ammRouter;\n    uint256 public xdxPrice;\n\n    uint256 public actionsNonce;\n    address public admin;\n\n    address[] public signers;\n    mapping (address => bool) public isSigner;\n    mapping (bytes32 => bool) public pendingActions;\n    mapping (address => mapping (bytes32 => bool)) public signedActions;\n\n    mapping (address => bool) public whitelistedTokens;\n    mapping (address => address) public override iouTokens;\n    mapping (address => uint256) public prices;\n    mapping (address => uint256) public caps;\n\n    mapping (address => bool) public lpTokens;\n    mapping (address => address) public lpTokenAs;\n    mapping (address => address) public lpTokenBs;\n\n    mapping (address => uint256) public tokenAmounts;\n\n    mapping (address => mapping (address => uint256)) public migratedAmounts;\n    mapping (address => mapping (address => uint256)) public maxMigrationAmounts;\n\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action, uint256 nonce);\n\n    event SignalPendingAction(bytes32 action, uint256 nonce);\n    event SignAction(bytes32 action, uint256 nonce);\n    event ClearAction(bytes32 action, uint256 nonce);\n\n    constructor(uint256 _minAuthorizations) public {\n        admin = msg.sender;\n        minAuthorizations = _minAuthorizations;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"XdxMigrator: forbidden\");\n        _;\n    }\n\n    modifier onlySigner() {\n        require(isSigner[msg.sender], \"XdxMigrator: forbidden\");\n        _;\n    }\n\n    function initialize(\n        address _ammRouter,\n        uint256 _xdxPrice,\n        address[] memory _signers,\n        address[] memory _whitelistedTokens,\n        address[] memory _iouTokens,\n        uint256[] memory _prices,\n        uint256[] memory _caps,\n        address[] memory _lpTokens,\n        address[] memory _lpTokenAs,\n        address[] memory _lpTokenBs\n    ) public onlyAdmin {\n        require(!isInitialized, \"XdxMigrator: already initialized\");\n        require(_whitelistedTokens.length == _iouTokens.length, \"XdxMigrator: invalid _iouTokens.length\");\n        require(_whitelistedTokens.length == _prices.length, \"XdxMigrator: invalid _prices.length\");\n        require(_whitelistedTokens.length == _caps.length, \"XdxMigrator: invalid _caps.length\");\n        require(_lpTokens.length == _lpTokenAs.length, \"XdxMigrator: invalid _lpTokenAs.length\");\n        require(_lpTokens.length == _lpTokenBs.length, \"XdxMigrator: invalid _lpTokenBs.length\");\n\n        isInitialized = true;\n\n        ammRouter = _ammRouter;\n        xdxPrice = _xdxPrice;\n\n        signers = _signers;\n        for (uint256 i = 0; i < _signers.length; i++) {\n            address signer = _signers[i];\n            isSigner[signer] = true;\n        }\n\n        for (uint256 i = 0; i < _whitelistedTokens.length; i++) {\n            address token = _whitelistedTokens[i];\n            whitelistedTokens[token] = true;\n            iouTokens[token] = _iouTokens[i];\n            prices[token] = _prices[i];\n            caps[token] = _caps[i];\n        }\n\n        for (uint256 i = 0; i < _lpTokens.length; i++) {\n            address token = _lpTokens[i];\n            lpTokens[token] = true;\n            lpTokenAs[token] = _lpTokenAs[i];\n            lpTokenBs[token] = _lpTokenBs[i];\n        }\n    }\n\n    function endMigration() public onlyAdmin {\n        isMigrationActive = false;\n    }\n\n    function setHasMaxMigrationLimit(bool _hasMaxMigrationLimit) public onlyAdmin {\n        hasMaxMigrationLimit = _hasMaxMigrationLimit;\n    }\n\n    function setMaxMigrationAmount(address _account, address _token, uint256 _maxMigrationAmount) public onlyAdmin {\n        maxMigrationAmounts[_account][_token] = _maxMigrationAmount;\n    }\n\n    function migrate(\n        address _token,\n        uint256 _tokenAmount\n    ) public nonReentrant {\n        require(isMigrationActive, \"XdxMigrator: migration is no longer active\");\n        require(whitelistedTokens[_token], \"XdxMigrator: token not whitelisted\");\n        require(_tokenAmount > 0, \"XdxMigrator: invalid tokenAmount\");\n\n        if (hasMaxMigrationLimit) {\n            migratedAmounts[msg.sender][_token] = migratedAmounts[msg.sender][_token].add(_tokenAmount);\n            require(migratedAmounts[msg.sender][_token] <= maxMigrationAmounts[msg.sender][_token], \"XdxMigrator: maxMigrationAmount exceeded\");\n        }\n\n        uint256 tokenPrice = getTokenPrice(_token);\n        uint256 mintAmount = _tokenAmount.mul(tokenPrice).div(xdxPrice);\n        require(mintAmount > 0, \"XdxMigrator: invalid mintAmount\");\n\n        tokenAmounts[_token] = tokenAmounts[_token].add(_tokenAmount);\n        require(tokenAmounts[_token] < caps[_token], \"XdxMigrator: token cap exceeded\");\n\n        IERC20(_token).transferFrom(msg.sender, address(this), _tokenAmount);\n\n        if (lpTokens[_token]) {\n            address tokenA = lpTokenAs[_token];\n            address tokenB = lpTokenBs[_token];\n            require(tokenA != address(0), \"XdxMigrator: invalid tokenA\");\n            require(tokenB != address(0), \"XdxMigrator: invalid tokenB\");\n\n            IERC20(_token).approve(ammRouter, _tokenAmount);\n            IAmmRouter(ammRouter).removeLiquidity(tokenA, tokenB, _tokenAmount, 0, 0, address(this), block.timestamp);\n        }\n\n        address iouToken = getIouToken(_token);\n        IXdxIou(iouToken).mint(msg.sender, mintAmount);\n    }\n\n    function signalApprove(address _token, address _spender, uint256 _amount) external nonReentrant onlyAdmin {\n        actionsNonce++;\n        uint256 nonce = actionsNonce;\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount, nonce));\n        _setPendingAction(action, nonce);\n        emit SignalApprove(_token, _spender, _amount, action, nonce);\n    }\n\n    function signApprove(address _token, address _spender, uint256 _amount, uint256 _nonce) external nonReentrant onlySigner {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount, _nonce));\n        _validateAction(action);\n        require(!signedActions[msg.sender][action], \"XdxMigrator: already signed\");\n        signedActions[msg.sender][action] = true;\n        emit SignAction(action, _nonce);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount, uint256 _nonce) external nonReentrant onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount, _nonce));\n        _validateAction(action);\n        _validateAuthorization(action);\n\n        IERC20(_token).approve(_spender, _amount);\n        _clearAction(action, _nonce);\n    }\n\n    function getTokenAmounts(address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            amounts[i] = tokenAmounts[token];\n        }\n\n        return amounts;\n    }\n\n    function getTokenPrice(address _token) public view returns (uint256) {\n        uint256 price = prices[_token];\n        require(price != 0, \"XdxMigrator: invalid token price\");\n        return price;\n    }\n\n    function getIouToken(address _token) public view returns (address) {\n        address iouToken = iouTokens[_token];\n        require(iouToken != address(0), \"XdxMigrator: invalid iou token\");\n        return iouToken;\n    }\n\n    function _setPendingAction(bytes32 _action, uint256 _nonce) private {\n        pendingActions[_action] = true;\n        emit SignalPendingAction(_action, _nonce);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action], \"XdxMigrator: action not signalled\");\n    }\n\n    function _validateAuthorization(bytes32 _action) private view {\n        uint256 count = 0;\n        for (uint256 i = 0; i < signers.length; i++) {\n            address signer = signers[i];\n            if (signedActions[signer][_action]) {\n                count++;\n            }\n        }\n\n        if (count == 0) {\n            revert(\"XdxMigrator: action not authorized\");\n        }\n        require(count >= minAuthorizations, \"XdxMigrator: insufficient authorization\");\n    }\n\n    function _clearAction(bytes32 _action, uint256 _nonce) private {\n        require(pendingActions[_action], \"XdxMigrator: invalid _action\");\n        delete pendingActions[_action];\n        emit ClearAction(_action, _nonce);\n    }\n}\n"
    },
    "contracts/xdx/interfaces/IXdxIou.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IXdxIou {\n    function mint(address account, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/xdx/interfaces/IAmmRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IAmmRouter {\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n"
    },
    "contracts/xdx/interfaces/IXdxMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IXdxMigrator {\n    function iouTokens(address _token) external view returns (address);\n}\n"
    },
    "contracts/xdx/MigrationHandler.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IAmmRouter.sol\";\nimport \"./interfaces/IXdxMigrator.sol\";\nimport \"../core/interfaces/IVault.sol\";\n\ncontract MigrationHandler is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    uint256 public constant USDG_PRECISION = 10 ** 18;\n\n    bool public isInitialized;\n\n    address public admin;\n    address public ammRouterV1;\n    address public ammRouterV2;\n\n    address public vault;\n\n    address public gmt;\n    address public xgmt;\n    address public usdg;\n    address public bnb;\n    address public busd;\n\n    mapping (address => mapping (address => uint256)) public refundedAmounts;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"MigrationHandler: forbidden\");\n        _;\n    }\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    function initialize(\n        address _ammRouterV1,\n        address _ammRouterV2,\n        address _vault,\n        address _gmt,\n        address _xgmt,\n        address _usdg,\n        address _bnb,\n        address _busd\n    ) public onlyAdmin {\n        require(!isInitialized, \"MigrationHandler: already initialized\");\n        isInitialized = true;\n\n        ammRouterV1 = _ammRouterV1;\n        ammRouterV2 = _ammRouterV2;\n\n        vault = _vault;\n\n        gmt = _gmt;\n        xgmt = _xgmt;\n        usdg = _usdg;\n        bnb = _bnb;\n        busd = _busd;\n    }\n\n    function redeemUsdg(\n        address _migrator,\n        address _redemptionToken,\n        uint256 _usdgAmount\n    ) external onlyAdmin nonReentrant {\n        IERC20(usdg).transferFrom(_migrator, vault, _usdgAmount);\n        uint256 amount = IVault(vault).sellUSDG(_redemptionToken, address(this));\n\n        address[] memory path = new address[](2);\n        path[0] = bnb;\n        path[1] = busd;\n\n        if (_redemptionToken != bnb) {\n            path = new address[](3);\n            path[0] = _redemptionToken;\n            path[1] = bnb;\n            path[2] = busd;\n        }\n\n        IERC20(_redemptionToken).approve(ammRouterV2, amount);\n        IAmmRouter(ammRouterV2).swapExactTokensForTokens(\n            amount,\n            0,\n            path,\n            _migrator,\n            block.timestamp\n        );\n    }\n\n    function swap(\n        address _migrator,\n        uint256 _gmtAmountForUsdg,\n        uint256 _xgmtAmountForUsdg,\n        uint256 _gmtAmountForBusd\n    ) external onlyAdmin nonReentrant {\n        address[] memory path = new address[](2);\n\n        path[0] = gmt;\n        path[1] = usdg;\n        IERC20(gmt).transferFrom(_migrator, address(this), _gmtAmountForUsdg);\n        IERC20(gmt).approve(ammRouterV2, _gmtAmountForUsdg);\n        IAmmRouter(ammRouterV2).swapExactTokensForTokens(\n            _gmtAmountForUsdg,\n            0,\n            path,\n            _migrator,\n            block.timestamp\n        );\n\n        path[0] = xgmt;\n        path[1] = usdg;\n        IERC20(xgmt).transferFrom(_migrator, address(this), _xgmtAmountForUsdg);\n        IERC20(xgmt).approve(ammRouterV2, _xgmtAmountForUsdg);\n        IAmmRouter(ammRouterV2).swapExactTokensForTokens(\n            _xgmtAmountForUsdg,\n            0,\n            path,\n            _migrator,\n            block.timestamp\n        );\n\n        path[0] = gmt;\n        path[1] = busd;\n        IERC20(gmt).transferFrom(_migrator, address(this), _gmtAmountForBusd);\n        IERC20(gmt).approve(ammRouterV1, _gmtAmountForBusd);\n        IAmmRouter(ammRouterV1).swapExactTokensForTokens(\n            _gmtAmountForBusd,\n            0,\n            path,\n            _migrator,\n            block.timestamp\n        );\n    }\n\n    function refund(\n        address _migrator,\n        address _account,\n        address _token,\n        uint256 _usdgAmount\n    ) external onlyAdmin nonReentrant {\n        address iouToken = IXdxMigrator(_migrator).iouTokens(_token);\n        uint256 iouBalance = IERC20(iouToken).balanceOf(_account);\n        uint256 iouTokenAmount = _usdgAmount.div(2); // each XDX is priced at $2\n\n        uint256 refunded = refundedAmounts[_account][iouToken];\n        refundedAmounts[_account][iouToken] = refunded.add(iouTokenAmount);\n\n        require(refundedAmounts[_account][iouToken] <= iouBalance, \"MigrationHandler: refundable amount exceeded\");\n\n        IERC20(usdg).transferFrom(_migrator, _account, _usdgAmount);\n    }\n}\n"
    },
    "contracts/core/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IVaultUtils.sol\";\n\ninterface IVault {\n    function isInitialized() external view returns (bool);\n    function isSwapEnabled() external view returns (bool);\n    function isLeverageEnabled() external view returns (bool);\n\n    function setVaultUtils(IVaultUtils _vaultUtils) external;\n    function setError(uint256 _errorCode, string calldata _error) external;\n\n    function router() external view returns (address);\n    function usdg() external view returns (address);\n    function gov() external view returns (address);\n\n    function whitelistedTokenCount() external view returns (uint256);\n    function maxLeverage() external view returns (uint256);\n\n    function minProfitTime() external view returns (uint256);\n    function hasDynamicFees() external view returns (bool);\n    function fundingInterval() external view returns (uint256);\n    function totalTokenWeights() external view returns (uint256);\n    function getTargetUsdgAmount(address _token) external view returns (uint256);\n\n    function inManagerMode() external view returns (bool);\n    function inPrivateLiquidationMode() external view returns (bool);\n\n    function maxGasPrice() external view returns (uint256);\n\n    function approvedRouters(address _account, address _router) external view returns (bool);\n    function isLiquidator(address _account) external view returns (bool);\n    function isManager(address _account) external view returns (bool);\n\n    function minProfitBasisPoints(address _token) external view returns (uint256);\n    function tokenBalances(address _token) external view returns (uint256);\n    function lastFundingTimes(address _token) external view returns (uint256);\n\n    function setMaxLeverage(uint256 _maxLeverage) external;\n    function setInManagerMode(bool _inManagerMode) external;\n    function setManager(address _manager, bool _isManager) external;\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\n    function setUsdgAmount(address _token, uint256 _amount) external;\n    function setBufferAmount(address _token, uint256 _amount) external;\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external;\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;\n    function setLiquidator(address _liquidator, bool _isActive) external;\n\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external;\n\n    function setFees(\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external;\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _redemptionBps,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external;\n\n    function setPriceFeed(address _priceFeed) external;\n    function withdrawFees(address _token, address _receiver) external returns (uint256);\n\n    function directPoolDeposit(address _token) external;\n    function buyUSDG(address _token, address _receiver) external returns (uint256);\n    function sellUSDG(address _token, address _receiver) external returns (uint256);\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n    function decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external returns (uint256);\n    function liquidatePosition(address _account, address _collateralToken, address _indexToken, bool _isLong, address _feeReceiver) external;\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);\n\n    function priceFeed() external view returns (address);\n    function fundingRateFactor() external view returns (uint256);\n    function stableFundingRateFactor() external view returns (uint256);\n    function cumulativeFundingRates(address _token) external view returns (uint256);\n    function getNextFundingRate(address _token) external view returns (uint256);\n    function getFeeBasisPoints(address _token, uint256 _usdgDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) external view returns (uint256);\n\n    function liquidationFeeUsd() external view returns (uint256);\n    function taxBasisPoints() external view returns (uint256);\n    function stableTaxBasisPoints() external view returns (uint256);\n    function mintBurnFeeBasisPoints() external view returns (uint256);\n    function swapFeeBasisPoints() external view returns (uint256);\n    function stableSwapFeeBasisPoints() external view returns (uint256);\n    function marginFeeBasisPoints() external view returns (uint256);\n\n    function allWhitelistedTokensLength() external view returns (uint256);\n    function allWhitelistedTokens(uint256) external view returns (address);\n    function whitelistedTokens(address _token) external view returns (bool);\n    function stableTokens(address _token) external view returns (bool);\n    function shortableTokens(address _token) external view returns (bool);\n    function feeReserves(address _token) external view returns (uint256);\n    function globalShortSizes(address _token) external view returns (uint256);\n    function globalShortAveragePrices(address _token) external view returns (uint256);\n    function maxGlobalShortSizes(address _token) external view returns (uint256);\n    function tokenDecimals(address _token) external view returns (uint256);\n    function tokenWeights(address _token) external view returns (uint256);\n    function guaranteedUsd(address _token) external view returns (uint256);\n    function poolAmounts(address _token) external view returns (uint256);\n    function bufferAmounts(address _token) external view returns (uint256);\n    function reservedAmounts(address _token) external view returns (uint256);\n    function usdgAmounts(address _token) external view returns (uint256);\n    function maxUsdgAmounts(address _token) external view returns (uint256);\n    function getRedemptionAmount(address _token, uint256 _usdgAmount) external view returns (uint256);\n    function getMaxPrice(address _token) external view returns (uint256);\n    function getMinPrice(address _token) external view returns (uint256);\n\n    function getDelta(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _lastIncreasedTime) external view returns (bool, uint256);\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);\n}\n"
    },
    "contracts/core/interfaces/IVaultUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVaultUtils {\n    function updateCumulativeFundingRate(address _collateralToken, address _indexToken) external returns (bool);\n    function validateIncreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external view;\n    function validateDecreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external view;\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) external view returns (uint256, uint256);\n    function getEntryFundingRate(address _collateralToken, address _indexToken, bool _isLong) external view returns (uint256);\n    function getPositionFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta) external view returns (uint256);\n    function getFundingFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _size, uint256 _entryFundingRate) external view returns (uint256);\n    function getBuyUsdgFeeBasisPoints(address _token, uint256 _usdgAmount) external view returns (uint256);\n    function getSellUsdgFeeBasisPoints(address _token, uint256 _usdgAmount) external view returns (uint256);\n    function getSwapFeeBasisPoints(address _tokenIn, address _tokenOut, uint256 _usdgAmount) external view returns (uint256);\n    function getFeeBasisPoints(address _token, uint256 _usdgDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) external view returns (uint256);\n}\n"
    },
    "contracts/peripherals/XdxTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/ITimelockTarget.sol\";\nimport \"./interfaces/IXdxTimelock.sol\";\nimport \"./interfaces/IHandlerTarget.sol\";\nimport \"../access/interfaces/IAdmin.sol\";\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultUtils.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../core/interfaces/IRouter.sol\";\nimport \"../tokens/interfaces/IYieldToken.sol\";\nimport \"../tokens/interfaces/IBaseToken.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../tokens/interfaces/IUSDG.sol\";\nimport \"../staking/interfaces/IVester.sol\";\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\n\ncontract XdxTimelock is IXdxTimelock {\n    using SafeMath for uint256;\n\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant MAX_BUFFER = 7 days;\n    uint256 public constant MAX_FEE_BASIS_POINTS = 300; // 3%\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 200; // 0.02%\n    uint256 public constant MAX_LEVERAGE_VALIDATION = 500000; // 50x\n\n    uint256 public buffer;\n    uint256 public longBuffer;\n    address public admin;\n\n    address public tokenManager;\n    address public rewardManager;\n    address public mintReceiver;\n    uint256 public maxTokenSupply;\n\n    mapping (bytes32 => uint256) public pendingActions;\n    mapping (address => bool) public excludedTokens;\n\n    mapping (address => bool) public isHandler;\n\n    event SignalPendingAction(bytes32 action);\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action);\n    event SignalWithdrawToken(address target, address token, address receiver, uint256 amount, bytes32 action);\n    event SignalMint(address token, address receiver, uint256 amount, bytes32 action);\n    event SignalSetGov(address target, address gov, bytes32 action);\n    event SignalSetPriceFeed(address vault, address priceFeed, bytes32 action);\n    event SignalAddPlugin(address router, address plugin, bytes32 action);\n    event SignalRedeemUsdg(address vault, address token, uint256 amount);\n    event SignalVaultSetTokenConfig(\n        address vault,\n        address token,\n        uint256 tokenDecimals,\n        uint256 tokenWeight,\n        uint256 minProfitBps,\n        uint256 maxUsdgAmount,\n        bool isStable,\n        bool isShortable\n    );\n    event SignalPriceFeedSetTokenConfig(\n        address vaultPriceFeed,\n        address token,\n        address priceFeed,\n        uint256 priceDecimals,\n        bool isStrictStable\n    );\n    event ClearAction(bytes32 action);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"XdxTimelock: forbidden\");\n        _;\n    }\n\n    modifier onlyAdminOrHandler() {\n        require(msg.sender == admin || isHandler[msg.sender], \"XdxTimelock: forbidden\");\n        _;\n    }\n\n    modifier onlyTokenManager() {\n        require(msg.sender == tokenManager, \"XdxTimelock: forbidden\");\n        _;\n    }\n\n    modifier onlyRewardManager() {\n        require(msg.sender == rewardManager, \"XdxTimelock: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _admin,\n        uint256 _buffer,\n        uint256 _longBuffer,\n        address _rewardManager,\n        address _tokenManager,\n        address _mintReceiver,\n        uint256 _maxTokenSupply\n    ) public {\n        require(_buffer <= MAX_BUFFER, \"XdxTimelock: invalid _buffer\");\n        require(_longBuffer <= MAX_BUFFER, \"XdxTimelock: invalid _longBuffer\");\n        admin = _admin;\n        buffer = _buffer;\n        longBuffer = _longBuffer;\n        rewardManager = _rewardManager;\n        tokenManager = _tokenManager;\n        mintReceiver = _mintReceiver;\n        maxTokenSupply = _maxTokenSupply;\n    }\n\n    function setAdmin(address _admin) external override onlyTokenManager {\n        admin = _admin;\n    }\n\n    function setExternalAdmin(address _target, address _admin) external onlyAdmin {\n        require(_target != address(this), \"XdxTimelock: invalid _target\");\n        IAdmin(_target).setAdmin(_admin);\n    }\n\n    function setContractHandler(address _handler, bool _isActive) external onlyAdmin {\n        isHandler[_handler] = _isActive;\n    }\n\n    function setBuffer(uint256 _buffer) external onlyAdmin {\n        require(_buffer <= MAX_BUFFER, \"XdxTimelock: invalid _buffer\");\n        require(_buffer > buffer, \"XdxTimelock: buffer cannot be decreased\");\n        buffer = _buffer;\n    }\n\n    function setMaxLeverage(address _vault, uint256 _maxLeverage) external onlyAdmin {\n      require(_maxLeverage > MAX_LEVERAGE_VALIDATION, \"XdxTimelock: invalid _maxLeverage\");\n      IVault(_vault).setMaxLeverage(_maxLeverage);\n    }\n\n    function setFundingRate(address _vault, uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external onlyAdmin {\n        require(_fundingRateFactor < MAX_FUNDING_RATE_FACTOR, \"XdxTimelock: invalid _fundingRateFactor\");\n        require(_stableFundingRateFactor < MAX_FUNDING_RATE_FACTOR, \"XdxTimelock: invalid _stableFundingRateFactor\");\n        IVault(_vault).setFundingRate(_fundingInterval, _fundingRateFactor, _stableFundingRateFactor);\n    }\n\n    function setFees(\n        address _vault,\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external onlyAdmin {\n        require(_taxBasisPoints < MAX_FEE_BASIS_POINTS, \"XdxTimelock: invalid _taxBasisPoints\");\n        require(_stableTaxBasisPoints < MAX_FEE_BASIS_POINTS, \"XdxTimelock: invalid _stableTaxBasisPoints\");\n        require(_mintBurnFeeBasisPoints < MAX_FEE_BASIS_POINTS, \"XdxTimelock: invalid _mintBurnFeeBasisPoints\");\n        require(_swapFeeBasisPoints < MAX_FEE_BASIS_POINTS, \"XdxTimelock: invalid _swapFeeBasisPoints\");\n        require(_stableSwapFeeBasisPoints < MAX_FEE_BASIS_POINTS, \"XdxTimelock: invalid _stableSwapFeeBasisPoints\");\n        require(_marginFeeBasisPoints < MAX_FEE_BASIS_POINTS, \"XdxTimelock: invalid _marginFeeBasisPoints\");\n        require(_liquidationFeeUsd < 10 * PRICE_PRECISION, \"XdxTimelock: invalid _liquidationFeeUsd\");\n\n        IVault(_vault).setFees(\n            _taxBasisPoints,\n            _stableTaxBasisPoints,\n            _mintBurnFeeBasisPoints,\n            _swapFeeBasisPoints,\n            _stableSwapFeeBasisPoints,\n            _marginFeeBasisPoints,\n            _liquidationFeeUsd,\n            _minProfitTime,\n            _hasDynamicFees\n        );\n    }\n\n    function setTokenConfig(\n        address _vault,\n        address _token,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        uint256 _bufferAmount,\n        uint256 _usdgAmount\n    ) external onlyAdmin {\n        require(_minProfitBps <= 500, \"XdxTimelock: invalid _minProfitBps\");\n\n        IVault vault = IVault(_vault);\n        require(vault.whitelistedTokens(_token), \"XdxTimelock: token not yet whitelisted\");\n\n        uint256 tokenDecimals = vault.tokenDecimals(_token);\n        bool isStable = vault.stableTokens(_token);\n        bool isShortable = vault.shortableTokens(_token);\n\n        IVault(_vault).setTokenConfig(\n            _token,\n            tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            isStable,\n            isShortable\n        );\n\n        IVault(_vault).setBufferAmount(_token, _bufferAmount);\n\n        IVault(_vault).setUsdgAmount(_token, _usdgAmount);\n    }\n\n    function setMaxGlobalShortSize(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        IVault(_vault).setMaxGlobalShortSize(_token, _amount);\n    }\n\n    function removeAdmin(address _token, address _account) external onlyAdmin {\n        IYieldToken(_token).removeAdmin(_account);\n    }\n\n    function setIsAmmEnabled(address _priceFeed, bool _isEnabled) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setIsAmmEnabled(_isEnabled);\n    }\n\n    function setIsSecondaryPriceEnabled(address _priceFeed, bool _isEnabled) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setIsSecondaryPriceEnabled(_isEnabled);\n    }\n\n    function setMaxStrictPriceDeviation(address _priceFeed, uint256 _maxStrictPriceDeviation) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setMaxStrictPriceDeviation(_maxStrictPriceDeviation);\n    }\n\n    function setUseV2Pricing(address _priceFeed, bool _useV2Pricing) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setUseV2Pricing(_useV2Pricing);\n    }\n\n    function setAdjustment(address _priceFeed, address _token, bool _isAdditive, uint256 _adjustmentBps) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setAdjustment(_token, _isAdditive, _adjustmentBps);\n    }\n\n    function setSpreadBasisPoints(address _priceFeed, address _token, uint256 _spreadBasisPoints) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setSpreadBasisPoints(_token, _spreadBasisPoints);\n    }\n\n    function setSpreadThresholdBasisPoints(address _priceFeed, uint256 _spreadThresholdBasisPoints) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setSpreadThresholdBasisPoints(_spreadThresholdBasisPoints);\n    }\n\n    function setFavorPrimaryPrice(address _priceFeed, bool _favorPrimaryPrice) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setFavorPrimaryPrice(_favorPrimaryPrice);\n    }\n\n    function setPriceSampleSpace(address _priceFeed,uint256 _priceSampleSpace) external onlyAdmin {\n        require(_priceSampleSpace <= 5, \"Invalid _priceSampleSpace\");\n        IVaultPriceFeed(_priceFeed).setPriceSampleSpace(_priceSampleSpace);\n    }\n\n    function setIsSwapEnabled(address _vault, bool _isSwapEnabled) external onlyAdmin {\n        IVault(_vault).setIsSwapEnabled(_isSwapEnabled);\n    }\n\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external override onlyAdminOrHandler {\n        IVault(_vault).setIsLeverageEnabled(_isLeverageEnabled);\n    }\n\n    function setVaultUtils(address _vault, IVaultUtils _vaultUtils) external onlyAdmin {\n        IVault(_vault).setVaultUtils(_vaultUtils);\n    }\n\n    function setMaxGasPrice(address _vault,uint256 _maxGasPrice) external onlyAdmin {\n        require(_maxGasPrice > 5000000000, \"Invalid _maxGasPrice\");\n        IVault(_vault).setMaxGasPrice(_maxGasPrice);\n    }\n\n    function withdrawFees(address _vault,address _token, address _receiver) external onlyAdmin {\n        IVault(_vault).withdrawFees(_token, _receiver);\n    }\n\n    function setInPrivateLiquidationMode(address _vault, bool _inPrivateLiquidationMode) external onlyAdmin {\n        IVault(_vault).setInPrivateLiquidationMode(_inPrivateLiquidationMode);\n    }\n\n    function setLiquidator(address _vault, address _liquidator, bool _isActive) external onlyAdmin {\n        IVault(_vault).setLiquidator(_liquidator, _isActive);\n    }\n\n    function addExcludedToken(address _token) external onlyAdmin {\n        excludedTokens[_token] = true;\n    }\n\n    function setInPrivateTransferMode(address _token, bool _inPrivateTransferMode) external onlyAdmin {\n        if (excludedTokens[_token]) {\n            // excludedTokens can only have their transfers enabled\n            require(_inPrivateTransferMode == false, \"XdxTimelock: invalid _inPrivateTransferMode\");\n        }\n\n        IBaseToken(_token).setInPrivateTransferMode(_inPrivateTransferMode);\n    }\n\n    function transferIn(address _sender, address _token, uint256 _amount) external onlyAdmin {\n        IERC20(_token).transferFrom(_sender, address(this), _amount);\n    }\n\n    function signalApprove(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _setPendingAction(action);\n        emit SignalApprove(_token, _spender, _amount, action);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function signalWithdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit SignalWithdrawToken(_target, _token, _receiver, _amount, action);\n    }\n\n    function withdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IBaseToken(_target).withdrawToken(_token, _receiver, _amount);\n    }\n\n    function signalMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit SignalMint(_token, _receiver, _amount, action);\n    }\n\n    function processMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n\n        _mint(_token, _receiver, _amount);\n    }\n\n    function signalSetGov(address _target, address _gov) external override onlyTokenManager {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _setLongPendingAction(action);\n        emit SignalSetGov(_target, _gov, action);\n    }\n\n    function setGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _validateAction(action);\n        _clearAction(action);\n        ITimelockTarget(_target).setGov(_gov);\n    }\n\n    function signalSetPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _setPendingAction(action);\n        emit SignalSetPriceFeed(_vault, _priceFeed, action);\n    }\n\n    function setPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _validateAction(action);\n        _clearAction(action);\n        IVault(_vault).setPriceFeed(_priceFeed);\n    }\n\n    function signalAddPlugin(address _router, address _plugin) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"addPlugin\", _router, _plugin));\n        _setPendingAction(action);\n        emit SignalAddPlugin(_router, _plugin, action);\n    }\n\n    function addPlugin(address _router, address _plugin) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"addPlugin\", _router, _plugin));\n        _validateAction(action);\n        _clearAction(action);\n        IRouter(_router).addPlugin(_plugin);\n    }\n\n    function signalRedeemUsdg(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemUsdg\", _vault, _token, _amount));\n        _setPendingAction(action);\n        emit SignalRedeemUsdg(_vault, _token, _amount);\n    }\n\n    function redeemUsdg(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemUsdg\", _vault, _token, _amount));\n        _validateAction(action);\n        _clearAction(action);\n\n        address usdg = IVault(_vault).usdg();\n        IVault(_vault).setManager(address(this), true);\n        IUSDG(usdg).addVault(address(this));\n\n        IUSDG(usdg).mint(address(this), _amount);\n        IERC20(usdg).transfer(address(_vault), _amount);\n\n        IVault(_vault).sellUSDG(_token, mintReceiver);\n\n        IVault(_vault).setManager(address(this), false);\n        IUSDG(usdg).removeVault(address(this));\n    }\n\n    function signalVaultSetTokenConfig(\n        address _vault,\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"vaultSetTokenConfig\",\n            _vault,\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        ));\n\n        _setPendingAction(action);\n\n        emit SignalVaultSetTokenConfig(\n            _vault,\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        );\n    }\n\n    function vaultSetTokenConfig(\n        address _vault,\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"vaultSetTokenConfig\",\n            _vault,\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        ));\n\n        _validateAction(action);\n        _clearAction(action);\n\n        IVault(_vault).setTokenConfig(\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        );\n    }\n\n    function signalPriceFeedSetTokenConfig(\n        address _vaultPriceFeed,\n        address _token,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        bool _isStrictStable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"priceFeedSetTokenConfig\",\n            _vaultPriceFeed,\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        ));\n\n        _setPendingAction(action);\n\n        emit SignalPriceFeedSetTokenConfig(\n            _vaultPriceFeed,\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        );\n    }\n\n    function priceFeedSetTokenConfig(\n        address _vaultPriceFeed,\n        address _token,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        bool _isStrictStable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"priceFeedSetTokenConfig\",\n            _vaultPriceFeed,\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        ));\n\n        _validateAction(action);\n        _clearAction(action);\n\n        IVaultPriceFeed(_vaultPriceFeed).setTokenConfig(\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        );\n    }\n\n    function cancelAction(bytes32 _action) external onlyAdmin {\n        _clearAction(_action);\n    }\n\n    function _mint(address _token, address _receiver, uint256 _amount) private {\n        IMintable mintable = IMintable(_token);\n\n        if (!mintable.isMinter(address(this))) {\n            mintable.setMinter(address(this), true);\n        }\n\n        mintable.mint(_receiver, _amount);\n        require(IERC20(_token).totalSupply() <= maxTokenSupply, \"XdxTimelock: maxTokenSupply exceeded\");\n    }\n\n    function _setPendingAction(bytes32 _action) private {\n        pendingActions[_action] = block.timestamp.add(buffer);\n        emit SignalPendingAction(_action);\n    }\n\n    function _setLongPendingAction(bytes32 _action) private {\n        pendingActions[_action] = block.timestamp.add(longBuffer);\n        emit SignalPendingAction(_action);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action] != 0, \"XdxTimelock: action not signalled\");\n        require(pendingActions[_action] < block.timestamp, \"XdxTimelock: action time not yet passed\");\n    }\n\n    function _clearAction(bytes32 _action) private {\n        require(pendingActions[_action] != 0, \"XdxTimelock: invalid _action\");\n        delete pendingActions[_action];\n        emit ClearAction(_action);\n    }\n}\n"
    },
    "contracts/peripherals/interfaces/ITimelockTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ITimelockTarget {\n    function setGov(address _gov) external;\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/peripherals/interfaces/IXdxTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IXdxTimelock {\n    function setAdmin(address _admin) external;\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external;\n    function signalSetGov(address _target, address _gov) external;\n}\n"
    },
    "contracts/peripherals/interfaces/IHandlerTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IHandlerTarget {\n    function isHandler(address _account) external returns (bool);\n    function setHandler(address _handler, bool _isActive) external;\n}\n"
    },
    "contracts/access/interfaces/IAdmin.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IAdmin {\n    function setAdmin(address _admin) external;\n}\n"
    },
    "contracts/core/interfaces/IVaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVaultPriceFeed {\n    function adjustmentBasisPoints(address _token) external view returns (uint256);\n    function isAdjustmentAdditive(address _token) external view returns (bool);\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;\n    function setUseV2Pricing(bool _useV2Pricing) external;\n    function setIsAmmEnabled(bool _isEnabled) external;\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);\n    function getAmmPrice(address _token) external view returns (uint256);\n    function getLatestPrimaryPrice(address _token) external view returns (uint256);\n    function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);\n    function setTokenConfig(\n        address _token,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        bool _isStrictStable\n    ) external;\n}\n"
    },
    "contracts/core/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IRouter {\n    function addPlugin(address _plugin) external;\n    function pluginTransfer(address _token, address _account, address _receiver, uint256 _amount) external;\n    function pluginIncreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n    function pluginDecreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external returns (uint256);\n    function swap(address[] memory _path, uint256 _amountIn, uint256 _minOut, address _receiver) external;\n}\n"
    },
    "contracts/tokens/interfaces/IYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IYieldToken {\n    function totalStaked() external view returns (uint256);\n    function stakedBalance(address _account) external view returns (uint256);\n    function removeAdmin(address _account) external;\n}\n"
    },
    "contracts/tokens/interfaces/IBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IBaseToken {\n    function totalStaked() external view returns (uint256);\n    function stakedBalance(address _account) external view returns (uint256);\n    function removeAdmin(address _account) external;\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external;\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/tokens/interfaces/IMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IMintable {\n    function isMinter(address _account) external returns (bool);\n    function setMinter(address _minter, bool _isActive) external;\n    function mint(address _account, uint256 _amount) external;\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/tokens/interfaces/IUSDG.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IUSDG {\n    function addVault(address _vault) external;\n    function removeVault(address _vault) external;\n    function mint(address _account, uint256 _amount) external;\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/staking/interfaces/IVester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVester {\n    function rewardTracker() external view returns (address);\n\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n\n    function claimable(address _account) external view returns (uint256);\n    function cumulativeClaimAmounts(address _account) external view returns (uint256);\n    function claimedAmounts(address _account) external view returns (uint256);\n    function pairAmounts(address _account) external view returns (uint256);\n    function getVestedAmount(address _account) external view returns (uint256);\n    function transferredAverageStakedAmounts(address _account) external view returns (uint256);\n    function transferredCumulativeRewards(address _account) external view returns (uint256);\n    function cumulativeRewardDeductions(address _account) external view returns (uint256);\n    function bonusRewards(address _account) external view returns (uint256);\n\n    function transferStakeValues(address _sender, address _receiver) external;\n    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;\n    function setTransferredCumulativeRewards(address _account, uint256 _amount) external;\n    function setCumulativeRewardDeductions(address _account, uint256 _amount) external;\n    function setBonusRewards(address _account, uint256 _amount) external;\n\n    function getMaxVestableAmount(address _account) external view returns (uint256);\n    function getCombinedAverageStakedAmount(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/xdx/XdxIou.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"./interfaces/IXdxIou.sol\";\n\ncontract XdxIou is IERC20, IXdxIou {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n    uint256 public override totalSupply;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    address public minter;\n\n    constructor (address _minter, string memory _name, string memory _symbol) public {\n        name = _name;\n        symbol = _symbol;\n        minter = _minter;\n        decimals = 18;\n    }\n\n    function mint(address account, uint256 amount) public override returns (bool) {\n        require(msg.sender == minter, \"XdxIou: forbidden\");\n        _mint(account, amount);\n        return true;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    // empty implementation, XdxIou tokens are non-transferrable\n    function transfer(address /* recipient */, uint256 /* amount */) public override returns (bool) {\n        revert(\"XdxIou: non-transferrable\");\n    }\n\n    // empty implementation, XdxIou tokens are non-transferrable\n    function allowance(address /* owner */, address /* spender */) public view virtual override returns (uint256) {\n        return 0;\n    }\n\n    // empty implementation, XdxIou tokens are non-transferrable\n    function approve(address /* spender */, uint256 /* amount */) public virtual override returns (bool) {\n        revert(\"XdxIou: non-transferrable\");\n    }\n\n    // empty implementation, XdxIou tokens are non-transferrable\n    function transferFrom(address /* sender */, address /* recipient */, uint256 /* amount */) public virtual override returns (bool) {\n        revert(\"XdxIou: non-transferrable\");\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"XdxIou: mint to the zero address\");\n\n        totalSupply = totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n}\n"
    },
    "contracts/xdx/XdxFloor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../access/TokenManager.sol\";\n\ncontract XdxFloor is ReentrancyGuard, TokenManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant BURN_BASIS_POINTS = 9000;\n\n    address public xdx;\n    address public reserveToken;\n    uint256 public backedSupply;\n    uint256 public baseMintPrice;\n    uint256 public mintMultiplier;\n    uint256 public mintedSupply;\n    uint256 public multiplierPrecision;\n\n    mapping (address => bool) public isHandler;\n\n    modifier onlyHandler() {\n        require(isHandler[msg.sender], \"XdxFloor: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _xdx,\n        address _reserveToken,\n        uint256 _backedSupply,\n        uint256 _baseMintPrice,\n        uint256 _mintMultiplier,\n        uint256 _multiplierPrecision,\n        uint256 _minAuthorizations\n    ) public TokenManager(_minAuthorizations) {\n        xdx = _xdx;\n\n        reserveToken = _reserveToken;\n        backedSupply = _backedSupply;\n\n        baseMintPrice = _baseMintPrice;\n        mintMultiplier = _mintMultiplier;\n        multiplierPrecision = _multiplierPrecision;\n    }\n\n    function initialize(address[] memory _signers) public override onlyAdmin {\n        TokenManager.initialize(_signers);\n    }\n\n    function setHandler(address _handler, bool _isHandler) public onlyAdmin {\n        isHandler[_handler] = _isHandler;\n    }\n\n    function setBackedSupply(uint256 _backedSupply) public onlyAdmin {\n        require(_backedSupply > backedSupply, \"XdxFloor: invalid _backedSupply\");\n        backedSupply = _backedSupply;\n    }\n\n    function setMintMultiplier(uint256 _mintMultiplier) public onlyAdmin {\n        require(_mintMultiplier > mintMultiplier, \"XdxFloor: invalid _mintMultiplier\");\n        mintMultiplier = _mintMultiplier;\n    }\n\n    // mint refers to increasing the circulating supply\n    // the XDX tokens to be transferred out must be pre-transferred into this contract\n    function mint(uint256 _amount, uint256 _maxCost, address _receiver) public onlyHandler nonReentrant returns (uint256) {\n        require(_amount > 0, \"XdxFloor: invalid _amount\");\n\n        uint256 currentMintPrice = getMintPrice();\n        uint256 nextMintPrice = currentMintPrice.add(_amount.mul(mintMultiplier).div(multiplierPrecision));\n        uint256 averageMintPrice = currentMintPrice.add(nextMintPrice).div(2);\n\n        uint256 cost = _amount.mul(averageMintPrice).div(PRICE_PRECISION);\n        require(cost <= _maxCost, \"XdxFloor: _maxCost exceeded\");\n\n        mintedSupply = mintedSupply.add(_amount);\n        backedSupply = backedSupply.add(_amount);\n\n        IERC20(reserveToken).safeTransferFrom(msg.sender, address(this), cost);\n        IERC20(xdx).transfer(_receiver, _amount);\n\n        return cost;\n    }\n\n    function burn(uint256 _amount, uint256 _minOut, address _receiver) public onlyHandler nonReentrant returns (uint256) {\n        require(_amount > 0, \"XdxFloor: invalid _amount\");\n\n        uint256 amountOut = getBurnAmountOut(_amount);\n        require(amountOut >= _minOut, \"XdxFloor: insufficient amountOut\");\n\n        backedSupply = backedSupply.sub(_amount);\n\n        IMintable(xdx).burn(msg.sender, _amount);\n        IERC20(reserveToken).safeTransfer(_receiver, amountOut);\n\n        return amountOut;\n    }\n\n    function getMintPrice() public view returns (uint256) {\n        return baseMintPrice.add(mintedSupply.mul(mintMultiplier).div(multiplierPrecision));\n    }\n\n    function getBurnAmountOut(uint256 _amount) public view returns (uint256) {\n        uint256 balance = IERC20(reserveToken).balanceOf(address(this));\n        return _amount.mul(balance).div(backedSupply).mul(BURN_BASIS_POINTS).div(BASIS_POINTS_DIVISOR);\n    }\n}\n"
    },
    "contracts/access/TokenManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/ERC721/IERC721.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"../peripherals/interfaces/ITimelock.sol\";\n\ncontract TokenManager is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bool public isInitialized;\n\n    uint256 public actionsNonce;\n    uint256 public minAuthorizations;\n\n    address public admin;\n\n    address[] public signers;\n    mapping (address => bool) public isSigner;\n    mapping (bytes32 => bool) public pendingActions;\n    mapping (address => mapping (bytes32 => bool)) public signedActions;\n\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action, uint256 nonce);\n    event SignalApproveNFT(address token, address spender, uint256 tokenId, bytes32 action, uint256 nonce);\n    event SignalApproveNFTs(address token, address spender, uint256[] tokenIds, bytes32 action, uint256 nonce);\n    event SignalSetAdmin(address target, address admin, bytes32 action, uint256 nonce);\n    event SignalSetGov(address timelock, address target, address gov, bytes32 action, uint256 nonce);\n    event SignalPendingAction(bytes32 action, uint256 nonce);\n    event SignAction(bytes32 action, uint256 nonce);\n    event ClearAction(bytes32 action, uint256 nonce);\n\n    constructor(uint256 _minAuthorizations) public {\n        admin = msg.sender;\n        minAuthorizations = _minAuthorizations;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"TokenManager: forbidden\");\n        _;\n    }\n\n    modifier onlySigner() {\n        require(isSigner[msg.sender], \"TokenManager: forbidden\");\n        _;\n    }\n\n    function initialize(address[] memory _signers) public virtual onlyAdmin {\n        require(!isInitialized, \"TokenManager: already initialized\");\n        isInitialized = true;\n\n        signers = _signers;\n        for (uint256 i = 0; i < _signers.length; i++) {\n            address signer = _signers[i];\n            isSigner[signer] = true;\n        }\n    }\n\n    function signersLength() public view returns (uint256) {\n        return signers.length;\n    }\n\n    function signalApprove(address _token, address _spender, uint256 _amount) external nonReentrant onlyAdmin {\n        actionsNonce++;\n        uint256 nonce = actionsNonce;\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount, nonce));\n        _setPendingAction(action, nonce);\n        emit SignalApprove(_token, _spender, _amount, action, nonce);\n    }\n\n    function signApprove(address _token, address _spender, uint256 _amount, uint256 _nonce) external nonReentrant onlySigner {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount, _nonce));\n        _validateAction(action);\n        require(!signedActions[msg.sender][action], \"TokenManager: already signed\");\n        signedActions[msg.sender][action] = true;\n        emit SignAction(action, _nonce);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount, uint256 _nonce) external nonReentrant onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount, _nonce));\n        _validateAction(action);\n        _validateAuthorization(action);\n\n        IERC20(_token).approve(_spender, _amount);\n        _clearAction(action, _nonce);\n    }\n\n    function signalApproveNFT(address _token, address _spender, uint256 _tokenId) external nonReentrant onlyAdmin {\n        actionsNonce++;\n        uint256 nonce = actionsNonce;\n        bytes32 action = keccak256(abi.encodePacked(\"approveNFT\", _token, _spender, _tokenId, nonce));\n        _setPendingAction(action, nonce);\n        emit SignalApproveNFT(_token, _spender, _tokenId, action, nonce);\n    }\n\n    function signApproveNFT(address _token, address _spender, uint256 _tokenId, uint256 _nonce) external nonReentrant onlySigner {\n        bytes32 action = keccak256(abi.encodePacked(\"approveNFT\", _token, _spender, _tokenId, _nonce));\n        _validateAction(action);\n        require(!signedActions[msg.sender][action], \"TokenManager: already signed\");\n        signedActions[msg.sender][action] = true;\n        emit SignAction(action, _nonce);\n    }\n\n    function approveNFT(address _token, address _spender, uint256 _tokenId, uint256 _nonce) external nonReentrant onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approveNFT\", _token, _spender, _tokenId, _nonce));\n        _validateAction(action);\n        _validateAuthorization(action);\n\n        IERC721(_token).approve(_spender, _tokenId);\n        _clearAction(action, _nonce);\n    }\n\n    function signalApproveNFTs(address _token, address _spender, uint256[] memory _tokenIds) external nonReentrant onlyAdmin {\n        actionsNonce++;\n        uint256 nonce = actionsNonce;\n        bytes32 action = keccak256(abi.encodePacked(\"approveNFTs\", _token, _spender, _tokenIds, nonce));\n        _setPendingAction(action, nonce);\n        emit SignalApproveNFTs(_token, _spender, _tokenIds, action, nonce);\n    }\n\n    function signApproveNFTs(address _token, address _spender, uint256[] memory _tokenIds, uint256 _nonce) external nonReentrant onlySigner {\n        bytes32 action = keccak256(abi.encodePacked(\"approveNFTs\", _token, _spender, _tokenIds, _nonce));\n        _validateAction(action);\n        require(!signedActions[msg.sender][action], \"TokenManager: already signed\");\n        signedActions[msg.sender][action] = true;\n        emit SignAction(action, _nonce);\n    }\n\n    function approveNFTs(address _token, address _spender, uint256[] memory _tokenIds, uint256 _nonce) external nonReentrant onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approveNFTs\", _token, _spender, _tokenIds, _nonce));\n        _validateAction(action);\n        _validateAuthorization(action);\n\n        for (uint256 i = 0 ; i < _tokenIds.length; i++) {\n            IERC721(_token).approve(_spender, _tokenIds[i]);\n        }\n        _clearAction(action, _nonce);\n    }\n\n    function receiveNFTs(address _token, address _sender, uint256[] memory _tokenIds) external nonReentrant onlyAdmin {\n        for (uint256 i = 0 ; i < _tokenIds.length; i++) {\n            IERC721(_token).transferFrom(_sender, address(this), _tokenIds[i]);\n        }\n    }\n\n    function signalSetAdmin(address _target, address _admin) external nonReentrant onlySigner {\n        actionsNonce++;\n        uint256 nonce = actionsNonce;\n        bytes32 action = keccak256(abi.encodePacked(\"setAdmin\", _target, _admin, nonce));\n        _setPendingAction(action, nonce);\n        signedActions[msg.sender][action] = true;\n        emit SignalSetAdmin(_target, _admin, action, nonce);\n    }\n\n    function signSetAdmin(address _target, address _admin, uint256 _nonce) external nonReentrant onlySigner {\n        bytes32 action = keccak256(abi.encodePacked(\"setAdmin\", _target, _admin, _nonce));\n        _validateAction(action);\n        require(!signedActions[msg.sender][action], \"TokenManager: already signed\");\n        signedActions[msg.sender][action] = true;\n        emit SignAction(action, _nonce);\n    }\n\n    function setAdmin(address _target, address _admin, uint256 _nonce) external nonReentrant onlySigner {\n        bytes32 action = keccak256(abi.encodePacked(\"setAdmin\", _target, _admin, _nonce));\n        _validateAction(action);\n        _validateAuthorization(action);\n\n        ITimelock(_target).setAdmin(_admin);\n        _clearAction(action, _nonce);\n    }\n\n    function signalSetGov(address _timelock, address _target, address _gov) external nonReentrant onlyAdmin {\n        actionsNonce++;\n        uint256 nonce = actionsNonce;\n        bytes32 action = keccak256(abi.encodePacked(\"signalSetGov\", _timelock, _target, _gov, nonce));\n        _setPendingAction(action, nonce);\n        signedActions[msg.sender][action] = true;\n        emit SignalSetGov(_timelock, _target, _gov, action, nonce);\n    }\n\n    function signSetGov(address _timelock, address _target, address _gov, uint256 _nonce) external nonReentrant onlySigner {\n        bytes32 action = keccak256(abi.encodePacked(\"signalSetGov\", _timelock, _target, _gov, _nonce));\n        _validateAction(action);\n        require(!signedActions[msg.sender][action], \"TokenManager: already signed\");\n        signedActions[msg.sender][action] = true;\n        emit SignAction(action, _nonce);\n    }\n\n    function setGov(address _timelock, address _target, address _gov, uint256 _nonce) external nonReentrant onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"signalSetGov\", _timelock, _target, _gov, _nonce));\n        _validateAction(action);\n        _validateAuthorization(action);\n\n        ITimelock(_timelock).signalSetGov(_target, _gov);\n        _clearAction(action, _nonce);\n    }\n\n    function _setPendingAction(bytes32 _action, uint256 _nonce) private {\n        pendingActions[_action] = true;\n        emit SignalPendingAction(_action, _nonce);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action], \"TokenManager: action not signalled\");\n    }\n\n    function _validateAuthorization(bytes32 _action) private view {\n        uint256 count = 0;\n        for (uint256 i = 0; i < signers.length; i++) {\n            address signer = signers[i];\n            if (signedActions[signer][_action]) {\n                count++;\n            }\n        }\n\n        if (count == 0) {\n            revert(\"TokenManager: action not authorized\");\n        }\n        require(count >= minAuthorizations, \"TokenManager: insufficient authorization\");\n    }\n\n    function _clearAction(bytes32 _action, uint256 _nonce) private {\n        require(pendingActions[_action], \"TokenManager: invalid _action\");\n        delete pendingActions[_action];\n        emit ClearAction(_action, _nonce);\n    }\n}\n"
    },
    "contracts/libraries/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "contracts/peripherals/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ITimelock {\n    function setAdmin(address _admin) external;\n    function enableLeverage(address _vault) external;\n    function disableLeverage(address _vault) external;\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external;\n    function signalSetGov(address _target, address _gov) external;\n}\n"
    },
    "contracts/libraries/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/referrals/ReferralStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"../access/Governable.sol\";\nimport \"../peripherals/interfaces/ITimelock.sol\";\n\nimport \"./interfaces/IReferralStorage.sol\";\n\ncontract ReferralStorage is Governable, IReferralStorage {\n    using SafeMath for uint256;\n\n    struct Tier {\n        uint256 totalRebate; // e.g. 2400 for 24%\n        uint256 discountShare; // 5000 for 50%/50%, 7000 for 30% rebates/70% discount\n    }\n\n    uint256 public constant BASIS_POINTS = 10000;\n\n    mapping (address => uint256) public referrerDiscountShares; // to override default value in tier\n    mapping (address => uint256) public referrerTiers; // link between user <> tier\n    mapping (uint256 => Tier) public tiers;\n\n    mapping (address => bool) public isHandler;\n\n    mapping (bytes32 => address) public override codeOwners;\n    mapping (address => bytes32) public traderReferralCodes;\n\n    event SetHandler(address handler, bool isActive);\n    event SetTraderReferralCode(address account, bytes32 code);\n    event SetTier(uint256 tierId, uint256 totalRebate, uint256 discountShare);\n    event SetReferrerTier(address referrer, uint256 tierId);\n    event SetReferrerDiscountShare(address referrer, uint256 discountShare);\n    event RegisterCode(address account, bytes32 code);\n    event SetCodeOwner(address account, address newAccount, bytes32 code);\n    event GovSetCodeOwner(bytes32 code, address newAccount);\n\n    modifier onlyHandler() {\n        require(isHandler[msg.sender], \"ReferralStorage: forbidden\");\n        _;\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n        emit SetHandler(_handler, _isActive);\n    }\n\n    function setTier(uint256 _tierId, uint256 _totalRebate, uint256 _discountShare) external override onlyGov {\n        require(_totalRebate <= BASIS_POINTS, \"ReferralStorage: invalid totalRebate\");\n        require(_discountShare <= BASIS_POINTS, \"ReferralStorage: invalid discountShare\");\n\n        Tier memory tier = tiers[_tierId];\n        tier.totalRebate = _totalRebate;\n        tier.discountShare = _discountShare;\n        tiers[_tierId] = tier;\n        emit SetTier(_tierId, _totalRebate, _discountShare);\n    }\n\n    function setReferrerTier(address _referrer, uint256 _tierId) external override onlyGov {\n        referrerTiers[_referrer] = _tierId;\n        emit SetReferrerTier(_referrer, _tierId);\n    }\n\n    function setReferrerDiscountShare(uint256 _discountShare) external {\n        require(_discountShare <= BASIS_POINTS, \"ReferralStorage: invalid discountShare\");\n\n        referrerDiscountShares[msg.sender] = _discountShare;\n        emit SetReferrerDiscountShare(msg.sender, _discountShare);\n    }\n\n    function setTraderReferralCode(address _account, bytes32 _code) external override onlyHandler {\n        _setTraderReferralCode(_account, _code);\n    }\n\n    function setTraderReferralCodeByUser(bytes32 _code) external {\n        _setTraderReferralCode(msg.sender, _code);\n    }\n\n    function registerCode(bytes32 _code) external {\n        require(_code != bytes32(0), \"ReferralStorage: invalid _code\");\n        require(codeOwners[_code] == address(0), \"ReferralStorage: code already exists\");\n\n        codeOwners[_code] = msg.sender;\n        emit RegisterCode(msg.sender, _code);\n    }\n\n    function setCodeOwner(bytes32 _code, address _newAccount) external {\n        require(_code != bytes32(0), \"ReferralStorage: invalid _code\");\n\n        address account = codeOwners[_code];\n        require(msg.sender == account, \"ReferralStorage: forbidden\");\n\n        codeOwners[_code] = _newAccount;\n        emit SetCodeOwner(msg.sender, _newAccount, _code);\n    }\n\n    function govSetCodeOwner(bytes32 _code, address _newAccount) external override onlyGov {\n        require(_code != bytes32(0), \"ReferralStorage: invalid _code\");\n\n        codeOwners[_code] = _newAccount;\n        emit GovSetCodeOwner(_code, _newAccount);\n    }\n\n    function getTraderReferralInfo(address _account) external override view returns (bytes32, address) {\n        bytes32 code = traderReferralCodes[_account];\n        address referrer;\n        if (code != bytes32(0)) {\n            referrer = codeOwners[code];\n        }\n        return (code, referrer);\n    }\n\n    function _setTraderReferralCode(address _account, bytes32 _code) private {\n        traderReferralCodes[_account] = _code;\n        emit SetTraderReferralCode(_account, _code);\n    }\n}\n"
    },
    "contracts/referrals/interfaces/IReferralStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IReferralStorage {\n    function codeOwners(bytes32 _code) external view returns (address);\n    function getTraderReferralInfo(address _account) external view returns (bytes32, address);\n    function setTraderReferralCode(address _account, bytes32 _code) external;\n    function setTier(uint256 _tierId, uint256 _totalRebate, uint256 _discountShare) external;\n    function setReferrerTier(address _referrer, uint256 _tierId) external;\n    function govSetCodeOwner(bytes32 _code, address _newAccount) external;\n}\n"
    },
    "contracts/referrals/ReferralReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IReferralStorage.sol\";\n\ncontract ReferralReader {\n    function getCodeOwners(IReferralStorage _referralStorage, bytes32[] memory _codes) public view returns (address[] memory) {\n        address[] memory owners = new address[](_codes.length);\n\n        for (uint256 i = 0; i < _codes.length; i++) {\n            bytes32 code = _codes[i];\n            owners[i] = _referralStorage.codeOwners(code);\n        }\n\n        return owners;\n    }\n}\n"
    },
    "contracts/peripherals/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/ITimelockTarget.sol\";\nimport \"./interfaces/ITimelock.sol\";\nimport \"./interfaces/IHandlerTarget.sol\";\nimport \"../access/interfaces/IAdmin.sol\";\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultUtils.sol\";\nimport \"../core/interfaces/IXlxManager.sol\";\nimport \"../referrals/interfaces/IReferralStorage.sol\";\nimport \"../tokens/interfaces/IYieldToken.sol\";\nimport \"../tokens/interfaces/IBaseToken.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../tokens/interfaces/IUSDG.sol\";\nimport \"../staking/interfaces/IVester.sol\";\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\n\ncontract Timelock is ITimelock {\n    using SafeMath for uint256;\n\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant MAX_BUFFER = 5 days;\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 200; // 0.02%\n    uint256 public constant MAX_LEVERAGE_VALIDATION = 500000; // 50x\n\n    uint256 public buffer;\n    address public admin;\n\n    address public tokenManager;\n    address public mintReceiver;\n    address public xlxManager;\n    uint256 public maxTokenSupply;\n\n    uint256 public marginFeeBasisPoints;\n    uint256 public maxMarginFeeBasisPoints;\n    bool public shouldToggleIsLeverageEnabled;\n\n    mapping (bytes32 => uint256) public pendingActions;\n\n    mapping (address => bool) public isHandler;\n    mapping (address => bool) public isKeeper;\n\n    event SignalPendingAction(bytes32 action);\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action);\n    event SignalWithdrawToken(address target, address token, address receiver, uint256 amount, bytes32 action);\n    event SignalMint(address token, address receiver, uint256 amount, bytes32 action);\n    event SignalSetGov(address target, address gov, bytes32 action);\n    event SignalSetHandler(address target, address handler, bool isActive, bytes32 action);\n    event SignalSetPriceFeed(address vault, address priceFeed, bytes32 action);\n    event SignalRedeemUsdg(address vault, address token, uint256 amount);\n    event SignalVaultSetTokenConfig(\n        address vault,\n        address token,\n        uint256 tokenDecimals,\n        uint256 tokenWeight,\n        uint256 minProfitBps,\n        uint256 maxUsdgAmount,\n        bool isStable,\n        bool isShortable\n    );\n    event ClearAction(bytes32 action);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Timelock: forbidden\");\n        _;\n    }\n\n    modifier onlyHandlerAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n\n    modifier onlyKeeperAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender] || isKeeper[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n\n    modifier onlyTokenManager() {\n        require(msg.sender == tokenManager, \"Timelock: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _admin,\n        uint256 _buffer,\n        address _tokenManager,\n        address _mintReceiver,\n        address _xlxManager,\n        uint256 _maxTokenSupply,\n        uint256 _marginFeeBasisPoints,\n        uint256 _maxMarginFeeBasisPoints\n    ) public {\n        require(_buffer <= MAX_BUFFER, \"Timelock: invalid _buffer\");\n        admin = _admin;\n        buffer = _buffer;\n        tokenManager = _tokenManager;\n        mintReceiver = _mintReceiver;\n        xlxManager = _xlxManager;\n        maxTokenSupply = _maxTokenSupply;\n\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\n    }\n\n    function setAdmin(address _admin) external override onlyTokenManager {\n        admin = _admin;\n    }\n\n    function setExternalAdmin(address _target, address _admin) external onlyAdmin {\n        require(_target != address(this), \"Timelock: invalid _target\");\n        IAdmin(_target).setAdmin(_admin);\n    }\n\n    function setContractHandler(address _handler, bool _isActive) external onlyAdmin {\n        isHandler[_handler] = _isActive;\n    }\n\n    function setKeeper(address _keeper, bool _isActive) external onlyAdmin {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setBuffer(uint256 _buffer) external onlyAdmin {\n        require(_buffer <= MAX_BUFFER, \"Timelock: invalid _buffer\");\n        require(_buffer > buffer, \"Timelock: buffer cannot be decreased\");\n        buffer = _buffer;\n    }\n\n    function setMaxLeverage(address _vault, uint256 _maxLeverage) external onlyAdmin {\n      require(_maxLeverage > MAX_LEVERAGE_VALIDATION, \"Timelock: invalid _maxLeverage\");\n      IVault(_vault).setMaxLeverage(_maxLeverage);\n    }\n\n    function setFundingRate(address _vault, uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external onlyKeeperAndAbove {\n        require(_fundingRateFactor < MAX_FUNDING_RATE_FACTOR, \"Timelock: invalid _fundingRateFactor\");\n        require(_stableFundingRateFactor < MAX_FUNDING_RATE_FACTOR, \"Timelock: invalid _stableFundingRateFactor\");\n        IVault(_vault).setFundingRate(_fundingInterval, _fundingRateFactor, _stableFundingRateFactor);\n    }\n\n    function setShouldToggleIsLeverageEnabled(bool _shouldToggleIsLeverageEnabled) external onlyHandlerAndAbove {\n        shouldToggleIsLeverageEnabled = _shouldToggleIsLeverageEnabled;\n    }\n\n    function setMarginFeeBasisPoints(uint256 _marginFeeBasisPoints, uint256 _maxMarginFeeBasisPoints) external onlyHandlerAndAbove {\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\n    }\n\n    function setSwapFees(\n        address _vault,\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints\n    ) external onlyKeeperAndAbove {\n        IVault vault = IVault(_vault);\n\n        vault.setFees(\n            _taxBasisPoints,\n            _stableTaxBasisPoints,\n            _mintBurnFeeBasisPoints,\n            _swapFeeBasisPoints,\n            _stableSwapFeeBasisPoints,\n            maxMarginFeeBasisPoints,\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    // assign _marginFeeBasisPoints to this.marginFeeBasisPoints\n    // because enableLeverage would update Vault.marginFeeBasisPoints to this.marginFeeBasisPoints\n    // and disableLeverage would reset the Vault.marginFeeBasisPoints to this.maxMarginFeeBasisPoints\n    function setFees(\n        address _vault,\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external onlyKeeperAndAbove {\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n\n        IVault(_vault).setFees(\n            _taxBasisPoints,\n            _stableTaxBasisPoints,\n            _mintBurnFeeBasisPoints,\n            _swapFeeBasisPoints,\n            _stableSwapFeeBasisPoints,\n            maxMarginFeeBasisPoints,\n            _liquidationFeeUsd,\n            _minProfitTime,\n            _hasDynamicFees\n        );\n    }\n\n    function enableLeverage(address _vault) external override onlyHandlerAndAbove {\n        IVault vault = IVault(_vault);\n\n        if (shouldToggleIsLeverageEnabled) {\n            vault.setIsLeverageEnabled(true);\n        }\n\n        vault.setFees(\n            vault.taxBasisPoints(),\n            vault.stableTaxBasisPoints(),\n            vault.mintBurnFeeBasisPoints(),\n            vault.swapFeeBasisPoints(),\n            vault.stableSwapFeeBasisPoints(),\n            marginFeeBasisPoints,\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    function disableLeverage(address _vault) external override onlyHandlerAndAbove {\n        IVault vault = IVault(_vault);\n\n        if (shouldToggleIsLeverageEnabled) {\n            vault.setIsLeverageEnabled(false);\n        }\n\n        vault.setFees(\n            vault.taxBasisPoints(),\n            vault.stableTaxBasisPoints(),\n            vault.mintBurnFeeBasisPoints(),\n            vault.swapFeeBasisPoints(),\n            vault.stableSwapFeeBasisPoints(),\n            maxMarginFeeBasisPoints, // marginFeeBasisPoints\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external override onlyHandlerAndAbove {\n        IVault(_vault).setIsLeverageEnabled(_isLeverageEnabled);\n    }\n\n    function setTokenConfig(\n        address _vault,\n        address _token,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        uint256 _bufferAmount,\n        uint256 _usdgAmount\n    ) external onlyKeeperAndAbove {\n        require(_minProfitBps <= 500, \"Timelock: invalid _minProfitBps\");\n\n        IVault vault = IVault(_vault);\n        require(vault.whitelistedTokens(_token), \"Timelock: token not yet whitelisted\");\n\n        uint256 tokenDecimals = vault.tokenDecimals(_token);\n        bool isStable = vault.stableTokens(_token);\n        bool isShortable = vault.shortableTokens(_token);\n\n        IVault(_vault).setTokenConfig(\n            _token,\n            tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            isStable,\n            isShortable\n        );\n\n        IVault(_vault).setBufferAmount(_token, _bufferAmount);\n\n        IVault(_vault).setUsdgAmount(_token, _usdgAmount);\n    }\n\n    function setUsdgAmounts(address _vault, address[] memory _tokens, uint256[] memory _usdgAmounts) external onlyKeeperAndAbove {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IVault(_vault).setUsdgAmount(_tokens[i], _usdgAmounts[i]);\n        }\n    }\n\n    function updateUsdgSupply(uint256 usdgAmount) external onlyKeeperAndAbove {\n        address usdg = IXlxManager(xlxManager).usdg();\n        uint256 balance = IERC20(usdg).balanceOf(xlxManager);\n\n        IUSDG(usdg).addVault(address(this));\n\n        if (usdgAmount > balance) {\n            uint256 mintAmount = usdgAmount.sub(balance);\n            IUSDG(usdg).mint(xlxManager, mintAmount);\n        } else {\n            uint256 burnAmount = balance.sub(usdgAmount);\n            IUSDG(usdg).burn(xlxManager, burnAmount);\n        }\n\n        IUSDG(usdg).removeVault(address(this));\n    }\n\n    function setMaxGlobalShortSize(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        IVault(_vault).setMaxGlobalShortSize(_token, _amount);\n    }\n\n    function removeAdmin(address _token, address _account) external onlyAdmin {\n        IYieldToken(_token).removeAdmin(_account);\n    }\n\n    function setIsSwapEnabled(address _vault, bool _isSwapEnabled) external onlyKeeperAndAbove {\n        IVault(_vault).setIsSwapEnabled(_isSwapEnabled);\n    }\n\n    function setTier(address _referralStorage, uint256 _tierId, uint256 _totalRebate, uint256 _discountShare) external onlyKeeperAndAbove {\n        IReferralStorage(_referralStorage).setTier(_tierId, _totalRebate, _discountShare);\n    }\n\n    function setReferrerTier(address _referralStorage, address _referrer, uint256 _tierId) external onlyKeeperAndAbove {\n        IReferralStorage(_referralStorage).setReferrerTier(_referrer, _tierId);\n    }\n\n    function govSetCodeOwner(address _referralStorage, bytes32 _code, address _newAccount) external onlyKeeperAndAbove {\n        IReferralStorage(_referralStorage).govSetCodeOwner(_code, _newAccount);\n    }\n\n    function setVaultUtils(address _vault, IVaultUtils _vaultUtils) external onlyAdmin {\n        IVault(_vault).setVaultUtils(_vaultUtils);\n    }\n\n    function setMaxGasPrice(address _vault, uint256 _maxGasPrice) external onlyAdmin {\n        require(_maxGasPrice > 5000000000, \"Invalid _maxGasPrice\");\n        IVault(_vault).setMaxGasPrice(_maxGasPrice);\n    }\n\n    function withdrawFees(address _vault, address _token, address _receiver) external onlyAdmin {\n        IVault(_vault).withdrawFees(_token, _receiver);\n    }\n\n    function batchWithdrawFees(address _vault, address[] memory _tokens) external onlyKeeperAndAbove {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IVault(_vault).withdrawFees(_tokens[i], admin);\n        }\n    }\n\n    function setInPrivateLiquidationMode(address _vault, bool _inPrivateLiquidationMode) external onlyAdmin {\n        IVault(_vault).setInPrivateLiquidationMode(_inPrivateLiquidationMode);\n    }\n\n    function setLiquidator(address _vault, address _liquidator, bool _isActive) external onlyAdmin {\n        IVault(_vault).setLiquidator(_liquidator, _isActive);\n    }\n\n    function setInPrivateTransferMode(address _token, bool _inPrivateTransferMode) external onlyAdmin {\n        IBaseToken(_token).setInPrivateTransferMode(_inPrivateTransferMode);\n    }\n\n    function batchSetBonusRewards(address _vester, address[] memory _accounts, uint256[] memory _amounts) external onlyKeeperAndAbove {\n        require(_accounts.length == _amounts.length, \"Timelock: invalid lengths\");\n\n        if (!IHandlerTarget(_vester).isHandler(address(this))) {\n            IHandlerTarget(_vester).setHandler(address(this), true);\n        }\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 amount = _amounts[i];\n            IVester(_vester).setBonusRewards(account, amount);\n        }\n    }\n\n    function transferIn(address _sender, address _token, uint256 _amount) external onlyAdmin {\n        IERC20(_token).transferFrom(_sender, address(this), _amount);\n    }\n\n    function signalApprove(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _setPendingAction(action);\n        emit SignalApprove(_token, _spender, _amount, action);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function signalWithdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit SignalWithdrawToken(_target, _token, _receiver, _amount, action);\n    }\n\n    function withdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IBaseToken(_target).withdrawToken(_token, _receiver, _amount);\n    }\n\n    function signalMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit SignalMint(_token, _receiver, _amount, action);\n    }\n\n    function processMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n\n        _mint(_token, _receiver, _amount);\n    }\n\n    function signalSetGov(address _target, address _gov) external override onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _setPendingAction(action);\n        emit SignalSetGov(_target, _gov, action);\n    }\n\n    function setGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _validateAction(action);\n        _clearAction(action);\n        ITimelockTarget(_target).setGov(_gov);\n    }\n\n    function signalSetHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setHandler\", _target, _handler, _isActive));\n        _setPendingAction(action);\n        emit SignalSetHandler(_target, _handler, _isActive, action);\n    }\n\n    function setHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setHandler\", _target, _handler, _isActive));\n        _validateAction(action);\n        _clearAction(action);\n        IHandlerTarget(_target).setHandler(_handler, _isActive);\n    }\n\n    function signalSetPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _setPendingAction(action);\n        emit SignalSetPriceFeed(_vault, _priceFeed, action);\n    }\n\n    function setPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _validateAction(action);\n        _clearAction(action);\n        IVault(_vault).setPriceFeed(_priceFeed);\n    }\n\n    function signalRedeemUsdg(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemUsdg\", _vault, _token, _amount));\n        _setPendingAction(action);\n        emit SignalRedeemUsdg(_vault, _token, _amount);\n    }\n\n    function redeemUsdg(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemUsdg\", _vault, _token, _amount));\n        _validateAction(action);\n        _clearAction(action);\n\n        address usdg = IVault(_vault).usdg();\n        IVault(_vault).setManager(address(this), true);\n        IUSDG(usdg).addVault(address(this));\n\n        IUSDG(usdg).mint(address(this), _amount);\n        IERC20(usdg).transfer(address(_vault), _amount);\n\n        IVault(_vault).sellUSDG(_token, mintReceiver);\n\n        IVault(_vault).setManager(address(this), false);\n        IUSDG(usdg).removeVault(address(this));\n    }\n\n    function signalVaultSetTokenConfig(\n        address _vault,\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"vaultSetTokenConfig\",\n            _vault,\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        ));\n\n        _setPendingAction(action);\n\n        emit SignalVaultSetTokenConfig(\n            _vault,\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        );\n    }\n\n    function vaultSetTokenConfig(\n        address _vault,\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"vaultSetTokenConfig\",\n            _vault,\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        ));\n\n        _validateAction(action);\n        _clearAction(action);\n\n        IVault(_vault).setTokenConfig(\n            _token,\n            _tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdgAmount,\n            _isStable,\n            _isShortable\n        );\n    }\n\n    function cancelAction(bytes32 _action) external onlyAdmin {\n        _clearAction(_action);\n    }\n\n    function _mint(address _token, address _receiver, uint256 _amount) private {\n        IMintable mintable = IMintable(_token);\n\n        if (!mintable.isMinter(address(this))) {\n            mintable.setMinter(address(this), true);\n        }\n\n        mintable.mint(_receiver, _amount);\n        require(IERC20(_token).totalSupply() <= maxTokenSupply, \"Timelock: maxTokenSupply exceeded\");\n    }\n\n    function _setPendingAction(bytes32 _action) private {\n        require(pendingActions[_action] == 0, \"Timelock: action already signalled\");\n        pendingActions[_action] = block.timestamp.add(buffer);\n        emit SignalPendingAction(_action);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action] != 0, \"Timelock: action not signalled\");\n        require(pendingActions[_action] < block.timestamp, \"Timelock: action time not yet passed\");\n    }\n\n    function _clearAction(bytes32 _action) private {\n        require(pendingActions[_action] != 0, \"Timelock: invalid _action\");\n        delete pendingActions[_action];\n        emit ClearAction(_action);\n    }\n}\n"
    },
    "contracts/core/interfaces/IXlxManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IXlxManager {\n    function usdg() external view returns (address);\n    function cooldownDuration() external returns (uint256);\n    function getAumInUsdg(bool maximise) external view returns (uint256);\n    function lastAddedAt(address _account) external returns (uint256);\n    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minXlx) external returns (uint256);\n    function addLiquidityForAccount(address _fundingAccount, address _account, address _token, uint256 _amount, uint256 _minUsdg, uint256 _minXlx) external returns (uint256);\n    function removeLiquidity(address _tokenOut, uint256 _xlxAmount, uint256 _minOut, address _receiver) external returns (uint256);\n    function removeLiquidityForAccount(address _account, address _tokenOut, uint256 _xlxAmount, uint256 _minOut, address _receiver) external returns (uint256);\n}\n"
    },
    "contracts/staking/Vester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"./interfaces/IVester.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../access/Governable.sol\";\n\ncontract Vester is IVester, IERC20, ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    uint256 public vestingDuration;\n\n    address public esToken;\n    address public pairToken;\n    address public claimableToken;\n\n    address public override rewardTracker;\n\n    uint256 public override totalSupply;\n    uint256 public pairSupply;\n\n    bool public hasMaxVestableAmount;\n\n    mapping (address => uint256) public balances;\n    mapping (address => uint256) public override pairAmounts;\n    mapping (address => uint256) public override cumulativeClaimAmounts;\n    mapping (address => uint256) public override claimedAmounts;\n    mapping (address => uint256) public lastVestingTimes;\n\n    mapping (address => uint256) public override transferredAverageStakedAmounts;\n    mapping (address => uint256) public override transferredCumulativeRewards;\n    mapping (address => uint256) public override cumulativeRewardDeductions;\n    mapping (address => uint256) public override bonusRewards;\n\n    mapping (address => bool) public isHandler;\n\n    event Claim(address receiver, uint256 amount);\n    event Deposit(address account, uint256 amount);\n    event Withdraw(address account, uint256 claimedAmount, uint256 balance);\n    event PairTransfer(address indexed from, address indexed to, uint256 value);\n\n    constructor (\n        string memory _name,\n        string memory _symbol,\n        uint256 _vestingDuration,\n        address _esToken,\n        address _pairToken,\n        address _claimableToken,\n        address _rewardTracker\n    ) public {\n        name = _name;\n        symbol = _symbol;\n\n        vestingDuration = _vestingDuration;\n\n        esToken = _esToken;\n        pairToken = _pairToken;\n        claimableToken = _claimableToken;\n\n        rewardTracker = _rewardTracker;\n\n        if (rewardTracker != address(0)) {\n            hasMaxVestableAmount = true;\n        }\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n\n    function setHasMaxVestableAmount(bool _hasMaxVestableAmount) external onlyGov {\n        hasMaxVestableAmount = _hasMaxVestableAmount;\n    }\n\n    function deposit(uint256 _amount) external nonReentrant {\n        _deposit(msg.sender, _amount);\n    }\n\n    function depositForAccount(address _account, uint256 _amount) external nonReentrant {\n        _validateHandler();\n        _deposit(_account, _amount);\n    }\n\n    function claim() external nonReentrant returns (uint256) {\n        return _claim(msg.sender, msg.sender);\n    }\n\n    function claimForAccount(address _account, address _receiver) external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _claim(_account, _receiver);\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function withdraw() external nonReentrant {\n        address account = msg.sender;\n        address _receiver = account;\n        _claim(account, _receiver);\n\n        uint256 claimedAmount = cumulativeClaimAmounts[account];\n        uint256 balance = balances[account];\n        uint256 totalVested = balance.add(claimedAmount);\n        require(totalVested > 0, \"Vester: vested amount is zero\");\n\n        if (hasPairToken()) {\n            uint256 pairAmount = pairAmounts[account];\n            _burnPair(account, pairAmount);\n            IERC20(pairToken).safeTransfer(_receiver, pairAmount);\n        }\n\n        IERC20(esToken).safeTransfer(_receiver, balance);\n        _burn(account, balance);\n\n        delete cumulativeClaimAmounts[account];\n        delete claimedAmounts[account];\n        delete lastVestingTimes[account];\n\n        emit Withdraw(account, claimedAmount, balance);\n    }\n\n    function transferStakeValues(address _sender, address _receiver) external override nonReentrant {\n        _validateHandler();\n\n        transferredAverageStakedAmounts[_receiver] = getCombinedAverageStakedAmount(_sender);\n        transferredAverageStakedAmounts[_sender] = 0;\n\n        uint256 transferredCumulativeReward = transferredCumulativeRewards[_sender];\n        uint256 cumulativeReward = IRewardTracker(rewardTracker).cumulativeRewards(_sender);\n\n        transferredCumulativeRewards[_receiver] = transferredCumulativeReward.add(cumulativeReward);\n        cumulativeRewardDeductions[_sender] = cumulativeReward;\n        transferredCumulativeRewards[_sender] = 0;\n\n        bonusRewards[_receiver] = bonusRewards[_sender];\n        bonusRewards[_sender] = 0;\n    }\n\n    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external override nonReentrant {\n        _validateHandler();\n        transferredAverageStakedAmounts[_account] = _amount;\n    }\n\n    function setTransferredCumulativeRewards(address _account, uint256 _amount) external override nonReentrant {\n        _validateHandler();\n        transferredCumulativeRewards[_account] = _amount;\n    }\n\n    function setCumulativeRewardDeductions(address _account, uint256 _amount) external override nonReentrant {\n        _validateHandler();\n        cumulativeRewardDeductions[_account] = _amount;\n    }\n\n    function setBonusRewards(address _account, uint256 _amount) external override nonReentrant {\n        _validateHandler();\n        bonusRewards[_account] = _amount;\n    }\n\n    function claimable(address _account) public override view returns (uint256) {\n        uint256 amount = cumulativeClaimAmounts[_account].sub(claimedAmounts[_account]);\n        uint256 nextClaimable = _getNextClaimableAmount(_account);\n        return amount.add(nextClaimable);\n    }\n\n    function getMaxVestableAmount(address _account) public override view returns (uint256) {\n        if (!hasRewardTracker()) { return 0; }\n\n        uint256 transferredCumulativeReward = transferredCumulativeRewards[_account];\n        uint256 bonusReward = bonusRewards[_account];\n        uint256 cumulativeReward = IRewardTracker(rewardTracker).cumulativeRewards(_account);\n        uint256 maxVestableAmount = cumulativeReward.add(transferredCumulativeReward).add(bonusReward);\n\n        uint256 cumulativeRewardDeduction = cumulativeRewardDeductions[_account];\n\n        if (maxVestableAmount < cumulativeRewardDeduction) {\n            return 0;\n        }\n\n        return maxVestableAmount.sub(cumulativeRewardDeduction);\n    }\n\n    function getCombinedAverageStakedAmount(address _account) public override view returns (uint256) {\n        uint256 cumulativeReward = IRewardTracker(rewardTracker).cumulativeRewards(_account);\n        uint256 transferredCumulativeReward = transferredCumulativeRewards[_account];\n        uint256 totalCumulativeReward = cumulativeReward.add(transferredCumulativeReward);\n        if (totalCumulativeReward == 0) { return 0; }\n\n        uint256 averageStakedAmount = IRewardTracker(rewardTracker).averageStakedAmounts(_account);\n        uint256 transferredAverageStakedAmount = transferredAverageStakedAmounts[_account];\n\n        return averageStakedAmount\n            .mul(cumulativeReward)\n            .div(totalCumulativeReward)\n            .add(\n                transferredAverageStakedAmount.mul(transferredCumulativeReward).div(totalCumulativeReward)\n            );\n    }\n\n    function getPairAmount(address _account, uint256 _esAmount) public view returns (uint256) {\n        if (!hasRewardTracker()) { return 0; }\n\n        uint256 combinedAverageStakedAmount = getCombinedAverageStakedAmount(_account);\n        if (combinedAverageStakedAmount == 0) {\n            return 0;\n        }\n\n        uint256 maxVestableAmount = getMaxVestableAmount(_account);\n        if (maxVestableAmount == 0) {\n            return 0;\n        }\n\n        return _esAmount.mul(combinedAverageStakedAmount).div(maxVestableAmount);\n    }\n\n    function hasRewardTracker() public view returns (bool) {\n        return rewardTracker != address(0);\n    }\n\n    function hasPairToken() public view returns (bool) {\n        return pairToken != address(0);\n    }\n\n    function getTotalVested(address _account) public view returns (uint256) {\n        return balances[_account].add(cumulativeClaimAmounts[_account]);\n    }\n\n    function balanceOf(address _account) public view override returns (uint256) {\n        return balances[_account];\n    }\n\n    // empty implementation, tokens are non-transferrable\n    function transfer(address /* recipient */, uint256 /* amount */) public override returns (bool) {\n        revert(\"Vester: non-transferrable\");\n    }\n\n    // empty implementation, tokens are non-transferrable\n    function allowance(address /* owner */, address /* spender */) public view virtual override returns (uint256) {\n        return 0;\n    }\n\n    // empty implementation, tokens are non-transferrable\n    function approve(address /* spender */, uint256 /* amount */) public virtual override returns (bool) {\n        revert(\"Vester: non-transferrable\");\n    }\n\n    // empty implementation, tokens are non-transferrable\n    function transferFrom(address /* sender */, address /* recipient */, uint256 /* amount */) public virtual override returns (bool) {\n        revert(\"Vester: non-transferrable\");\n    }\n\n    function getVestedAmount(address _account) public override view returns (uint256) {\n        uint256 balance = balances[_account];\n        uint256 cumulativeClaimAmount = cumulativeClaimAmounts[_account];\n        return balance.add(cumulativeClaimAmount);\n    }\n\n    function _mint(address _account, uint256 _amount) private {\n        require(_account != address(0), \"Vester: mint to the zero address\");\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _mintPair(address _account, uint256 _amount) private {\n        require(_account != address(0), \"Vester: mint to the zero address\");\n\n        pairSupply = pairSupply.add(_amount);\n        pairAmounts[_account] = pairAmounts[_account].add(_amount);\n\n        emit PairTransfer(address(0), _account, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) private {\n        require(_account != address(0), \"Vester: burn from the zero address\");\n\n        balances[_account] = balances[_account].sub(_amount, \"Vester: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(_amount);\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _burnPair(address _account, uint256 _amount) private {\n        require(_account != address(0), \"Vester: burn from the zero address\");\n\n        pairAmounts[_account] = pairAmounts[_account].sub(_amount, \"Vester: burn amount exceeds balance\");\n        pairSupply = pairSupply.sub(_amount);\n\n        emit PairTransfer(_account, address(0), _amount);\n    }\n\n    function _deposit(address _account, uint256 _amount) private {\n        require(_amount > 0, \"Vester: invalid _amount\");\n\n        _updateVesting(_account);\n\n        IERC20(esToken).safeTransferFrom(_account, address(this), _amount);\n\n        _mint(_account, _amount);\n\n        if (hasPairToken()) {\n            uint256 pairAmount = pairAmounts[_account];\n            uint256 nextPairAmount = getPairAmount(_account, balances[_account]);\n            if (nextPairAmount > pairAmount) {\n                uint256 pairAmountDiff = nextPairAmount.sub(pairAmount);\n                IERC20(pairToken).safeTransferFrom(_account, address(this), pairAmountDiff);\n                _mintPair(_account, pairAmountDiff);\n            }\n        }\n\n        if (hasMaxVestableAmount) {\n            uint256 maxAmount = getMaxVestableAmount(_account);\n            require(getTotalVested(_account) <= maxAmount, \"Vester: max vestable amount exceeded\");\n        }\n\n        emit Deposit(_account, _amount);\n    }\n\n    function _updateVesting(address _account) private {\n        uint256 amount = _getNextClaimableAmount(_account);\n        lastVestingTimes[_account] = block.timestamp;\n\n        if (amount == 0) {\n            return;\n        }\n\n        // transfer claimableAmount from balances to cumulativeClaimAmounts\n        _burn(_account, amount);\n        cumulativeClaimAmounts[_account] = cumulativeClaimAmounts[_account].add(amount);\n\n        IMintable(esToken).burn(address(this), amount);\n    }\n\n    function _getNextClaimableAmount(address _account) private view returns (uint256) {\n        uint256 timeDiff = block.timestamp.sub(lastVestingTimes[_account]);\n\n        uint256 balance = balances[_account];\n        if (balance == 0) { return 0; }\n\n        uint256 vestedAmount = getVestedAmount(_account);\n        uint256 claimableAmount = vestedAmount.mul(timeDiff).div(vestingDuration);\n\n        if (claimableAmount < balance) {\n            return claimableAmount;\n        }\n\n        return balance;\n    }\n\n    function _claim(address _account, address _receiver) private returns (uint256) {\n        _updateVesting(_account);\n        uint256 amount = claimable(_account);\n        claimedAmounts[_account] = claimedAmounts[_account].add(amount);\n        IERC20(claimableToken).safeTransfer(_receiver, amount);\n        emit Claim(_account, amount);\n        return amount;\n    }\n\n    function _validateHandler() private view {\n        require(isHandler[msg.sender], \"Vester: forbidden\");\n    }\n}\n"
    },
    "contracts/staking/interfaces/IRewardTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IRewardTracker {\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\n    function stakedAmounts(address _account) external view returns (uint256);\n    function updateRewards() external;\n    function stake(address _depositToken, uint256 _amount) external;\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\n    function unstake(address _depositToken, uint256 _amount) external;\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\n    function tokensPerInterval() external view returns (uint256);\n    function claim(address _receiver) external returns (uint256);\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n    function averageStakedAmounts(address _account) external view returns (uint256);\n    function cumulativeRewards(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/tokens/MintableBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./BaseToken.sol\";\nimport \"./interfaces/IMintable.sol\";\n\ncontract MintableBaseToken is BaseToken, IMintable {\n\n    mapping (address => bool) public override isMinter;\n\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public BaseToken(_name, _symbol, _initialSupply) {\n    }\n\n    modifier onlyMinter() {\n        require(isMinter[msg.sender], \"MintableBaseToken: forbidden\");\n        _;\n    }\n\n    function setMinter(address _minter, bool _isActive) external override onlyGov {\n        isMinter[_minter] = _isActive;\n    }\n\n    function mint(address _account, uint256 _amount) external override onlyMinter {\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override onlyMinter {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/tokens/BaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\n\nimport \"./interfaces/IYieldTracker.sol\";\nimport \"./interfaces/IBaseToken.sol\";\n\ncontract BaseToken is IERC20, IBaseToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    uint256 public override totalSupply;\n    uint256 public nonStakingSupply;\n\n    address public gov;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    address[] public yieldTrackers;\n    mapping (address => bool) public nonStakingAccounts;\n    mapping (address => bool) public admins;\n\n    bool public inPrivateTransferMode;\n    mapping (address => bool) public isHandler;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"BaseToken: forbidden\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"BaseToken: forbidden\");\n        _;\n    }\n\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public {\n        name = _name;\n        symbol = _symbol;\n        gov = msg.sender;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setInfo(string memory _name, string memory _symbol) external onlyGov {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function setYieldTrackers(address[] memory _yieldTrackers) external onlyGov {\n        yieldTrackers = _yieldTrackers;\n    }\n\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n\n    function removeAdmin(address _account) external override onlyGov {\n        admins[_account] = false;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external override onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external override onlyGov {\n        inPrivateTransferMode = _inPrivateTransferMode;\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n\n    function addNonStakingAccount(address _account) external onlyAdmin {\n        require(!nonStakingAccounts[_account], \"BaseToken: _account already marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = true;\n        nonStakingSupply = nonStakingSupply.add(balances[_account]);\n    }\n\n    function removeNonStakingAccount(address _account) external onlyAdmin {\n        require(nonStakingAccounts[_account], \"BaseToken: _account not marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = false;\n        nonStakingSupply = nonStakingSupply.sub(balances[_account]);\n    }\n\n    function recoverClaim(address _account, address _receiver) external onlyAdmin {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(_account, _receiver);\n        }\n    }\n\n    function claim(address _receiver) external {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(msg.sender, _receiver);\n        }\n    }\n\n    function totalStaked() external view override returns (uint256) {\n        return totalSupply.sub(nonStakingSupply);\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function stakedBalance(address _account) external view override returns (uint256) {\n        if (nonStakingAccounts[_account]) {\n            return 0;\n        }\n        return balances[_account];\n    }\n\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        if (isHandler[msg.sender]) {\n            _transfer(_sender, _recipient, _amount);\n            return true;\n        }\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"BaseToken: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"BaseToken: mint to the zero address\");\n\n        _updateRewards(_account);\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"BaseToken: burn from the zero address\");\n\n        _updateRewards(_account);\n\n        balances[_account] = balances[_account].sub(_amount, \"BaseToken: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"BaseToken: transfer from the zero address\");\n        require(_recipient != address(0), \"BaseToken: transfer to the zero address\");\n\n        if (inPrivateTransferMode) {\n            require(isHandler[msg.sender], \"BaseToken: msg.sender not whitelisted\");\n        }\n\n        _updateRewards(_sender);\n        _updateRewards(_recipient);\n\n        balances[_sender] = balances[_sender].sub(_amount, \"BaseToken: transfer amount exceeds balance\");\n        balances[_recipient] = balances[_recipient].add(_amount);\n\n        if (nonStakingAccounts[_sender]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        if (nonStakingAccounts[_recipient]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(_sender, _recipient,_amount);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"BaseToken: approve from the zero address\");\n        require(_spender != address(0), \"BaseToken: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _updateRewards(address _account) private {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).updateRewards(_account);\n        }\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IYieldTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IYieldTracker {\n    function claim(address _account, address _receiver) external returns (uint256);\n    function updateRewards(address _account) external;\n    function getTokensPerInterval() external view returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/xdx/XLX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../tokens/MintableBaseToken.sol\";\n\ncontract XLX is MintableBaseToken {\n    constructor() public MintableBaseToken(\"XDX LP\", \"XLX\", 0) {\n    }\n\n    function id() external pure returns (string memory _name) {\n        return \"XLX\";\n    }\n}\n"
    },
    "contracts/xdx/XDX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../tokens/MintableBaseToken.sol\";\n\ncontract XDX is MintableBaseToken {\n    constructor() public MintableBaseToken(\"XDX\", \"XDX\", 10000000000000000000000000) {\n    }\n\n    function id() external pure returns (string memory _name) {\n        return \"XDX\";\n    }\n}\n"
    },
    "contracts/xdx/EsXDX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../tokens/MintableBaseToken.sol\";\n\ncontract EsXDX is MintableBaseToken {\n    constructor() public MintableBaseToken(\"Escrowed XDX\", \"esXDX\", 0) {\n    }\n\n    function id() external pure returns (string memory _name) {\n        return \"esXDX\";\n    }\n}\n"
    },
    "contracts/tokens/SnapshotToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./MintableBaseToken.sol\";\n\ncontract SnapshotToken is MintableBaseToken {\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public MintableBaseToken(_name, _symbol, _initialSupply) {\n    }\n\n    function batchMint(address[] memory _accounts, uint256[] memory _amounts) external onlyMinter {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 amount = _amounts[i];\n            _mint(account, amount);\n        }\n    }\n}\n"
    },
    "contracts/peripherals/PriceFeedTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/ITimelockTarget.sol\";\nimport \"./interfaces/IHandlerTarget.sol\";\nimport \"../access/interfaces/IAdmin.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../oracle/interfaces/IFastPriceFeed.sol\";\nimport \"../referrals/interfaces/IReferralStorage.sol\";\nimport \"../tokens/interfaces/IYieldToken.sol\";\nimport \"../tokens/interfaces/IBaseToken.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../tokens/interfaces/IUSDG.sol\";\nimport \"../staking/interfaces/IVester.sol\";\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\n\ncontract PriceFeedTimelock {\n    using SafeMath for uint256;\n\n    uint256 public constant MAX_BUFFER = 5 days;\n\n    uint256 public buffer;\n    address public admin;\n\n    address public tokenManager;\n\n    mapping (bytes32 => uint256) public pendingActions;\n\n    mapping (address => bool) public isHandler;\n    mapping (address => bool) public isKeeper;\n\n    event SignalPendingAction(bytes32 action);\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action);\n    event SignalWithdrawToken(address target, address token, address receiver, uint256 amount, bytes32 action);\n    event SignalSetGov(address target, address gov, bytes32 action);\n    event SignalSetPriceFeedWatcher(address fastPriceFeed, address account, bool isActive);\n    event SignalPriceFeedSetTokenConfig(\n        address vaultPriceFeed,\n        address token,\n        address priceFeed,\n        uint256 priceDecimals,\n        bool isStrictStable\n    );\n    event ClearAction(bytes32 action);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Timelock: forbidden\");\n        _;\n    }\n\n    modifier onlyHandlerAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n\n    modifier onlyKeeperAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender] || isKeeper[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n\n    modifier onlyTokenManager() {\n        require(msg.sender == tokenManager, \"Timelock: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _admin,\n        uint256 _buffer,\n        address _tokenManager\n    ) public {\n        require(_buffer <= MAX_BUFFER, \"Timelock: invalid _buffer\");\n        admin = _admin;\n        buffer = _buffer;\n        tokenManager = _tokenManager;\n    }\n\n    function setAdmin(address _admin) external onlyTokenManager {\n        admin = _admin;\n    }\n\n    function setExternalAdmin(address _target, address _admin) external onlyAdmin {\n        require(_target != address(this), \"Timelock: invalid _target\");\n        IAdmin(_target).setAdmin(_admin);\n    }\n\n    function setContractHandler(address _handler, bool _isActive) external onlyAdmin {\n        isHandler[_handler] = _isActive;\n    }\n\n    function setKeeper(address _keeper, bool _isActive) external onlyAdmin {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setBuffer(uint256 _buffer) external onlyAdmin {\n        require(_buffer <= MAX_BUFFER, \"Timelock: invalid _buffer\");\n        require(_buffer > buffer, \"Timelock: buffer cannot be decreased\");\n        buffer = _buffer;\n    }\n\n    function setIsAmmEnabled(address _priceFeed, bool _isEnabled) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setIsAmmEnabled(_isEnabled);\n    }\n\n    function setIsSecondaryPriceEnabled(address _priceFeed, bool _isEnabled) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setIsSecondaryPriceEnabled(_isEnabled);\n    }\n\n    function setMaxStrictPriceDeviation(address _priceFeed, uint256 _maxStrictPriceDeviation) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setMaxStrictPriceDeviation(_maxStrictPriceDeviation);\n    }\n\n    function setUseV2Pricing(address _priceFeed, bool _useV2Pricing) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setUseV2Pricing(_useV2Pricing);\n    }\n\n    function setAdjustment(address _priceFeed, address _token, bool _isAdditive, uint256 _adjustmentBps) external onlyKeeperAndAbove {\n        IVaultPriceFeed(_priceFeed).setAdjustment(_token, _isAdditive, _adjustmentBps);\n    }\n\n    function setSpreadBasisPoints(address _priceFeed, address _token, uint256 _spreadBasisPoints) external onlyKeeperAndAbove {\n        IVaultPriceFeed(_priceFeed).setSpreadBasisPoints(_token, _spreadBasisPoints);\n    }\n\n    function setPriceSampleSpace(address _priceFeed,uint256 _priceSampleSpace) external onlyHandlerAndAbove {\n        require(_priceSampleSpace <= 5, \"Invalid _priceSampleSpace\");\n        IVaultPriceFeed(_priceFeed).setPriceSampleSpace(_priceSampleSpace);\n    }\n\n    function setVaultPriceFeed(address _fastPriceFeed, address _vaultPriceFeed) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setVaultPriceFeed(_vaultPriceFeed);\n    }\n\n    function setPriceDuration(address _fastPriceFeed, uint256 _priceDuration) external onlyHandlerAndAbove {\n        IFastPriceFeed(_fastPriceFeed).setPriceDuration(_priceDuration);\n    }\n\n    function setMaxPriceUpdateDelay(address _fastPriceFeed, uint256 _maxPriceUpdateDelay) external onlyHandlerAndAbove {\n        IFastPriceFeed(_fastPriceFeed).setMaxPriceUpdateDelay(_maxPriceUpdateDelay);\n    }\n\n    function setSpreadBasisPointsIfInactive(address _fastPriceFeed, uint256 _spreadBasisPointsIfInactive) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setSpreadBasisPointsIfInactive(_spreadBasisPointsIfInactive);\n    }\n\n    function setSpreadBasisPointsIfChainError(address _fastPriceFeed, uint256 _spreadBasisPointsIfChainError) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setSpreadBasisPointsIfChainError(_spreadBasisPointsIfChainError);\n    }\n\n    function setMinBlockInterval(address _fastPriceFeed, uint256 _minBlockInterval) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setMinBlockInterval(_minBlockInterval);\n    }\n\n    function setIsSpreadEnabled(address _fastPriceFeed, bool _isSpreadEnabled) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setIsSpreadEnabled(_isSpreadEnabled);\n    }\n\n    function setMaxDeviationBasisPoints(address _fastPriceFeed, uint256 _maxDeviationBasisPoints) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setMaxDeviationBasisPoints(_maxDeviationBasisPoints);\n    }\n\n    function setMaxCumulativeDeltaDiffs(address _fastPriceFeed, address[] memory _tokens,  uint256[] memory _maxCumulativeDeltaDiffs) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setMaxCumulativeDeltaDiffs(_tokens, _maxCumulativeDeltaDiffs);\n    }\n\n    function setPriceDataInterval(address _fastPriceFeed, uint256 _priceDataInterval) external onlyAdmin {\n        IFastPriceFeed(_fastPriceFeed).setPriceDataInterval(_priceDataInterval);\n    }\n\n    function transferIn(address _sender, address _token, uint256 _amount) external onlyAdmin {\n        IERC20(_token).transferFrom(_sender, address(this), _amount);\n    }\n\n    function signalApprove(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _setPendingAction(action);\n        emit SignalApprove(_token, _spender, _amount, action);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function signalWithdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit SignalWithdrawToken(_target, _token, _receiver, _amount, action);\n    }\n\n    function withdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IBaseToken(_target).withdrawToken(_token, _receiver, _amount);\n    }\n\n    function signalSetGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _setPendingAction(action);\n        emit SignalSetGov(_target, _gov, action);\n    }\n\n    function setGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _validateAction(action);\n        _clearAction(action);\n        ITimelockTarget(_target).setGov(_gov);\n    }\n\n    function signalSetPriceFeedWatcher(address _fastPriceFeed, address _account, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeedWatcher\", _fastPriceFeed, _account, _isActive));\n        _setPendingAction(action);\n        emit SignalSetPriceFeedWatcher(_fastPriceFeed, _account, _isActive);\n    }\n\n    function setPriceFeedWatcher(address _fastPriceFeed, address _account, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeedWatcher\", _fastPriceFeed, _account, _isActive));\n        _validateAction(action);\n        _clearAction(action);\n        IFastPriceFeed(_fastPriceFeed).setSigner(_account, _isActive);\n    }\n\n    function signalSetPriceFeedUpdater(address _fastPriceFeed, address _account, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeedUpdater\", _fastPriceFeed, _account, _isActive));\n        _setPendingAction(action);\n        emit SignalSetPriceFeedWatcher(_fastPriceFeed, _account, _isActive);\n    }\n\n    function setPriceFeedUpdater(address _fastPriceFeed, address _account, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeedUpdater\", _fastPriceFeed, _account, _isActive));\n        _validateAction(action);\n        _clearAction(action);\n        IFastPriceFeed(_fastPriceFeed).setUpdater(_account, _isActive);\n    }\n\n    function signalPriceFeedSetTokenConfig(\n        address _vaultPriceFeed,\n        address _token,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        bool _isStrictStable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"priceFeedSetTokenConfig\",\n            _vaultPriceFeed,\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        ));\n\n        _setPendingAction(action);\n\n        emit SignalPriceFeedSetTokenConfig(\n            _vaultPriceFeed,\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        );\n    }\n\n    function priceFeedSetTokenConfig(\n        address _vaultPriceFeed,\n        address _token,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        bool _isStrictStable\n    ) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n            \"priceFeedSetTokenConfig\",\n            _vaultPriceFeed,\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        ));\n\n        _validateAction(action);\n        _clearAction(action);\n\n        IVaultPriceFeed(_vaultPriceFeed).setTokenConfig(\n            _token,\n            _priceFeed,\n            _priceDecimals,\n            _isStrictStable\n        );\n    }\n\n    function cancelAction(bytes32 _action) external onlyAdmin {\n        _clearAction(_action);\n    }\n\n    function _setPendingAction(bytes32 _action) private {\n        pendingActions[_action] = block.timestamp.add(buffer);\n        emit SignalPendingAction(_action);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action] != 0, \"Timelock: action not signalled\");\n        require(pendingActions[_action] < block.timestamp, \"Timelock: action time not yet passed\");\n    }\n\n    function _clearAction(bytes32 _action) private {\n        require(pendingActions[_action] != 0, \"Timelock: invalid _action\");\n        delete pendingActions[_action];\n        emit ClearAction(_action);\n    }\n}\n"
    },
    "contracts/oracle/interfaces/IFastPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IFastPriceFeed {\n    function lastUpdatedAt() external view returns (uint256);\n    function lastUpdatedBlock() external view returns (uint256);\n    function setSigner(address _account, bool _isActive) external;\n    function setUpdater(address _account, bool _isActive) external;\n    function setPriceDuration(uint256 _priceDuration) external;\n    function setMaxPriceUpdateDelay(uint256 _maxPriceUpdateDelay) external;\n    function setSpreadBasisPointsIfInactive(uint256 _spreadBasisPointsIfInactive) external;\n    function setSpreadBasisPointsIfChainError(uint256 _spreadBasisPointsIfChainError) external;\n    function setMinBlockInterval(uint256 _minBlockInterval) external;\n    function setIsSpreadEnabled(bool _isSpreadEnabled) external;\n    function setMaxDeviationBasisPoints(uint256 _maxDeviationBasisPoints) external;\n    function setMaxCumulativeDeltaDiffs(address[] memory _tokens,  uint256[] memory _maxCumulativeDeltaDiffs) external;\n    function setPriceDataInterval(uint256 _priceDataInterval) external;\n    function setVaultPriceFeed(address _vaultPriceFeed) external;\n}\n"
    },
    "contracts/tokens/USDG.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IUSDG.sol\";\nimport \"./YieldToken.sol\";\n\ncontract USDG is YieldToken, IUSDG {\n\n    mapping (address => bool) public vaults;\n\n    modifier onlyVault() {\n        require(vaults[msg.sender], \"USDG: forbidden\");\n        _;\n    }\n\n    constructor(address _vault) public YieldToken(\"USD Gambit\", \"USDG\", 0) {\n        vaults[_vault] = true;\n    }\n\n    function addVault(address _vault) external override onlyGov {\n        vaults[_vault] = true;\n    }\n\n    function removeVault(address _vault) external override onlyGov {\n        vaults[_vault] = false;\n    }\n\n    function mint(address _account, uint256 _amount) external override onlyVault {\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override onlyVault {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/tokens/YieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\n\nimport \"./interfaces/IYieldTracker.sol\";\nimport \"./interfaces/IYieldToken.sol\";\n\ncontract YieldToken is IERC20, IYieldToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    uint256 public override totalSupply;\n    uint256 public nonStakingSupply;\n\n    address public gov;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    address[] public yieldTrackers;\n    mapping (address => bool) public nonStakingAccounts;\n    mapping (address => bool) public admins;\n\n    bool public inWhitelistMode;\n    mapping (address => bool) public whitelistedHandlers;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"YieldToken: forbidden\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"YieldToken: forbidden\");\n        _;\n    }\n\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public {\n        name = _name;\n        symbol = _symbol;\n        gov = msg.sender;\n        admins[msg.sender] = true;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setInfo(string memory _name, string memory _symbol) external onlyGov {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function setYieldTrackers(address[] memory _yieldTrackers) external onlyGov {\n        yieldTrackers = _yieldTrackers;\n    }\n\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n\n    function removeAdmin(address _account) external override onlyGov {\n        admins[_account] = false;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function setInWhitelistMode(bool _inWhitelistMode) external onlyGov {\n        inWhitelistMode = _inWhitelistMode;\n    }\n\n    function setWhitelistedHandler(address _handler, bool _isWhitelisted) external onlyGov {\n        whitelistedHandlers[_handler] = _isWhitelisted;\n    }\n\n    function addNonStakingAccount(address _account) external onlyAdmin {\n        require(!nonStakingAccounts[_account], \"YieldToken: _account already marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = true;\n        nonStakingSupply = nonStakingSupply.add(balances[_account]);\n    }\n\n    function removeNonStakingAccount(address _account) external onlyAdmin {\n        require(nonStakingAccounts[_account], \"YieldToken: _account not marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = false;\n        nonStakingSupply = nonStakingSupply.sub(balances[_account]);\n    }\n\n    function recoverClaim(address _account, address _receiver) external onlyAdmin {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(_account, _receiver);\n        }\n    }\n\n    function claim(address _receiver) external {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(msg.sender, _receiver);\n        }\n    }\n\n    function totalStaked() external view override returns (uint256) {\n        return totalSupply.sub(nonStakingSupply);\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function stakedBalance(address _account) external view override returns (uint256) {\n        if (nonStakingAccounts[_account]) {\n            return 0;\n        }\n        return balances[_account];\n    }\n\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"YieldToken: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"YieldToken: mint to the zero address\");\n\n        _updateRewards(_account);\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"YieldToken: burn from the zero address\");\n\n        _updateRewards(_account);\n\n        balances[_account] = balances[_account].sub(_amount, \"YieldToken: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"YieldToken: transfer from the zero address\");\n        require(_recipient != address(0), \"YieldToken: transfer to the zero address\");\n\n        if (inWhitelistMode) {\n            require(whitelistedHandlers[msg.sender], \"YieldToken: msg.sender not whitelisted\");\n        }\n\n        _updateRewards(_sender);\n        _updateRewards(_recipient);\n\n        balances[_sender] = balances[_sender].sub(_amount, \"YieldToken: transfer amount exceeds balance\");\n        balances[_recipient] = balances[_recipient].add(_amount);\n\n        if (nonStakingAccounts[_sender]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        if (nonStakingAccounts[_recipient]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(_sender, _recipient,_amount);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"YieldToken: approve from the zero address\");\n        require(_spender != address(0), \"YieldToken: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _updateRewards(address _account) private {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).updateRewards(_account);\n        }\n    }\n}\n"
    },
    "contracts/tokens/YieldTracker.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IDistributor.sol\";\nimport \"./interfaces/IYieldTracker.sol\";\nimport \"./interfaces/IYieldToken.sol\";\n\n// code adapated from https://github.com/trusttoken/smart-contracts/blob/master/contracts/truefi/TrueFarm.sol\ncontract YieldTracker is IYieldTracker, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PRECISION = 1e30;\n\n    address public gov;\n    address public yieldToken;\n    address public distributor;\n\n    uint256 public cumulativeRewardPerToken;\n    mapping (address => uint256) public claimableReward;\n    mapping (address => uint256) public previousCumulatedRewardPerToken;\n\n    event Claim(address receiver, uint256 amount);\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"YieldTracker: forbidden\");\n        _;\n    }\n\n    constructor(address _yieldToken) public {\n        gov = msg.sender;\n        yieldToken = _yieldToken;\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setDistributor(address _distributor) external onlyGov {\n        distributor = _distributor;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function claim(address _account, address _receiver) external override returns (uint256) {\n        require(msg.sender == yieldToken, \"YieldTracker: forbidden\");\n        updateRewards(_account);\n\n        uint256 tokenAmount = claimableReward[_account];\n        claimableReward[_account] = 0;\n\n        address rewardToken = IDistributor(distributor).getRewardToken(address(this));\n        IERC20(rewardToken).safeTransfer(_receiver, tokenAmount);\n        emit Claim(_account, tokenAmount);\n\n        return tokenAmount;\n    }\n\n    function getTokensPerInterval() external override view returns (uint256) {\n        return IDistributor(distributor).tokensPerInterval(address(this));\n    }\n\n    function claimable(address _account) external override view returns (uint256) {\n        uint256 stakedBalance = IYieldToken(yieldToken).stakedBalance(_account);\n        if (stakedBalance == 0) {\n            return claimableReward[_account];\n        }\n        uint256 pendingRewards = IDistributor(distributor).getDistributionAmount(address(this)).mul(PRECISION);\n        uint256 totalStaked = IYieldToken(yieldToken).totalStaked();\n        uint256 nextCumulativeRewardPerToken = cumulativeRewardPerToken.add(pendingRewards.div(totalStaked));\n        return claimableReward[_account].add(\n            stakedBalance.mul(nextCumulativeRewardPerToken.sub(previousCumulatedRewardPerToken[_account])).div(PRECISION));\n    }\n\n    function updateRewards(address _account) public override nonReentrant {\n        uint256 blockReward;\n\n        if (distributor != address(0)) {\n            blockReward = IDistributor(distributor).distribute();\n        }\n\n        uint256 _cumulativeRewardPerToken = cumulativeRewardPerToken;\n        uint256 totalStaked = IYieldToken(yieldToken).totalStaked();\n        // only update cumulativeRewardPerToken when there are stakers, i.e. when totalStaked > 0\n        // if blockReward == 0, then there will be no change to cumulativeRewardPerToken\n        if (totalStaked > 0 && blockReward > 0) {\n            _cumulativeRewardPerToken = _cumulativeRewardPerToken.add(blockReward.mul(PRECISION).div(totalStaked));\n            cumulativeRewardPerToken = _cumulativeRewardPerToken;\n        }\n\n        // cumulativeRewardPerToken can only increase\n        // so if cumulativeRewardPerToken is zero, it means there are no rewards yet\n        if (_cumulativeRewardPerToken == 0) {\n            return;\n        }\n\n        if (_account != address(0)) {\n            uint256 stakedBalance = IYieldToken(yieldToken).stakedBalance(_account);\n            uint256 _previousCumulatedReward = previousCumulatedRewardPerToken[_account];\n            uint256 _claimableReward = claimableReward[_account].add(\n                stakedBalance.mul(_cumulativeRewardPerToken.sub(_previousCumulatedReward)).div(PRECISION)\n            );\n\n            claimableReward[_account] = _claimableReward;\n            previousCumulatedRewardPerToken[_account] = _cumulativeRewardPerToken;\n        }\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IDistributor {\n    function distribute() external returns (uint256);\n    function getRewardToken(address _receiver) external view returns (address);\n    function getDistributionAmount(address _receiver) external view returns (uint256);\n    function tokensPerInterval(address _receiver) external view returns (uint256);\n}\n"
    },
    "contracts/peripherals/Reader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../tokens/interfaces/IYieldTracker.sol\";\nimport \"../tokens/interfaces/IYieldToken.sol\";\nimport \"../amm/interfaces/IPancakeFactory.sol\";\n\nimport \"../staking/interfaces/IVester.sol\";\nimport \"../access/Governable.sol\";\n\ncontract Reader is Governable {\n    using SafeMath for uint256;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant POSITION_PROPS_LENGTH = 9;\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant USDG_DECIMALS = 18;\n\n    bool public hasMaxGlobalShortSizes;\n\n    function setConfig(bool _hasMaxGlobalShortSizes) public onlyGov {\n        hasMaxGlobalShortSizes = _hasMaxGlobalShortSizes;\n    }\n\n    function getMaxAmountIn(IVault _vault, address _tokenIn, address _tokenOut) public view returns (uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 priceOut = _vault.getMaxPrice(_tokenOut);\n\n        uint256 tokenInDecimals = _vault.tokenDecimals(_tokenIn);\n        uint256 tokenOutDecimals = _vault.tokenDecimals(_tokenOut);\n\n        uint256 amountIn;\n\n        {\n            uint256 poolAmount = _vault.poolAmounts(_tokenOut);\n            uint256 reservedAmount = _vault.reservedAmounts(_tokenOut);\n            uint256 bufferAmount = _vault.bufferAmounts(_tokenOut);\n            uint256 subAmount = reservedAmount > bufferAmount ? reservedAmount : bufferAmount;\n            if (subAmount >= poolAmount) {\n                return 0;\n            }\n            uint256 availableAmount = poolAmount.sub(subAmount);\n            amountIn = availableAmount.mul(priceOut).div(priceIn).mul(10 ** tokenInDecimals).div(10 ** tokenOutDecimals);\n        }\n\n        uint256 maxUsdgAmount = _vault.maxUsdgAmounts(_tokenIn);\n\n        if (maxUsdgAmount != 0) {\n            if (maxUsdgAmount < _vault.usdgAmounts(_tokenIn)) {\n                return 0;\n            }\n\n            uint256 maxAmountIn = maxUsdgAmount.sub(_vault.usdgAmounts(_tokenIn));\n            maxAmountIn = maxAmountIn.mul(10 ** tokenInDecimals).div(10 ** USDG_DECIMALS);\n            maxAmountIn = maxAmountIn.mul(PRICE_PRECISION).div(priceIn);\n\n            if (amountIn > maxAmountIn) {\n                return maxAmountIn;\n            }\n        }\n\n        return amountIn;\n    }\n\n    function getAmountOut(IVault _vault, address _tokenIn, address _tokenOut, uint256 _amountIn) public view returns (uint256, uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n\n        uint256 tokenInDecimals = _vault.tokenDecimals(_tokenIn);\n        uint256 tokenOutDecimals = _vault.tokenDecimals(_tokenOut);\n\n        uint256 feeBasisPoints;\n        {\n            uint256 usdgAmount = _amountIn.mul(priceIn).div(PRICE_PRECISION);\n            usdgAmount = usdgAmount.mul(10 ** USDG_DECIMALS).div(10 ** tokenInDecimals);\n\n            bool isStableSwap = _vault.stableTokens(_tokenIn) && _vault.stableTokens(_tokenOut);\n            uint256 baseBps = isStableSwap ? _vault.stableSwapFeeBasisPoints() : _vault.swapFeeBasisPoints();\n            uint256 taxBps = isStableSwap ? _vault.stableTaxBasisPoints() : _vault.taxBasisPoints();\n            uint256 feesBasisPoints0 = _vault.getFeeBasisPoints(_tokenIn, usdgAmount, baseBps, taxBps, true);\n            uint256 feesBasisPoints1 = _vault.getFeeBasisPoints(_tokenOut, usdgAmount, baseBps, taxBps, false);\n            // use the higher of the two fee basis points\n            feeBasisPoints = feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n        }\n\n        uint256 priceOut = _vault.getMaxPrice(_tokenOut);\n        uint256 amountOut = _amountIn.mul(priceIn).div(priceOut);\n        amountOut = amountOut.mul(10 ** tokenOutDecimals).div(10 ** tokenInDecimals);\n\n        uint256 amountOutAfterFees = amountOut.mul(BASIS_POINTS_DIVISOR.sub(feeBasisPoints)).div(BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = amountOut.sub(amountOutAfterFees);\n\n        return (amountOutAfterFees, feeAmount);\n    }\n\n    function getFeeBasisPoints(IVault _vault, address _tokenIn, address _tokenOut, uint256 _amountIn) public view returns (uint256, uint256, uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 tokenInDecimals = _vault.tokenDecimals(_tokenIn);\n\n        uint256 usdgAmount = _amountIn.mul(priceIn).div(PRICE_PRECISION);\n        usdgAmount = usdgAmount.mul(10 ** USDG_DECIMALS).div(10 ** tokenInDecimals);\n\n        bool isStableSwap = _vault.stableTokens(_tokenIn) && _vault.stableTokens(_tokenOut);\n        uint256 baseBps = isStableSwap ? _vault.stableSwapFeeBasisPoints() : _vault.swapFeeBasisPoints();\n        uint256 taxBps = isStableSwap ? _vault.stableTaxBasisPoints() : _vault.taxBasisPoints();\n        uint256 feesBasisPoints0 = _vault.getFeeBasisPoints(_tokenIn, usdgAmount, baseBps, taxBps, true);\n        uint256 feesBasisPoints1 = _vault.getFeeBasisPoints(_tokenOut, usdgAmount, baseBps, taxBps, false);\n        // use the higher of the two fee basis points\n        uint256 feeBasisPoints = feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n\n        return (feeBasisPoints, feesBasisPoints0, feesBasisPoints1);\n    }\n\n    function getFees(address _vault, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amounts[i] = IVault(_vault).feeReserves(_tokens[i]);\n        }\n        return amounts;\n    }\n\n    function getTotalStaked(address[] memory _yieldTokens) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_yieldTokens.length);\n        for (uint256 i = 0; i < _yieldTokens.length; i++) {\n            IYieldToken yieldToken = IYieldToken(_yieldTokens[i]);\n            amounts[i] = yieldToken.totalStaked();\n        }\n        return amounts;\n    }\n\n    function getStakingInfo(address _account, address[] memory _yieldTrackers) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory amounts = new uint256[](_yieldTrackers.length * propsLength);\n        for (uint256 i = 0; i < _yieldTrackers.length; i++) {\n            IYieldTracker yieldTracker = IYieldTracker(_yieldTrackers[i]);\n            amounts[i * propsLength] = yieldTracker.claimable(_account);\n            amounts[i * propsLength + 1] = yieldTracker.getTokensPerInterval();\n        }\n        return amounts;\n    }\n\n    function getVestingInfo(address _account, address[] memory _vesters) public view returns (uint256[] memory) {\n        uint256 propsLength = 7;\n        uint256[] memory amounts = new uint256[](_vesters.length * propsLength);\n        for (uint256 i = 0; i < _vesters.length; i++) {\n            IVester vester = IVester(_vesters[i]);\n            amounts[i * propsLength] = vester.pairAmounts(_account);\n            amounts[i * propsLength + 1] = vester.getVestedAmount(_account);\n            amounts[i * propsLength + 2] = IERC20(_vesters[i]).balanceOf(_account);\n            amounts[i * propsLength + 3] = vester.claimedAmounts(_account);\n            amounts[i * propsLength + 4] = vester.claimable(_account);\n            amounts[i * propsLength + 5] = vester.getMaxVestableAmount(_account);\n            amounts[i * propsLength + 6] = vester.getCombinedAverageStakedAmount(_account);\n        }\n        return amounts;\n    }\n\n    function getPairInfo(address _factory, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 inputLength = 2;\n        uint256 propsLength = 2;\n        uint256[] memory amounts = new uint256[](_tokens.length / inputLength * propsLength);\n        for (uint256 i = 0; i < _tokens.length / inputLength; i++) {\n            address token0 = _tokens[i * inputLength];\n            address token1 = _tokens[i * inputLength + 1];\n            address pair = IPancakeFactory(_factory).getPair(token0, token1);\n\n            amounts[i * propsLength] = IERC20(token0).balanceOf(pair);\n            amounts[i * propsLength + 1] = IERC20(token1).balanceOf(pair);\n        }\n        return amounts;\n    }\n\n    function getFundingRates(address _vault, address _weth, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory fundingRates = new uint256[](_tokens.length * propsLength);\n        IVault vault = IVault(_vault);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n\n            uint256 fundingRateFactor = vault.stableTokens(token) ? vault.stableFundingRateFactor() : vault.fundingRateFactor();\n            uint256 reservedAmount = vault.reservedAmounts(token);\n            uint256 poolAmount = vault.poolAmounts(token);\n\n            if (poolAmount > 0) {\n                fundingRates[i * propsLength] = fundingRateFactor.mul(reservedAmount).div(poolAmount);\n            }\n\n            if (vault.cumulativeFundingRates(token) > 0) {\n                uint256 nextRate = vault.getNextFundingRate(token);\n                uint256 baseRate = vault.cumulativeFundingRates(token);\n                fundingRates[i * propsLength + 1] = baseRate.add(nextRate);\n            }\n        }\n\n        return fundingRates;\n    }\n\n    function getTokenSupply(IERC20 _token, address[] memory _excludedAccounts) public view returns (uint256) {\n        uint256 supply = _token.totalSupply();\n        for (uint256 i = 0; i < _excludedAccounts.length; i++) {\n            address account = _excludedAccounts[i];\n            uint256 balance = _token.balanceOf(account);\n            supply = supply.sub(balance);\n        }\n        return supply;\n    }\n\n    function getTotalBalance(IERC20 _token, address[] memory _accounts) public view returns (uint256) {\n        uint256 totalBalance = 0;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 balance = _token.balanceOf(account);\n            totalBalance = totalBalance.add(balance);\n        }\n        return totalBalance;\n    }\n\n    function getTokenBalances(address _account, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i] = _account.balance;\n                continue;\n            }\n            balances[i] = IERC20(token).balanceOf(_account);\n        }\n        return balances;\n    }\n\n    function getTokenBalancesWithSupplies(address _account, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory balances = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i * propsLength] = _account.balance;\n                balances[i * propsLength + 1] = 0;\n                continue;\n            }\n            balances[i * propsLength] = IERC20(token).balanceOf(_account);\n            balances[i * propsLength + 1] = IERC20(token).totalSupply();\n        }\n        return balances;\n    }\n\n    function getPrices(IVaultPriceFeed _priceFeed, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 6;\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            amounts[i * propsLength] = _priceFeed.getPrice(token, true, true, false);\n            amounts[i * propsLength + 1] = _priceFeed.getPrice(token, false, true, false);\n            amounts[i * propsLength + 2] = _priceFeed.getPrimaryPrice(token, true);\n            amounts[i * propsLength + 3] = _priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 4] = _priceFeed.isAdjustmentAdditive(token) ? 1 : 0;\n            amounts[i * propsLength + 5] = _priceFeed.adjustmentBasisPoints(token);\n        }\n\n        return amounts;\n    }\n\n    function getVaultTokenInfo(address _vault, address _weth, uint256 _usdgAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 10;\n\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdgAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdgAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.getMinPrice(token);\n            amounts[i * propsLength + 6] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 7] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 8] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 9] = priceFeed.getPrimaryPrice(token, true);\n        }\n\n        return amounts;\n    }\n\n    function getFullVaultTokenInfo(address _vault, address _weth, uint256 _usdgAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 12;\n\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdgAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdgAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdgAmounts(token);\n            amounts[i * propsLength + 7] = vault.getMinPrice(token);\n            amounts[i * propsLength + 8] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 9] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 10] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 11] = priceFeed.getPrimaryPrice(token, true);\n        }\n\n        return amounts;\n    }\n\n    function getVaultTokenInfoV2(address _vault, address _weth, uint256 _usdgAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 14;\n\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n\n            uint256 maxGlobalShortSize = hasMaxGlobalShortSizes ? vault.maxGlobalShortSizes(token) : 0;\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdgAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdgAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdgAmounts(token);\n            amounts[i * propsLength + 7] = vault.globalShortSizes(token);\n            amounts[i * propsLength + 8] = maxGlobalShortSize;\n            amounts[i * propsLength + 9] = vault.getMinPrice(token);\n            amounts[i * propsLength + 10] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 11] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 12] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 13] = priceFeed.getPrimaryPrice(token, true);\n        }\n\n        return amounts;\n    }\n\n    function getPositions(address _vault, address _account, address[] memory _collateralTokens, address[] memory _indexTokens, bool[] memory _isLong) public view returns(uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_collateralTokens.length * POSITION_PROPS_LENGTH);\n\n        for (uint256 i = 0; i < _collateralTokens.length; i++) {\n            {\n            (uint256 size,\n             uint256 collateral,\n             uint256 averagePrice,\n             uint256 entryFundingRate,\n             /* reserveAmount */,\n             uint256 realisedPnl,\n             bool hasRealisedProfit,\n             uint256 lastIncreasedTime) = IVault(_vault).getPosition(_account, _collateralTokens[i], _indexTokens[i], _isLong[i]);\n\n            amounts[i * POSITION_PROPS_LENGTH] = size;\n            amounts[i * POSITION_PROPS_LENGTH + 1] = collateral;\n            amounts[i * POSITION_PROPS_LENGTH + 2] = averagePrice;\n            amounts[i * POSITION_PROPS_LENGTH + 3] = entryFundingRate;\n            amounts[i * POSITION_PROPS_LENGTH + 4] = hasRealisedProfit ? 1 : 0;\n            amounts[i * POSITION_PROPS_LENGTH + 5] = realisedPnl;\n            amounts[i * POSITION_PROPS_LENGTH + 6] = lastIncreasedTime;\n            }\n\n            uint256 size = amounts[i * POSITION_PROPS_LENGTH];\n            uint256 averagePrice = amounts[i * POSITION_PROPS_LENGTH + 2];\n            uint256 lastIncreasedTime = amounts[i * POSITION_PROPS_LENGTH + 6];\n            if (averagePrice > 0) {\n                (bool hasProfit, uint256 delta) = IVault(_vault).getDelta(_indexTokens[i], size, averagePrice, _isLong[i], lastIncreasedTime);\n                amounts[i * POSITION_PROPS_LENGTH + 7] = hasProfit ? 1 : 0;\n                amounts[i * POSITION_PROPS_LENGTH + 8] = delta;\n            }\n        }\n\n        return amounts;\n    }\n}\n"
    },
    "contracts/amm/interfaces/IPancakeFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakeFactory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n"
    },
    "contracts/amm/PancakeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IPancakeFactory.sol\";\n\ncontract PancakeFactory is IPancakeFactory {\n    address public btc;\n    address public bnb;\n    address public busd;\n\n    address public bnbBusdPair;\n    address public btcBnbPair;\n\n    constructor(address[] memory _addresses) public {\n        btc = _addresses[0];\n        bnb = _addresses[1];\n        busd = _addresses[2];\n\n        bnbBusdPair = _addresses[3];\n        btcBnbPair = _addresses[4];\n    }\n\n    function getPair(address tokenA, address tokenB) external override view returns (address) {\n        if (tokenA == busd && tokenB == bnb) {\n            return bnbBusdPair;\n        }\n        if (tokenA == bnb && tokenB == btc) {\n            return btcBnbPair;\n        }\n        revert(\"Invalid tokens\");\n    }\n}\n"
    },
    "contracts/peripherals/VaultReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../core/interfaces/IBasePositionManager.sol\";\n\ncontract VaultReader {\n    function getVaultTokenInfoV3(address _vault, address _positionManager, address _weth, uint256 _usdgAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 14;\n\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n        IBasePositionManager positionManager = IBasePositionManager(_positionManager);\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdgAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdgAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdgAmounts(token);\n            amounts[i * propsLength + 7] = vault.globalShortSizes(token);\n            amounts[i * propsLength + 8] = positionManager.maxGlobalShortSizes(token);\n            amounts[i * propsLength + 9] = vault.getMinPrice(token);\n            amounts[i * propsLength + 10] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 11] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 12] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 13] = priceFeed.getPrimaryPrice(token, true);\n        }\n\n        return amounts;\n    }\n\n    function getVaultTokenInfoV4(address _vault, address _positionManager, address _weth, uint256 _usdgAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 15;\n\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n        IBasePositionManager positionManager = IBasePositionManager(_positionManager);\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdgAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdgAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdgAmounts(token);\n            amounts[i * propsLength + 7] = vault.globalShortSizes(token);\n            amounts[i * propsLength + 8] = positionManager.maxGlobalShortSizes(token);\n            amounts[i * propsLength + 9] = positionManager.maxGlobalLongSizes(token);\n            amounts[i * propsLength + 10] = vault.getMinPrice(token);\n            amounts[i * propsLength + 11] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 12] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 13] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 14] = priceFeed.getPrimaryPrice(token, true);\n        }\n\n        return amounts;\n    }\n}\n"
    },
    "contracts/core/interfaces/IBasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IBasePositionManager {\n    function maxGlobalLongSizes(address _token) external view returns (uint256);\n    function maxGlobalShortSizes(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/core/BasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../tokens/interfaces/IWETH.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/Address.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOrderBook.sol\";\nimport \"./interfaces/IBasePositionManager.sol\";\n\nimport \"../access/Governable.sol\";\nimport \"../peripherals/interfaces/ITimelock.sol\";\n\nimport \"../referrals/interfaces/IReferralStorage.sol\";\n\ncontract BasePositionManager is IBasePositionManager, ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n\n    address public admin;\n\n    address public vault;\n    address public router;\n    address public weth;\n\n    // to prevent using the deposit and withdrawal of collateral as a zero fee swap,\n    // there is a small depositFee charged if a collateral deposit results in the decrease\n    // of leverage for an existing position\n    // increasePositionBufferBps allows for a small amount of decrease of leverage\n    uint256 public depositFee;\n    uint256 public increasePositionBufferBps = 100;\n\n    address public referralStorage;\n\n    mapping (address => uint256) public feeReserves;\n\n    mapping (address => uint256) public override maxGlobalLongSizes;\n    mapping (address => uint256) public override maxGlobalShortSizes;\n\n    event SetDepositFee(uint256 depositFee);\n    event SetIncreasePositionBufferBps(uint256 increasePositionBufferBps);\n    event SetReferralStorage(address referralStorage);\n    event SetAdmin(address admin);\n    event WithdrawFees(address token, address receiver, uint256 amount);\n\n    event SetMaxGlobalSizes(\n        address[] tokens,\n        uint256[] longSizes,\n        uint256[] shortSizes\n    );\n\n    event IncreasePositionReferral(\n        address account,\n        uint256 sizeDelta,\n        uint256 marginFeeBasisPoints,\n        bytes32 referralCode,\n        address referrer\n    );\n\n    event DecreasePositionReferral(\n        address account,\n        uint256 sizeDelta,\n        uint256 marginFeeBasisPoints,\n        bytes32 referralCode,\n        address referrer\n    );\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"BasePositionManager: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _router,\n        address _weth,\n        uint256 _depositFee\n    ) public {\n        vault = _vault;\n        router = _router;\n        weth = _weth;\n        depositFee = _depositFee;\n\n        admin = msg.sender;\n    }\n\n    receive() external payable {\n        require(msg.sender == weth, \"BasePositionManager: invalid sender\");\n    }\n\n    function setAdmin(address _admin) external onlyGov {\n        admin = _admin;\n        emit SetAdmin(_admin);\n    }\n\n    function setDepositFee(uint256 _depositFee) external onlyAdmin {\n        depositFee = _depositFee;\n        emit SetDepositFee(_depositFee);\n    }\n\n    function setIncreasePositionBufferBps(uint256 _increasePositionBufferBps) external onlyAdmin {\n        increasePositionBufferBps = _increasePositionBufferBps;\n        emit SetIncreasePositionBufferBps(_increasePositionBufferBps);\n    }\n\n    function setReferralStorage(address _referralStorage) external onlyAdmin {\n        referralStorage = _referralStorage;\n        emit SetReferralStorage(_referralStorage);\n    }\n\n    function setMaxGlobalSizes(\n        address[] memory _tokens,\n        uint256[] memory _longSizes,\n        uint256[] memory _shortSizes\n    ) external onlyAdmin {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            maxGlobalLongSizes[token] = _longSizes[i];\n            maxGlobalShortSizes[token] = _shortSizes[i];\n        }\n\n        emit SetMaxGlobalSizes(_tokens, _longSizes, _shortSizes);\n    }\n\n    function withdrawFees(address _token, address _receiver) external onlyAdmin {\n        uint256 amount = feeReserves[_token];\n        if (amount == 0) { return; }\n\n        feeReserves[_token] = 0;\n        IERC20(_token).safeTransfer(_receiver, amount);\n\n        emit WithdrawFees(_token, _receiver, amount);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyGov {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function sendValue(address payable _receiver, uint256 _amount) external onlyGov {\n        _receiver.sendValue(_amount);\n    }\n\n    function _increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _price) internal {\n        address _vault = vault;\n\n        if (_isLong) {\n            require(IVault(_vault).getMaxPrice(_indexToken) <= _price, \"BasePositionManager: mark price higher than limit\");\n        } else {\n            require(IVault(_vault).getMinPrice(_indexToken) >= _price, \"BasePositionManager: mark price lower than limit\");\n        }\n\n        if (_isLong) {\n            uint256 maxGlobalLongSize = maxGlobalLongSizes[_indexToken];\n            if (maxGlobalLongSize > 0 && IVault(_vault).guaranteedUsd(_indexToken).add(_sizeDelta) > maxGlobalLongSize) {\n                revert(\"BasePositionManager: max global longs exceeded\");\n            }\n        } else {\n            uint256 maxGlobalShortSize = maxGlobalShortSizes[_indexToken];\n            if (maxGlobalShortSize > 0 && IVault(_vault).globalShortSizes(_indexToken).add(_sizeDelta) > maxGlobalShortSize) {\n                revert(\"BasePositionManager: max global shorts exceeded\");\n            }\n        }\n\n        address timelock = IVault(_vault).gov();\n\n        ITimelock(timelock).enableLeverage(_vault);\n        IRouter(router).pluginIncreasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n        ITimelock(timelock).disableLeverage(_vault);\n\n        _emitIncreasePositionReferral(_account, _sizeDelta);\n    }\n\n    function _decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price) internal returns (uint256) {\n        address _vault = vault;\n\n        if (_isLong) {\n            require(IVault(_vault).getMinPrice(_indexToken) >= _price, \"BasePositionManager: mark price lower than limit\");\n        } else {\n            require(IVault(_vault).getMaxPrice(_indexToken) <= _price, \"BasePositionManager: mark price higher than limit\");\n        }\n\n        address timelock = IVault(_vault).gov();\n\n        ITimelock(timelock).enableLeverage(_vault);\n        uint256 amountOut = IRouter(router).pluginDecreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n        ITimelock(timelock).disableLeverage(_vault);\n\n        _emitDecreasePositionReferral(_account, _sizeDelta);\n\n        return amountOut;\n    }\n\n    function _emitIncreasePositionReferral(address _account, uint256 _sizeDelta) internal {\n        address _referralStorage = referralStorage;\n        if (_referralStorage == address(0)) {\n            return;\n        }\n\n        (bytes32 referralCode, address referrer) = IReferralStorage(_referralStorage).getTraderReferralInfo(_account);\n        emit IncreasePositionReferral(\n            _account,\n            _sizeDelta,\n            IVault(vault).marginFeeBasisPoints(),\n            referralCode,\n            referrer\n        );\n    }\n\n    function _emitDecreasePositionReferral(address _account, uint256 _sizeDelta) internal {\n        address _referralStorage = referralStorage;\n        if (_referralStorage == address(0)) {\n            return;\n        }\n\n        (bytes32 referralCode, address referrer) = IReferralStorage(_referralStorage).getTraderReferralInfo(_account);\n\n        if (referralCode == bytes32(0)) {\n            return;\n        }\n\n        emit DecreasePositionReferral(\n            _account,\n            _sizeDelta,\n            IVault(vault).marginFeeBasisPoints(),\n            referralCode,\n            referrer\n        );\n    }\n\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) internal returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        revert(\"BasePositionManager: invalid _path.length\");\n    }\n\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) internal returns (uint256) {\n        uint256 amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        require(amountOut >= _minOut, \"BasePositionManager: insufficient amountOut\");\n        return amountOut;\n    }\n\n    function _transferInETH() internal {\n        if (msg.value != 0) {\n            IWETH(weth).deposit{value: msg.value}();\n        }\n    }\n\n    function _transferOutETH(uint256 _amountOut, address payable _receiver) internal {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.sendValue(_amountOut);\n    }\n\n    function _transferOutETHWithGasLimit(uint256 _amountOut, address payable _receiver) internal {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.transfer(_amountOut);\n    }\n\n    function _collectFees(\n        address _account,\n        address[] memory _path,\n        uint256 _amountIn,\n        address _indexToken,\n        bool _isLong,\n        uint256 _sizeDelta\n    ) internal returns (uint256) {\n        bool shouldDeductFee = _shouldDeductFee(\n            _account,\n            _path,\n            _amountIn,\n            _indexToken,\n            _isLong,\n            _sizeDelta\n        );\n\n        if (shouldDeductFee) {\n            uint256 afterFeeAmount = _amountIn.mul(BASIS_POINTS_DIVISOR.sub(depositFee)).div(BASIS_POINTS_DIVISOR);\n            uint256 feeAmount = _amountIn.sub(afterFeeAmount);\n            address feeToken = _path[_path.length - 1];\n            feeReserves[feeToken] = feeReserves[feeToken].add(feeAmount);\n            return afterFeeAmount;\n        }\n\n        return _amountIn;\n    }\n\n    function _shouldDeductFee(\n        address _account,\n        address[] memory _path,\n        uint256 _amountIn,\n        address _indexToken,\n        bool _isLong,\n        uint256 _sizeDelta\n    ) internal view returns (bool) {\n        // if the position is a short, do not charge a fee\n        if (!_isLong) { return false; }\n\n        // if the position size is not increasing, this is a collateral deposit\n        if (_sizeDelta == 0) { return true; }\n\n        address collateralToken = _path[_path.length - 1];\n\n        IVault _vault = IVault(vault);\n        (uint256 size, uint256 collateral, , , , , , ) = _vault.getPosition(_account, collateralToken, _indexToken, _isLong);\n\n        // if there is no existing position, do not charge a fee\n        if (size == 0) { return false; }\n\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 collateralDelta = _vault.tokenToUsdMin(collateralToken, _amountIn);\n        uint256 nextCollateral = collateral.add(collateralDelta);\n\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\n        // allow for a maximum of a increasePositionBufferBps decrease since there might be some swap fees taken from the collateral\n        uint256 nextLeverage = nextSize.mul(BASIS_POINTS_DIVISOR + increasePositionBufferBps).div(nextCollateral);\n\n        // deduct a fee if the leverage is decreased\n        return nextLeverage < prevLeverage;\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "contracts/core/interfaces/IOrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IOrderBook {\n\tfunction getSwapOrder(address _account, uint256 _orderIndex) external view returns (\n        address path0, \n        address path1,\n        address path2,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 triggerRatio,\n        bool triggerAboveThreshold,\n        bool shouldUnwrap,\n        uint256 executionFee\n    );\n\n    function getIncreaseOrder(address _account, uint256 _orderIndex) external view returns (\n        address purchaseToken, \n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    function getDecreaseOrder(address _account, uint256 _orderIndex) external view returns (\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n\n    function executeSwapOrder(address, uint256, address payable) external;\n    function executeDecreaseOrder(address, uint256, address payable) external;\n    function executeIncreaseOrder(address, uint256, address payable) external;\n}\n"
    },
    "contracts/core/PositionRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IPositionRouter.sol\";\n\nimport \"../peripherals/interfaces/ITimelock.sol\";\nimport \"./BasePositionManager.sol\";\n\ncontract PositionRouter is BasePositionManager, IPositionRouter {\n\n    struct IncreasePositionRequest {\n        address account;\n        address[] path;\n        address indexToken;\n        uint256 amountIn;\n        uint256 minOut;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 blockNumber;\n        uint256 blockTime;\n        bool hasCollateralInETH;\n    }\n\n    struct DecreasePositionRequest {\n        address account;\n        address[] path;\n        address indexToken;\n        uint256 collateralDelta;\n        uint256 sizeDelta;\n        bool isLong;\n        address receiver;\n        uint256 acceptablePrice;\n        uint256 minOut;\n        uint256 executionFee;\n        uint256 blockNumber;\n        uint256 blockTime;\n        bool withdrawETH;\n    }\n\n    uint256 public minExecutionFee;\n\n    uint256 public minBlockDelayKeeper;\n    uint256 public minTimeDelayPublic;\n    uint256 public maxTimeDelay;\n\n    bool public isLeverageEnabled = true;\n\n    bytes32[] public increasePositionRequestKeys;\n    bytes32[] public decreasePositionRequestKeys;\n\n    uint256 public override increasePositionRequestKeysStart;\n    uint256 public override decreasePositionRequestKeysStart;\n\n    mapping (address => bool) public isPositionKeeper;\n\n    mapping (address => uint256) public increasePositionsIndex;\n    mapping (bytes32 => IncreasePositionRequest) public increasePositionRequests;\n\n    mapping (address => uint256) public decreasePositionsIndex;\n    mapping (bytes32 => DecreasePositionRequest) public decreasePositionRequests;\n\n    event CreateIncreasePosition(\n        address indexed account,\n        address[] path,\n        address indexToken,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 acceptablePrice,\n        uint256 executionFee,\n        uint256 index,\n        uint256 blockNumber,\n        uint256 blockTime,\n        uint256 gasPrice\n    );\n\n    event ExecuteIncreasePosition(\n        address indexed account,\n        address[] path,\n        address indexToken,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 acceptablePrice,\n        uint256 executionFee,\n        uint256 blockGap,\n        uint256 timeGap\n    );\n\n    event CancelIncreasePosition(\n        address indexed account,\n        address[] path,\n        address indexToken,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 acceptablePrice,\n        uint256 executionFee,\n        uint256 blockGap,\n        uint256 timeGap\n    );\n\n    event CreateDecreasePosition(\n        address indexed account,\n        address[] path,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        address receiver,\n        uint256 acceptablePrice,\n        uint256 minOut,\n        uint256 executionFee,\n        uint256 index,\n        uint256 blockNumber,\n        uint256 blockTime\n    );\n\n    event ExecuteDecreasePosition(\n        address indexed account,\n        address[] path,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        address receiver,\n        uint256 acceptablePrice,\n        uint256 minOut,\n        uint256 executionFee,\n        uint256 blockGap,\n        uint256 timeGap\n    );\n\n    event CancelDecreasePosition(\n        address indexed account,\n        address[] path,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        address receiver,\n        uint256 acceptablePrice,\n        uint256 minOut,\n        uint256 executionFee,\n        uint256 blockGap,\n        uint256 timeGap\n    );\n\n    event SetPositionKeeper(address indexed account, bool isActive);\n    event SetMinExecutionFee(uint256 minExecutionFee);\n    event SetIsLeverageEnabled(bool isLeverageEnabled);\n    event SetDelayValues(uint256 minBlockDelayKeeper, uint256 minTimeDelayPublic, uint256 maxTimeDelay);\n    event SetRequestKeysStartValues(uint256 increasePositionRequestKeysStart, uint256 decreasePositionRequestKeysStart);\n\n    modifier onlyPositionKeeper() {\n        require(isPositionKeeper[msg.sender], \"PositionRouter: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _router,\n        address _weth,\n        uint256 _depositFee,\n        uint256 _minExecutionFee\n    ) public BasePositionManager(_vault, _router, _weth, _depositFee) {\n        minExecutionFee = _minExecutionFee;\n    }\n\n    function setPositionKeeper(address _account, bool _isActive) external onlyAdmin {\n        isPositionKeeper[_account] = _isActive;\n        emit SetPositionKeeper(_account, _isActive);\n    }\n\n    function setMinExecutionFee(uint256 _minExecutionFee) external onlyAdmin {\n        minExecutionFee = _minExecutionFee;\n        emit SetMinExecutionFee(_minExecutionFee);\n    }\n\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external onlyAdmin {\n        isLeverageEnabled = _isLeverageEnabled;\n        emit SetIsLeverageEnabled(_isLeverageEnabled);\n    }\n\n    function setDelayValues(uint256 _minBlockDelayKeeper, uint256 _minTimeDelayPublic, uint256 _maxTimeDelay) external onlyAdmin {\n        minBlockDelayKeeper = _minBlockDelayKeeper;\n        minTimeDelayPublic = _minTimeDelayPublic;\n        maxTimeDelay = _maxTimeDelay;\n        emit SetDelayValues(_minBlockDelayKeeper, _minTimeDelayPublic, _maxTimeDelay);\n    }\n\n    function setRequestKeysStartValues(uint256 _increasePositionRequestKeysStart, uint256 _decreasePositionRequestKeysStart) external onlyAdmin {\n        increasePositionRequestKeysStart = _increasePositionRequestKeysStart;\n        decreasePositionRequestKeysStart = _decreasePositionRequestKeysStart;\n\n        emit SetRequestKeysStartValues(_increasePositionRequestKeysStart, _decreasePositionRequestKeysStart);\n    }\n\n    function executeIncreasePositions(uint256 _endIndex, address payable _executionFeeReceiver) external override onlyPositionKeeper {\n        uint256 index = increasePositionRequestKeysStart;\n        uint256 length = increasePositionRequestKeys.length;\n\n        if (index >= length) { return; }\n\n        if (_endIndex > length) {\n            _endIndex = length;\n        }\n\n        while (index < _endIndex) {\n            bytes32 key = increasePositionRequestKeys[index];\n\n            // if the request was executed then delete the key from the array\n            // if the request was not executed then break from the loop, this can happen if the\n            // minimum number of blocks has not yet passed\n            // an error could be thrown if the request is too old or if the slippage is\n            // higher than what the user specified, or if there is insufficient liquidity for the position\n            // in case an error was thrown, cancel the request\n            try this.executeIncreasePosition(key, _executionFeeReceiver) returns (bool _wasExecuted) {\n                if (!_wasExecuted) { break; }\n            } catch {\n                // wrap this call in a try catch to prevent invalid cancels from blocking the loop\n                try this.cancelIncreasePosition(key, _executionFeeReceiver) returns (bool _wasCancelled) {\n                    if (!_wasCancelled) { break; }\n                } catch {}\n            }\n\n            delete increasePositionRequestKeys[index];\n            index++;\n        }\n\n        increasePositionRequestKeysStart = index;\n    }\n\n    function executeDecreasePositions(uint256 _endIndex, address payable _executionFeeReceiver) external override onlyPositionKeeper {\n        uint256 index = decreasePositionRequestKeysStart;\n        uint256 length = decreasePositionRequestKeys.length;\n\n        if (index >= length) { return; }\n\n        if (_endIndex > length) {\n            _endIndex = length;\n        }\n\n        while (index < _endIndex) {\n            bytes32 key = decreasePositionRequestKeys[index];\n\n            // if the request was executed then delete the key from the array\n            // if the request was not executed then break from the loop, this can happen if the\n            // minimum number of blocks has not yet passed\n            // an error could be thrown if the request is too old\n            // in case an error was thrown, cancel the request\n            try this.executeDecreasePosition(key, _executionFeeReceiver) returns (bool _wasExecuted) {\n                if (!_wasExecuted) { break; }\n            } catch {\n                // wrap this call in a try catch to prevent invalid cancels from blocking the loop\n                try this.cancelDecreasePosition(key, _executionFeeReceiver) returns (bool _wasCancelled) {\n                    if (!_wasCancelled) { break; }\n                } catch {}\n            }\n\n            delete decreasePositionRequestKeys[index];\n            index++;\n        }\n\n        decreasePositionRequestKeysStart = index;\n    }\n\n    function createIncreasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _acceptablePrice,\n        uint256 _executionFee,\n        bytes32 _referralCode\n    ) external payable nonReentrant {\n        require(_executionFee >= minExecutionFee, \"PositionRouter: invalid executionFee\");\n        require(msg.value == _executionFee, \"PositionRouter: invalid msg.value\");\n        require(_path.length == 1 || _path.length == 2, \"PositionRouter: invalid _path length\");\n\n        _transferInETH();\n        _setTraderReferralCode(_referralCode);\n\n        if (_amountIn > 0) {\n            IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n        }\n\n        _createIncreasePosition(\n            msg.sender,\n            _path,\n            _indexToken,\n            _amountIn,\n            _minOut,\n            _sizeDelta,\n            _isLong,\n            _acceptablePrice,\n            _executionFee,\n            false\n        );\n    }\n\n    function createIncreasePositionETH(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _acceptablePrice,\n        uint256 _executionFee,\n        bytes32 _referralCode\n    ) external payable nonReentrant {\n        require(_executionFee >= minExecutionFee, \"PositionRouter: invalid executionFee\");\n        require(msg.value >= _executionFee, \"PositionRouter: invalid msg.value\");\n        require(_path.length == 1 || _path.length == 2, \"PositionRouter: invalid _path length\");\n        require(_path[0] == weth, \"PositionRouter: invalid _path\");\n\n        _transferInETH();\n        _setTraderReferralCode(_referralCode);\n\n        uint256 amountIn = msg.value.sub(_executionFee);\n\n        _createIncreasePosition(\n            msg.sender,\n            _path,\n            _indexToken,\n            amountIn,\n            _minOut,\n            _sizeDelta,\n            _isLong,\n            _acceptablePrice,\n            _executionFee,\n            true\n        );\n    }\n\n    function createDecreasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _acceptablePrice,\n        uint256 _minOut,\n        uint256 _executionFee,\n        bool _withdrawETH\n    ) external payable nonReentrant {\n        require(_executionFee >= minExecutionFee, \"PositionRouter: invalid executionFee\");\n        require(msg.value == _executionFee, \"PositionRouter: invalid msg.value\");\n        require(_path.length == 1 || _path.length == 2, \"PositionRouter: invalid _path length\");\n\n        if (_withdrawETH) {\n            require(_path[_path.length - 1] == weth, \"PositionRouter: invalid _path\");\n        }\n\n        _transferInETH();\n\n        _createDecreasePosition(\n            msg.sender,\n            _path,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            _receiver,\n            _acceptablePrice,\n            _minOut,\n            _executionFee,\n            _withdrawETH\n        );\n    }\n\n    function getRequestQueueLengths() external view returns (uint256, uint256, uint256, uint256) {\n        return (\n            increasePositionRequestKeysStart,\n            increasePositionRequestKeys.length,\n            decreasePositionRequestKeysStart,\n            decreasePositionRequestKeys.length\n        );\n    }\n\n    function executeIncreasePosition(bytes32 _key, address payable _executionFeeReceiver) public nonReentrant returns (bool) {\n        IncreasePositionRequest memory request = increasePositionRequests[_key];\n        // if the request was already executed or cancelled, return true so that the executeIncreasePositions loop will continue executing the next request\n        if (request.account == address(0)) { return true; }\n\n        bool shouldExecute = _validateExecution(request.blockNumber, request.blockTime, request.account);\n        if (!shouldExecute) { return false; }\n\n        delete increasePositionRequests[_key];\n\n       if (request.amountIn > 0) {\n           uint256 amountIn = request.amountIn;\n\n           if (request.path.length > 1) {\n               IERC20(request.path[0]).safeTransfer(vault, request.amountIn);\n               amountIn = _swap(request.path, request.minOut, address(this));\n           }\n\n           uint256 afterFeeAmount = _collectFees(msg.sender, request.path, amountIn, request.indexToken, request.isLong, request.sizeDelta);\n           IERC20(request.path[request.path.length - 1]).safeTransfer(vault, afterFeeAmount);\n       }\n\n       _increasePosition(request.account, request.path[request.path.length - 1], request.indexToken, request.sizeDelta, request.isLong, request.acceptablePrice);\n\n       _transferOutETH(request.executionFee, _executionFeeReceiver);\n\n        emit ExecuteIncreasePosition(\n            request.account,\n            request.path,\n            request.indexToken,\n            request.amountIn,\n            request.minOut,\n            request.sizeDelta,\n            request.isLong,\n            request.acceptablePrice,\n            request.executionFee,\n            block.number.sub(request.blockNumber),\n            block.timestamp.sub(request.blockTime)\n        );\n\n        return true;\n    }\n\n    function cancelIncreasePosition(bytes32 _key, address payable _executionFeeReceiver) public nonReentrant returns (bool) {\n        IncreasePositionRequest memory request = increasePositionRequests[_key];\n        // if the request was already executed or cancelled, return true so that the executeIncreasePositions loop will continue executing the next request\n        if (request.account == address(0)) { return true; }\n\n        bool shouldCancel = _validateCancellation(request.blockNumber, request.blockTime, request.account);\n        if (!shouldCancel) { return false; }\n\n        delete increasePositionRequests[_key];\n\n        if (request.hasCollateralInETH) {\n            _transferOutETHWithGasLimit(request.amountIn, payable(request.account));\n        } else {\n            IERC20(request.path[0]).safeTransfer(request.account, request.amountIn);\n        }\n\n       _transferOutETH(request.executionFee, _executionFeeReceiver);\n\n        emit CancelIncreasePosition(\n            request.account,\n            request.path,\n            request.indexToken,\n            request.amountIn,\n            request.minOut,\n            request.sizeDelta,\n            request.isLong,\n            request.acceptablePrice,\n            request.executionFee,\n            block.number.sub(request.blockNumber),\n            block.timestamp.sub(request.blockTime)\n        );\n\n        return true;\n    }\n\n    function executeDecreasePosition(bytes32 _key, address payable _executionFeeReceiver) public nonReentrant returns (bool) {\n        DecreasePositionRequest memory request = decreasePositionRequests[_key];\n        // if the request was already executed or cancelled, return true so that the executeDecreasePositions loop will continue executing the next request\n        if (request.account == address(0)) { return true; }\n\n        bool shouldExecute = _validateExecution(request.blockNumber, request.blockTime, request.account);\n        if (!shouldExecute) { return false; }\n\n        delete decreasePositionRequests[_key];\n\n        uint256 amountOut = _decreasePosition(request.account, request.path[0], request.indexToken, request.collateralDelta, request.sizeDelta, request.isLong, address(this), request.acceptablePrice);\n\n        if (request.path.length > 1) {\n            IERC20(request.path[0]).safeTransfer(vault, amountOut);\n            amountOut = _swap(request.path, request.minOut, address(this));\n        }\n\n        if (request.withdrawETH) {\n           _transferOutETHWithGasLimit(amountOut, payable(request.receiver));\n        } else {\n           IERC20(request.path[request.path.length - 1]).safeTransfer(request.receiver, amountOut);\n        }\n\n       _transferOutETH(request.executionFee, _executionFeeReceiver);\n\n        emit ExecuteDecreasePosition(\n            request.account,\n            request.path,\n            request.indexToken,\n            request.collateralDelta,\n            request.sizeDelta,\n            request.isLong,\n            request.receiver,\n            request.acceptablePrice,\n            request.minOut,\n            request.executionFee,\n            block.number.sub(request.blockNumber),\n            block.timestamp.sub(request.blockTime)\n        );\n\n        return true;\n    }\n\n    function cancelDecreasePosition(bytes32 _key, address payable _executionFeeReceiver) public nonReentrant returns (bool) {\n        DecreasePositionRequest memory request = decreasePositionRequests[_key];\n        // if the request was already executed or cancelled, return true so that the executeDecreasePositions loop will continue executing the next request\n        if (request.account == address(0)) { return true; }\n\n        bool shouldCancel = _validateCancellation(request.blockNumber, request.blockTime, request.account);\n        if (!shouldCancel) { return false; }\n\n        delete decreasePositionRequests[_key];\n\n       _transferOutETH(request.executionFee, _executionFeeReceiver);\n\n        emit CancelDecreasePosition(\n            request.account,\n            request.path,\n            request.indexToken,\n            request.collateralDelta,\n            request.sizeDelta,\n            request.isLong,\n            request.receiver,\n            request.acceptablePrice,\n            request.minOut,\n            request.executionFee,\n            block.number.sub(request.blockNumber),\n            block.timestamp.sub(request.blockTime)\n        );\n\n        return true;\n    }\n\n    function getRequestKey(address _account, uint256 _index) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_account, _index));\n    }\n\n    function getIncreasePositionRequestPath(bytes32 _key) public view returns (address[] memory) {\n        IncreasePositionRequest memory request = increasePositionRequests[_key];\n        return request.path;\n    }\n\n    function getDecreasePositionRequestPath(bytes32 _key) public view returns (address[] memory) {\n        DecreasePositionRequest memory request = decreasePositionRequests[_key];\n        return request.path;\n    }\n\n    function _setTraderReferralCode(bytes32 _referralCode) internal {\n        if (_referralCode != bytes32(0) && referralStorage != address(0)) {\n            IReferralStorage(referralStorage).setTraderReferralCode(msg.sender, _referralCode);\n        }\n    }\n\n    function _validateExecution(uint256 _positionBlockNumber, uint256 _positionBlockTime, address _account) internal view returns (bool) {\n        if (_positionBlockTime.add(maxTimeDelay) <= block.timestamp) {\n            revert(\"PositionRouter: request has expired\");\n        }\n\n        bool isKeeperCall = msg.sender == address(this) || isPositionKeeper[msg.sender];\n\n        if (!isLeverageEnabled && !isKeeperCall) {\n            revert(\"PositionRouter: forbidden\");\n        }\n\n        if (isKeeperCall) {\n            return _positionBlockNumber.add(minBlockDelayKeeper) <= block.number;\n        }\n\n        require(msg.sender == _account, \"PositionRouter: forbidden\");\n\n        require(_positionBlockTime.add(minTimeDelayPublic) <= block.timestamp, \"PositionRouter: min delay not yet passed\");\n\n        return true;\n    }\n\n    function _validateCancellation(uint256 _positionBlockNumber, uint256 _positionBlockTime, address _account) internal view returns (bool) {\n        bool isKeeperCall = msg.sender == address(this) || isPositionKeeper[msg.sender];\n\n        if (!isLeverageEnabled && !isKeeperCall) {\n            revert(\"PositionRouter: forbidden\");\n        }\n\n        if (isKeeperCall) {\n            return _positionBlockNumber.add(minBlockDelayKeeper) <= block.number;\n        }\n\n        require(msg.sender == _account, \"PositionRouter: forbidden\");\n\n        require(_positionBlockTime.add(minTimeDelayPublic) <= block.timestamp, \"PositionRouter: min delay not yet passed\");\n\n        return true;\n    }\n\n    function _createIncreasePosition(\n        address _account,\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _acceptablePrice,\n        uint256 _executionFee,\n        bool _hasCollateralInETH\n    ) internal {\n        uint256 index = increasePositionsIndex[_account].add(1);\n        increasePositionsIndex[_account] = index;\n\n        IncreasePositionRequest memory request = IncreasePositionRequest(\n            _account,\n            _path,\n            _indexToken,\n            _amountIn,\n            _minOut,\n            _sizeDelta,\n            _isLong,\n            _acceptablePrice,\n            _executionFee,\n            block.number,\n            block.timestamp,\n            _hasCollateralInETH\n        );\n\n        bytes32 key = getRequestKey(_account, index);\n        increasePositionRequests[key] = request;\n\n        increasePositionRequestKeys.push(key);\n\n        emit CreateIncreasePosition(\n            _account,\n            _path,\n            _indexToken,\n            _amountIn,\n            _minOut,\n            _sizeDelta,\n            _isLong,\n            _acceptablePrice,\n            _executionFee,\n            index,\n            block.number,\n            block.timestamp,\n            tx.gasprice\n        );\n    }\n\n    function _createDecreasePosition(\n        address _account,\n        address[] memory _path,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _acceptablePrice,\n        uint256 _minOut,\n        uint256 _executionFee,\n        bool _withdrawETH\n    ) internal {\n        uint256 index = decreasePositionsIndex[_account].add(1);\n        decreasePositionsIndex[_account] = index;\n\n        DecreasePositionRequest memory request = DecreasePositionRequest(\n            _account,\n            _path,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            _receiver,\n            _acceptablePrice,\n            _minOut,\n            _executionFee,\n            block.number,\n            block.timestamp,\n            _withdrawETH\n        );\n\n        bytes32 key = getRequestKey(_account, index);\n        decreasePositionRequests[key] = request;\n\n        decreasePositionRequestKeys.push(key);\n\n        emit CreateDecreasePosition(\n            _account,\n            _path,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            _receiver,\n            _acceptablePrice,\n            _minOut,\n            _executionFee,\n            index,\n            block.number,\n            block.timestamp\n        );\n    }\n}\n"
    },
    "contracts/core/interfaces/IPositionRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPositionRouter {\n    function increasePositionRequestKeysStart() external returns (uint256);\n    function decreasePositionRequestKeysStart() external returns (uint256);\n    function executeIncreasePositions(uint256 _count, address payable _executionFeeReceiver) external;\n    function executeDecreasePositions(uint256 _count, address payable _executionFeeReceiver) external;\n}\n"
    },
    "contracts/oracle/FastPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"./interfaces/ISecondaryPriceFeed.sol\";\nimport \"./interfaces/IFastPriceFeed.sol\";\nimport \"./interfaces/IFastPriceEvents.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../core/interfaces/IPositionRouter.sol\";\nimport \"../access/Governable.sol\";\n\npragma solidity 0.6.12;\n\ncontract FastPriceFeed is ISecondaryPriceFeed, IFastPriceFeed, Governable {\n    using SafeMath for uint256;\n\n    // fit data in a uint256 slot to save gas costs\n    struct PriceDataItem {\n        uint160 refPrice; // Chainlink price\n        uint32 refTime; // last updated at time\n        uint32 cumulativeRefDelta; // cumulative Chainlink price delta\n        uint32 cumulativeFastDelta; // cumulative fast price delta\n    }\n\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n\n    uint256 public constant CUMULATIVE_DELTA_PRECISION = 10 * 1000 * 1000;\n\n    uint256 public constant MAX_REF_PRICE = type(uint160).max;\n    uint256 public constant MAX_CUMULATIVE_REF_DELTA = type(uint32).max;\n    uint256 public constant MAX_CUMULATIVE_FAST_DELTA = type(uint32).max;\n\n    // uint256(~0) is 256 bits of 1s\n    // shift the 1s by (256 - 32) to get (256 - 32) 0s followed by 32 1s\n    uint256 constant public BITMASK_32 = uint256(~0) >> (256 - 32);\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n\n    uint256 public constant MAX_PRICE_DURATION = 30 minutes;\n\n    bool public isInitialized;\n    bool public isSpreadEnabled = false;\n\n    address public vaultPriceFeed;\n    address public fastPriceEvents;\n\n    address public tokenManager;\n\n    address public positionRouter;\n\n    uint256 public override lastUpdatedAt;\n    uint256 public override lastUpdatedBlock;\n\n    uint256 public priceDuration;\n    uint256 public maxPriceUpdateDelay;\n    uint256 public spreadBasisPointsIfInactive;\n    uint256 public spreadBasisPointsIfChainError;\n    uint256 public minBlockInterval;\n    uint256 public maxTimeDeviation;\n\n    uint256 public priceDataInterval;\n\n    // allowed deviation from primary price\n    uint256 public maxDeviationBasisPoints;\n\n    uint256 public minAuthorizations;\n    uint256 public disableFastPriceVoteCount = 0;\n\n    mapping (address => bool) public isUpdater;\n\n    mapping (address => uint256) public prices;\n    mapping (address => PriceDataItem) public priceData;\n    mapping (address => uint256) public maxCumulativeDeltaDiffs;\n\n    mapping (address => bool) public isSigner;\n    mapping (address => bool) public disableFastPriceVotes;\n\n    // array of tokens used in setCompactedPrices, saves L1 calldata gas costs\n    address[] public tokens;\n    // array of tokenPrecisions used in setCompactedPrices, saves L1 calldata gas costs\n    // if the token price will be sent with 3 decimals, then tokenPrecision for that token\n    // should be 10 ** 3\n    uint256[] public tokenPrecisions;\n\n    event DisableFastPrice(address signer);\n    event EnableFastPrice(address signer);\n    event PriceData(address token, uint256 refPrice, uint256 fastPrice, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta);\n    event MaxCumulativeDeltaDiffExceeded(address token, uint256 refPrice, uint256 fastPrice, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta);\n\n    modifier onlySigner() {\n        require(isSigner[msg.sender], \"FastPriceFeed: forbidden\");\n        _;\n    }\n\n    modifier onlyUpdater() {\n        require(isUpdater[msg.sender], \"FastPriceFeed: forbidden\");\n        _;\n    }\n\n    modifier onlyTokenManager() {\n        require(msg.sender == tokenManager, \"FastPriceFeed: forbidden\");\n        _;\n    }\n\n    constructor(\n      uint256 _priceDuration,\n      uint256 _maxPriceUpdateDelay,\n      uint256 _minBlockInterval,\n      uint256 _maxDeviationBasisPoints,\n      address _fastPriceEvents,\n      address _tokenManager,\n      address _positionRouter\n    ) public {\n        require(_priceDuration <= MAX_PRICE_DURATION, \"FastPriceFeed: invalid _priceDuration\");\n        priceDuration = _priceDuration;\n        maxPriceUpdateDelay = _maxPriceUpdateDelay;\n        minBlockInterval = _minBlockInterval;\n        maxDeviationBasisPoints = _maxDeviationBasisPoints;\n        fastPriceEvents = _fastPriceEvents;\n        tokenManager = _tokenManager;\n        positionRouter = _positionRouter;\n    }\n\n    function initialize(uint256 _minAuthorizations, address[] memory _signers, address[] memory _updaters) public onlyGov {\n        require(!isInitialized, \"FastPriceFeed: already initialized\");\n        isInitialized = true;\n\n        minAuthorizations = _minAuthorizations;\n\n        for (uint256 i = 0; i < _signers.length; i++) {\n            address signer = _signers[i];\n            isSigner[signer] = true;\n        }\n\n        for (uint256 i = 0; i < _updaters.length; i++) {\n            address updater = _updaters[i];\n            isUpdater[updater] = true;\n        }\n    }\n\n    function setTokenManager(address _tokenManager) external onlyGov {\n        tokenManager = _tokenManager;\n    }\n\n    function setSigner(address _account, bool _isActive) external override onlyGov {\n        isSigner[_account] = _isActive;\n    }\n\n    function setUpdater(address _account, bool _isActive) external override onlyGov {\n        isUpdater[_account] = _isActive;\n    }\n\n    function setFastPriceEvents(address _fastPriceEvents) external onlyGov {\n      fastPriceEvents = _fastPriceEvents;\n    }\n\n    function setVaultPriceFeed(address _vaultPriceFeed) external override onlyGov {\n      vaultPriceFeed = _vaultPriceFeed;\n    }\n\n    function setMaxTimeDeviation(uint256 _maxTimeDeviation) external onlyGov {\n        maxTimeDeviation = _maxTimeDeviation;\n    }\n\n    function setPriceDuration(uint256 _priceDuration) external override onlyGov {\n        require(_priceDuration <= MAX_PRICE_DURATION, \"FastPriceFeed: invalid _priceDuration\");\n        priceDuration = _priceDuration;\n    }\n\n    function setMaxPriceUpdateDelay(uint256 _maxPriceUpdateDelay) external override onlyGov {\n        maxPriceUpdateDelay = _maxPriceUpdateDelay;\n    }\n\n    function setSpreadBasisPointsIfInactive(uint256 _spreadBasisPointsIfInactive) external override onlyGov {\n        spreadBasisPointsIfInactive = _spreadBasisPointsIfInactive;\n    }\n\n    function setSpreadBasisPointsIfChainError(uint256 _spreadBasisPointsIfChainError) external override onlyGov {\n        spreadBasisPointsIfChainError = _spreadBasisPointsIfChainError;\n    }\n\n    function setMinBlockInterval(uint256 _minBlockInterval) external override onlyGov {\n        minBlockInterval = _minBlockInterval;\n    }\n\n    function setIsSpreadEnabled(bool _isSpreadEnabled) external override onlyGov {\n        isSpreadEnabled = _isSpreadEnabled;\n    }\n\n    function setMaxDeviationBasisPoints(uint256 _maxDeviationBasisPoints) external override onlyGov {\n        maxDeviationBasisPoints = _maxDeviationBasisPoints;\n    }\n\n    function setMaxCumulativeDeltaDiffs(address[] memory _tokens,  uint256[] memory _maxCumulativeDeltaDiffs) external override onlyGov {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            maxCumulativeDeltaDiffs[token] = _maxCumulativeDeltaDiffs[i];\n        }\n    }\n\n    function setPriceDataInterval(uint256 _priceDataInterval) external override onlyGov {\n        priceDataInterval = _priceDataInterval;\n    }\n\n    function setLastUpdatedAt(uint256 _lastUpdatedAt) external onlyGov {\n        lastUpdatedAt = _lastUpdatedAt;\n    }\n\n    function setMinAuthorizations(uint256 _minAuthorizations) external onlyTokenManager {\n        minAuthorizations = _minAuthorizations;\n    }\n\n    function setTokens(address[] memory _tokens, uint256[] memory _tokenPrecisions) external onlyGov {\n        require(_tokens.length == _tokenPrecisions.length, \"FastPriceFeed: invalid lengths\");\n        tokens = _tokens;\n        tokenPrecisions = _tokenPrecisions;\n    }\n\n    function setPrices(address[] memory _tokens, uint256[] memory _prices, uint256 _timestamp) external onlyUpdater {\n        bool shouldUpdate = _setLastUpdatedValues(_timestamp);\n\n        if (shouldUpdate) {\n            address _fastPriceEvents = fastPriceEvents;\n            address _vaultPriceFeed = vaultPriceFeed;\n\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                address token = _tokens[i];\n                _setPrice(token, _prices[i], _vaultPriceFeed, _fastPriceEvents);\n            }\n        }\n    }\n\n    function setCompactedPrices(uint256[] memory _priceBitArray, uint256 _timestamp) external onlyUpdater {\n        bool shouldUpdate = _setLastUpdatedValues(_timestamp);\n\n        if (shouldUpdate) {\n            address _fastPriceEvents = fastPriceEvents;\n            address _vaultPriceFeed = vaultPriceFeed;\n\n            for (uint256 i = 0; i < _priceBitArray.length; i++) {\n                uint256 priceBits = _priceBitArray[i];\n\n                for (uint256 j = 0; j < 8; j++) {\n                    uint256 index = i * 8 + j;\n                    if (index >= tokens.length) { return; }\n\n                    uint256 startBit = 32 * j;\n                    uint256 price = (priceBits >> startBit) & BITMASK_32;\n\n                    address token = tokens[i * 8 + j];\n                    uint256 tokenPrecision = tokenPrecisions[i * 8 + j];\n                    uint256 adjustedPrice = price.mul(PRICE_PRECISION).div(tokenPrecision);\n\n                    _setPrice(token, adjustedPrice, _vaultPriceFeed, _fastPriceEvents);\n                }\n            }\n        }\n    }\n\n    function setPricesWithBits(uint256 _priceBits, uint256 _timestamp) external onlyUpdater {\n        _setPricesWithBits(_priceBits, _timestamp);\n    }\n\n    function setPricesWithBitsAndExecute(\n        uint256 _priceBits,\n        uint256 _timestamp,\n        uint256 _endIndexForIncreasePositions,\n        uint256 _endIndexForDecreasePositions,\n        uint256 _maxIncreasePositions,\n        uint256 _maxDecreasePositions\n    ) external onlyUpdater {\n        _setPricesWithBits(_priceBits, _timestamp);\n\n        IPositionRouter _positionRouter = IPositionRouter(positionRouter);\n        uint256 maxEndIndexForIncrease = _positionRouter.increasePositionRequestKeysStart().add(_maxIncreasePositions);\n        uint256 maxEndIndexForDecrease = _positionRouter.increasePositionRequestKeysStart().add(_maxDecreasePositions);\n\n        if (_endIndexForIncreasePositions > maxEndIndexForIncrease) {\n            _endIndexForIncreasePositions = maxEndIndexForIncrease;\n        }\n\n        if (_endIndexForDecreasePositions > maxEndIndexForDecrease) {\n            _endIndexForDecreasePositions = maxEndIndexForDecrease;\n        }\n\n        _positionRouter.executeIncreasePositions(_endIndexForIncreasePositions, payable(msg.sender));\n        _positionRouter.executeDecreasePositions(_endIndexForDecreasePositions, payable(msg.sender));\n    }\n\n    function disableFastPrice() external onlySigner {\n        require(!disableFastPriceVotes[msg.sender], \"FastPriceFeed: already voted\");\n        disableFastPriceVotes[msg.sender] = true;\n        disableFastPriceVoteCount = disableFastPriceVoteCount.add(1);\n\n        emit DisableFastPrice(msg.sender);\n    }\n\n    function enableFastPrice() external onlySigner {\n        require(disableFastPriceVotes[msg.sender], \"FastPriceFeed: already enabled\");\n        disableFastPriceVotes[msg.sender] = false;\n        disableFastPriceVoteCount = disableFastPriceVoteCount.sub(1);\n\n        emit EnableFastPrice(msg.sender);\n    }\n\n    // under regular operation, the fastPrice (prices[token]) is returned and there is no spread returned from this function,\n    // though VaultPriceFeed might apply its own spread\n    //\n    // if the fastPrice has not been updated within priceDuration then it is ignored and only _refPrice with a spread is used (spread: spreadBasisPointsIfInactive)\n    // in case the fastPrice has not been updated for maxPriceUpdateDelay then the _refPrice with a larger spread is used (spread: spreadBasisPointsIfChainError)\n    //\n    // there will be a spread from the _refPrice to the fastPrice in the following cases:\n    // - in case isSpreadEnabled is set to true\n    // - in case the maxDeviationBasisPoints between _refPrice and fastPrice is exceeded\n    // - in case watchers flag an issue\n    // - in case the cumulativeFastDelta exceeds the cumulativeRefDelta by the maxCumulativeDeltaDiff\n    function getPrice(address _token, uint256 _refPrice, bool _maximise) external override view returns (uint256) {\n        if (block.timestamp > lastUpdatedAt.add(maxPriceUpdateDelay)) {\n            if (_maximise) {\n                return _refPrice.mul(BASIS_POINTS_DIVISOR.add(spreadBasisPointsIfChainError)).div(BASIS_POINTS_DIVISOR);\n            }\n\n            return _refPrice.mul(BASIS_POINTS_DIVISOR.sub(spreadBasisPointsIfChainError)).div(BASIS_POINTS_DIVISOR);\n        }\n\n        if (block.timestamp > lastUpdatedAt.add(priceDuration)) {\n            if (_maximise) {\n                return _refPrice.mul(BASIS_POINTS_DIVISOR.add(spreadBasisPointsIfInactive)).div(BASIS_POINTS_DIVISOR);\n            }\n\n            return _refPrice.mul(BASIS_POINTS_DIVISOR.sub(spreadBasisPointsIfInactive)).div(BASIS_POINTS_DIVISOR);\n        }\n\n        uint256 fastPrice = prices[_token];\n        if (fastPrice == 0) { return _refPrice; }\n\n        uint256 diffBasisPoints = _refPrice > fastPrice ? _refPrice.sub(fastPrice) : fastPrice.sub(_refPrice);\n        diffBasisPoints = diffBasisPoints.mul(BASIS_POINTS_DIVISOR).div(_refPrice);\n\n        // create a spread between the _refPrice and the fastPrice if the maxDeviationBasisPoints is exceeded\n        // or if watchers have flagged an issue with the fast price\n        bool hasSpread = !favorFastPrice(_token) || diffBasisPoints > maxDeviationBasisPoints;\n\n        if (hasSpread) {\n            // return the higher of the two prices\n            if (_maximise) {\n                return _refPrice > fastPrice ? _refPrice : fastPrice;\n            }\n\n            // return the lower of the two prices\n            return _refPrice < fastPrice ? _refPrice : fastPrice;\n        }\n\n        return fastPrice;\n    }\n\n    function favorFastPrice(address _token) public view returns (bool) {\n        if (isSpreadEnabled) {\n            return false;\n        }\n\n        if (disableFastPriceVoteCount >= minAuthorizations) {\n            // force a spread if watchers have flagged an issue with the fast price\n            return false;\n        }\n\n        (/* uint256 prevRefPrice */, /* uint256 refTime */, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta) = getPriceData(_token);\n        if (cumulativeFastDelta > cumulativeRefDelta && cumulativeFastDelta.sub(cumulativeRefDelta) > maxCumulativeDeltaDiffs[_token]) {\n            // force a spread if the cumulative delta for the fast price feed exceeds the cumulative delta\n            // for the Chainlink price feed by the maxCumulativeDeltaDiff allowed\n            return false;\n        }\n\n        return true;\n    }\n\n    function getPriceData(address _token) public view returns (uint256, uint256, uint256, uint256) {\n        PriceDataItem memory data = priceData[_token];\n        return (uint256(data.refPrice), uint256(data.refTime), uint256(data.cumulativeRefDelta), uint256(data.cumulativeFastDelta));\n    }\n\n    function _setPricesWithBits(uint256 _priceBits, uint256 _timestamp) private {\n        bool shouldUpdate = _setLastUpdatedValues(_timestamp);\n\n        if (shouldUpdate) {\n            address _fastPriceEvents = fastPriceEvents;\n            address _vaultPriceFeed = vaultPriceFeed;\n\n            for (uint256 j = 0; j < 8; j++) {\n                uint256 index = j;\n                if (index >= tokens.length) { return; }\n\n                uint256 startBit = 32 * j;\n                uint256 price = (_priceBits >> startBit) & BITMASK_32;\n\n                address token = tokens[j];\n                uint256 tokenPrecision = tokenPrecisions[j];\n                uint256 adjustedPrice = price.mul(PRICE_PRECISION).div(tokenPrecision);\n\n                _setPrice(token, adjustedPrice, _vaultPriceFeed, _fastPriceEvents);\n            }\n        }\n    }\n\n    function _setPrice(address _token, uint256 _price, address _vaultPriceFeed, address _fastPriceEvents) private {\n        if (_vaultPriceFeed != address(0)) {\n            uint256 refPrice = IVaultPriceFeed(_vaultPriceFeed).getLatestPrimaryPrice(_token);\n            uint256 fastPrice = prices[_token];\n\n            (uint256 prevRefPrice, uint256 refTime, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta) = getPriceData(_token);\n\n            if (prevRefPrice > 0) {\n                uint256 refDeltaAmount = refPrice > prevRefPrice ? refPrice.sub(prevRefPrice) : prevRefPrice.sub(refPrice);\n                uint256 fastDeltaAmount = fastPrice > _price ? fastPrice.sub(_price) : _price.sub(fastPrice);\n\n                // reset cumulative delta values if it is a new time window\n                if (refTime.div(priceDataInterval) != block.timestamp.div(priceDataInterval)) {\n                    cumulativeRefDelta = 0;\n                    cumulativeFastDelta = 0;\n                }\n\n                cumulativeRefDelta = cumulativeRefDelta.add(refDeltaAmount.mul(CUMULATIVE_DELTA_PRECISION).div(prevRefPrice));\n                cumulativeFastDelta = cumulativeFastDelta.add(fastDeltaAmount.mul(CUMULATIVE_DELTA_PRECISION).div(fastPrice));\n            }\n\n            if (cumulativeFastDelta > cumulativeRefDelta && cumulativeFastDelta.sub(cumulativeRefDelta) > maxCumulativeDeltaDiffs[_token]) {\n                emit MaxCumulativeDeltaDiffExceeded(_token, refPrice, fastPrice, cumulativeRefDelta, cumulativeFastDelta);\n            }\n\n            _setPriceData(_token, refPrice, cumulativeRefDelta, cumulativeFastDelta);\n            emit PriceData(_token, refPrice, fastPrice, cumulativeRefDelta, cumulativeFastDelta);\n        }\n\n        prices[_token] = _price;\n        _emitPriceEvent(_fastPriceEvents, _token, _price);\n    }\n\n    function _setPriceData(address _token, uint256 _refPrice, uint256 _cumulativeRefDelta, uint256 _cumulativeFastDelta) private {\n        require(_refPrice < MAX_REF_PRICE, \"FastPriceFeed: invalid refPrice\");\n        // skip validation of block.timestamp, it should only be out of range after the year 2100\n        require(_cumulativeRefDelta < MAX_CUMULATIVE_REF_DELTA, \"FastPriceFeed: invalid cumulativeRefDelta\");\n        require(_cumulativeFastDelta < MAX_CUMULATIVE_FAST_DELTA, \"FastPriceFeed: invalid cumulativeFastDelta\");\n\n        priceData[_token] = PriceDataItem(\n            uint160(_refPrice),\n            uint32(block.timestamp),\n            uint32(_cumulativeRefDelta),\n            uint32(_cumulativeFastDelta)\n        );\n    }\n\n    function _emitPriceEvent(address _fastPriceEvents, address _token, uint256 _price) private {\n        if (_fastPriceEvents == address(0)) {\n            return;\n        }\n\n        IFastPriceEvents(_fastPriceEvents).emitPriceEvent(_token, _price);\n    }\n\n    function _setLastUpdatedValues(uint256 _timestamp) private returns (bool) {\n        if (minBlockInterval > 0) {\n            require(block.number.sub(lastUpdatedBlock) >= minBlockInterval, \"FastPriceFeed: minBlockInterval not yet passed\");\n        }\n\n        uint256 _maxTimeDeviation = maxTimeDeviation;\n        require(_timestamp > block.timestamp.sub(_maxTimeDeviation), \"FastPriceFeed: _timestamp below allowed range\");\n        require(_timestamp < block.timestamp.add(_maxTimeDeviation), \"FastPriceFeed: _timestamp exceeds allowed range\");\n\n        // do not update prices if _timestamp is before the current lastUpdatedAt value\n        if (_timestamp < lastUpdatedAt) {\n            return false;\n        }\n\n        lastUpdatedAt = _timestamp;\n        lastUpdatedBlock = block.number;\n\n        return true;\n    }\n}\n"
    },
    "contracts/oracle/interfaces/ISecondaryPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ISecondaryPriceFeed {\n    function getPrice(address _token, uint256 _referencePrice, bool _maximise) external view returns (uint256);\n}\n"
    },
    "contracts/oracle/interfaces/IFastPriceEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IFastPriceEvents {\n    function emitPriceEvent(address _token, uint256 _price) external;\n}\n"
    },
    "contracts/oracle/FastPriceEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"./interfaces/IFastPriceEvents.sol\";\nimport \"../access/Governable.sol\";\n\npragma solidity 0.6.12;\n\ncontract FastPriceEvents is IFastPriceEvents, Governable {\n\n    mapping (address => bool) public isPriceFeed;\n    event PriceUpdate(address token, uint256 price, address priceFeed);\n\n    function setIsPriceFeed(address _priceFeed, bool _isPriceFeed) external onlyGov {\n      isPriceFeed[_priceFeed] = _isPriceFeed;\n    }\n\n    function emitPriceEvent(address _token, uint256 _price) external override {\n      require(isPriceFeed[msg.sender], \"FastPriceEvents: invalid sender\");\n      emit PriceUpdate(_token, _price, msg.sender);\n    }\n}\n"
    },
    "contracts/core/VaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"./interfaces/IVaultPriceFeed.sol\";\nimport \"../oracle/interfaces/IPriceFeed.sol\";\nimport \"../oracle/interfaces/ISecondaryPriceFeed.sol\";\nimport \"../oracle/interfaces/IChainlinkFlags.sol\";\nimport \"../amm/interfaces/IPancakePair.sol\";\n\npragma solidity 0.6.12;\n\ncontract VaultPriceFeed is IVaultPriceFeed {\n    using SafeMath for uint256;\n\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant ONE_USD = PRICE_PRECISION;\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant MAX_SPREAD_BASIS_POINTS = 50;\n    uint256 public constant MAX_ADJUSTMENT_INTERVAL = 2 hours;\n    uint256 public constant MAX_ADJUSTMENT_BASIS_POINTS = 20;\n\n    // Identifier of the Sequencer offline flag on the Flags contract\n    address constant private FLAG_ARBITRUM_SEQ_OFFLINE = address(bytes20(bytes32(uint256(keccak256(\"chainlink.flags.arbitrum-seq-offline\")) - 1)));\n\n    address public gov;\n    address public chainlinkFlags;\n\n    bool public isAmmEnabled = true;\n    bool public isSecondaryPriceEnabled = true;\n    bool public useV2Pricing = false;\n    bool public favorPrimaryPrice = false;\n    uint256 public priceSampleSpace = 3;\n    uint256 public maxStrictPriceDeviation = 0;\n    address public secondaryPriceFeed;\n    uint256 public spreadThresholdBasisPoints = 30;\n\n    address public btc;\n    address public eth;\n    address public bnb;\n    address public bnbBusd;\n    address public ethBnb;\n    address public btcBnb;\n\n    mapping (address => address) public priceFeeds;\n    mapping (address => uint256) public priceDecimals;\n    mapping (address => uint256) public spreadBasisPoints;\n    // Chainlink can return prices for stablecoins\n    // that differs from 1 USD by a larger percentage than stableSwapFeeBasisPoints\n    // we use strictStableTokens to cap the price to 1 USD\n    // this allows us to configure stablecoins like DAI as being a stableToken\n    // while not being a strictStableToken\n    mapping (address => bool) public strictStableTokens;\n\n    mapping (address => uint256) public override adjustmentBasisPoints;\n    mapping (address => bool) public override isAdjustmentAdditive;\n    mapping (address => uint256) public lastAdjustmentTimings;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"VaultPriceFeed: forbidden\");\n        _;\n    }\n\n    constructor() public {\n        gov = msg.sender;\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setChainlinkFlags(address _chainlinkFlags) external onlyGov {\n        chainlinkFlags = _chainlinkFlags;\n    }\n\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external override onlyGov {\n        require(\n            lastAdjustmentTimings[_token].add(MAX_ADJUSTMENT_INTERVAL) < block.timestamp,\n            \"VaultPriceFeed: adjustment frequency exceeded\"\n        );\n        require(_adjustmentBps <= MAX_ADJUSTMENT_BASIS_POINTS, \"invalid _adjustmentBps\");\n        isAdjustmentAdditive[_token] = _isAdditive;\n        adjustmentBasisPoints[_token] = _adjustmentBps;\n        lastAdjustmentTimings[_token] = block.timestamp;\n    }\n\n    function setUseV2Pricing(bool _useV2Pricing) external override onlyGov {\n        useV2Pricing = _useV2Pricing;\n    }\n\n    function setIsAmmEnabled(bool _isEnabled) external override onlyGov {\n        isAmmEnabled = _isEnabled;\n    }\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external override onlyGov {\n        isSecondaryPriceEnabled = _isEnabled;\n    }\n\n    function setSecondaryPriceFeed(address _secondaryPriceFeed) external onlyGov {\n        secondaryPriceFeed = _secondaryPriceFeed;\n    }\n\n    function setTokens(address _btc, address _eth, address _bnb) external onlyGov {\n        btc = _btc;\n        eth = _eth;\n        bnb = _bnb;\n    }\n\n    function setPairs(address _bnbBusd, address _ethBnb, address _btcBnb) external onlyGov {\n        bnbBusd = _bnbBusd;\n        ethBnb = _ethBnb;\n        btcBnb = _btcBnb;\n    }\n\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external override onlyGov {\n        require(_spreadBasisPoints <= MAX_SPREAD_BASIS_POINTS, \"VaultPriceFeed: invalid _spreadBasisPoints\");\n        spreadBasisPoints[_token] = _spreadBasisPoints;\n    }\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external override onlyGov {\n        spreadThresholdBasisPoints = _spreadThresholdBasisPoints;\n    }\n\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external override onlyGov {\n        favorPrimaryPrice = _favorPrimaryPrice;\n    }\n\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external override onlyGov {\n        require(_priceSampleSpace > 0, \"VaultPriceFeed: invalid _priceSampleSpace\");\n        priceSampleSpace = _priceSampleSpace;\n    }\n\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external override onlyGov {\n        maxStrictPriceDeviation = _maxStrictPriceDeviation;\n    }\n\n    function setTokenConfig(\n        address _token,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        bool _isStrictStable\n    ) external override onlyGov {\n        priceFeeds[_token] = _priceFeed;\n        priceDecimals[_token] = _priceDecimals;\n        strictStableTokens[_token] = _isStrictStable;\n    }\n\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool /* _useSwapPricing */) public override view returns (uint256) {\n        uint256 price = useV2Pricing ? getPriceV2(_token, _maximise, _includeAmmPrice) : getPriceV1(_token, _maximise, _includeAmmPrice);\n\n        uint256 adjustmentBps = adjustmentBasisPoints[_token];\n        if (adjustmentBps > 0) {\n            bool isAdditive = isAdjustmentAdditive[_token];\n            if (isAdditive) {\n                price = price.mul(BASIS_POINTS_DIVISOR.add(adjustmentBps)).div(BASIS_POINTS_DIVISOR);\n            } else {\n                price = price.mul(BASIS_POINTS_DIVISOR.sub(adjustmentBps)).div(BASIS_POINTS_DIVISOR);\n            }\n        }\n\n        return price;\n    }\n\n    function getPriceV1(address _token, bool _maximise, bool _includeAmmPrice) public view returns (uint256) {\n        uint256 price = getPrimaryPrice(_token, _maximise);\n\n        if (_includeAmmPrice && isAmmEnabled) {\n            uint256 ammPrice = getAmmPrice(_token);\n            if (ammPrice > 0) {\n                if (_maximise && ammPrice > price) {\n                    price = ammPrice;\n                }\n                if (!_maximise && ammPrice < price) {\n                    price = ammPrice;\n                }\n            }\n        }\n\n        if (isSecondaryPriceEnabled) {\n            price = getSecondaryPrice(_token, price, _maximise);\n        }\n\n        if (strictStableTokens[_token]) {\n            uint256 delta = price > ONE_USD ? price.sub(ONE_USD) : ONE_USD.sub(price);\n            if (delta <= maxStrictPriceDeviation) {\n                return ONE_USD;\n            }\n\n            // if _maximise and price is e.g. 1.02, return 1.02\n            if (_maximise && price > ONE_USD) {\n                return price;\n            }\n\n            // if !_maximise and price is e.g. 0.98, return 0.98\n            if (!_maximise && price < ONE_USD) {\n                return price;\n            }\n\n            return ONE_USD;\n        }\n\n        uint256 _spreadBasisPoints = spreadBasisPoints[_token];\n\n        if (_maximise) {\n            return price.mul(BASIS_POINTS_DIVISOR.add(_spreadBasisPoints)).div(BASIS_POINTS_DIVISOR);\n        }\n\n        return price.mul(BASIS_POINTS_DIVISOR.sub(_spreadBasisPoints)).div(BASIS_POINTS_DIVISOR);\n    }\n\n    function getPriceV2(address _token, bool _maximise, bool _includeAmmPrice) public view returns (uint256) {\n        uint256 price = getPrimaryPrice(_token, _maximise);\n\n        if (_includeAmmPrice && isAmmEnabled) {\n            price = getAmmPriceV2(_token, _maximise, price);\n        }\n\n        if (isSecondaryPriceEnabled) {\n            price = getSecondaryPrice(_token, price, _maximise);\n        }\n\n        if (strictStableTokens[_token]) {\n            uint256 delta = price > ONE_USD ? price.sub(ONE_USD) : ONE_USD.sub(price);\n            if (delta <= maxStrictPriceDeviation) {\n                return ONE_USD;\n            }\n\n            // if _maximise and price is e.g. 1.02, return 1.02\n            if (_maximise && price > ONE_USD) {\n                return price;\n            }\n\n            // if !_maximise and price is e.g. 0.98, return 0.98\n            if (!_maximise && price < ONE_USD) {\n                return price;\n            }\n\n            return ONE_USD;\n        }\n\n        uint256 _spreadBasisPoints = spreadBasisPoints[_token];\n\n        if (_maximise) {\n            return price.mul(BASIS_POINTS_DIVISOR.add(_spreadBasisPoints)).div(BASIS_POINTS_DIVISOR);\n        }\n\n        return price.mul(BASIS_POINTS_DIVISOR.sub(_spreadBasisPoints)).div(BASIS_POINTS_DIVISOR);\n    }\n\n    function getAmmPriceV2(address _token, bool _maximise, uint256 _primaryPrice) public view returns (uint256) {\n        uint256 ammPrice = getAmmPrice(_token);\n        if (ammPrice == 0) {\n            return _primaryPrice;\n        }\n\n        uint256 diff = ammPrice > _primaryPrice ? ammPrice.sub(_primaryPrice) : _primaryPrice.sub(ammPrice);\n        if (diff.mul(BASIS_POINTS_DIVISOR) < _primaryPrice.mul(spreadThresholdBasisPoints)) {\n            if (favorPrimaryPrice) {\n                return _primaryPrice;\n            }\n            return ammPrice;\n        }\n\n        if (_maximise && ammPrice > _primaryPrice) {\n            return ammPrice;\n        }\n\n        if (!_maximise && ammPrice < _primaryPrice) {\n            return ammPrice;\n        }\n\n        return _primaryPrice;\n    }\n\n    function getLatestPrimaryPrice(address _token) public override view returns (uint256) {\n        address priceFeedAddress = priceFeeds[_token];\n        require(priceFeedAddress != address(0), \"VaultPriceFeed: invalid price feed\");\n\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\n\n        int256 price = priceFeed.latestAnswer();\n        require(price > 0, \"VaultPriceFeed: invalid price\");\n\n        return uint256(price);\n    }\n\n    function getPrimaryPrice(address _token, bool _maximise) public override view returns (uint256) {\n        address priceFeedAddress = priceFeeds[_token];\n        require(priceFeedAddress != address(0), \"VaultPriceFeed: invalid price feed\");\n\n        if (chainlinkFlags != address(0)) {\n            bool isRaised = IChainlinkFlags(chainlinkFlags).getFlag(FLAG_ARBITRUM_SEQ_OFFLINE);\n            if (isRaised) {\n                    // If flag is raised we shouldn't perform any critical operations\n                revert(\"Chainlink feeds are not being updated\");\n            }\n        }\n\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\n\n        uint256 price = 0;\n        uint80 roundId = priceFeed.latestRound();\n\n        for (uint80 i = 0; i < priceSampleSpace; i++) {\n            if (roundId <= i) { break; }\n            uint256 p;\n\n            if (i == 0) {\n                int256 _p = priceFeed.latestAnswer();\n                require(_p > 0, \"VaultPriceFeed: invalid price\");\n                p = uint256(_p);\n            } else {\n                (, int256 _p, , ,) = priceFeed.getRoundData(roundId - i);\n                require(_p > 0, \"VaultPriceFeed: invalid price\");\n                p = uint256(_p);\n            }\n\n            if (price == 0) {\n                price = p;\n                continue;\n            }\n\n            if (_maximise && p > price) {\n                price = p;\n                continue;\n            }\n\n            if (!_maximise && p < price) {\n                price = p;\n            }\n        }\n\n        require(price > 0, \"VaultPriceFeed: could not fetch price\");\n        // normalise price precision\n        uint256 _priceDecimals = priceDecimals[_token];\n        return price.mul(PRICE_PRECISION).div(10 ** _priceDecimals);\n    }\n\n    function getSecondaryPrice(address _token, uint256 _referencePrice, bool _maximise) public view returns (uint256) {\n        if (secondaryPriceFeed == address(0)) { return _referencePrice; }\n        return ISecondaryPriceFeed(secondaryPriceFeed).getPrice(_token, _referencePrice, _maximise);\n    }\n\n    function getAmmPrice(address _token) public override view returns (uint256) {\n        if (_token == bnb) {\n            // for bnbBusd, reserve0: BNB, reserve1: BUSD\n            return getPairPrice(bnbBusd, true);\n        }\n\n        if (_token == eth) {\n            uint256 price0 = getPairPrice(bnbBusd, true);\n            // for ethBnb, reserve0: ETH, reserve1: BNB\n            uint256 price1 = getPairPrice(ethBnb, true);\n            // this calculation could overflow if (price0 / 10**30) * (price1 / 10**30) is more than 10**17\n            return price0.mul(price1).div(PRICE_PRECISION);\n        }\n\n        if (_token == btc) {\n            uint256 price0 = getPairPrice(bnbBusd, true);\n            // for btcBnb, reserve0: BTC, reserve1: BNB\n            uint256 price1 = getPairPrice(btcBnb, true);\n            // this calculation could overflow if (price0 / 10**30) * (price1 / 10**30) is more than 10**17\n            return price0.mul(price1).div(PRICE_PRECISION);\n        }\n\n        return 0;\n    }\n\n    // if divByReserve0: calculate price as reserve1 / reserve0\n    // if !divByReserve1: calculate price as reserve0 / reserve1\n    function getPairPrice(address _pair, bool _divByReserve0) public view returns (uint256) {\n        (uint256 reserve0, uint256 reserve1, ) = IPancakePair(_pair).getReserves();\n        if (_divByReserve0) {\n            if (reserve0 == 0) { return 0; }\n            return reserve1.mul(PRICE_PRECISION).div(reserve0);\n        }\n        if (reserve1 == 0) { return 0; }\n        return reserve0.mul(PRICE_PRECISION).div(reserve1);\n    }\n}\n"
    },
    "contracts/oracle/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPriceFeed {\n    function description() external view returns (string memory);\n    function aggregator() external view returns (address);\n    function latestAnswer() external view returns (int256);\n    function latestRound() external view returns (uint80);\n    function getRoundData(uint80 roundId) external view returns (uint80, int256, uint256, uint256, uint80);\n}\n"
    },
    "contracts/oracle/interfaces/IChainlinkFlags.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IChainlinkFlags {\n  function getFlag(address) external view returns (bool);\n}\n"
    },
    "contracts/amm/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IPancakePair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "contracts/amm/PancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IPancakePair.sol\";\n\ncontract PancakePair is IPancakePair {\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    function setReserves(uint256 balance0, uint256 balance1) external {\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = uint32(block.timestamp);\n    }\n\n    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n}\n"
    },
    "contracts/oracle/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IPriceFeed.sol\";\n\ncontract PriceFeed is IPriceFeed {\n    int256 public answer;\n    uint80 public roundId;\n    string public override description = \"PriceFeed\";\n    address public override aggregator;\n\n    uint256 public decimals;\n\n    address public gov;\n\n    mapping (uint80 => int256) public answers;\n    mapping (address => bool) public isAdmin;\n\n    constructor() public {\n        gov = msg.sender;\n        isAdmin[msg.sender] = true;\n    }\n\n    function setAdmin(address _account, bool _isAdmin) public {\n        require(msg.sender == gov, \"PriceFeed: forbidden\");\n        isAdmin[_account] = _isAdmin;\n    }\n\n    function latestAnswer() public override view returns (int256) {\n        return answer;\n    }\n\n    function latestRound() public override view returns (uint80) {\n        return roundId;\n    }\n\n    function setLatestAnswer(int256 _answer) public {\n        require(isAdmin[msg.sender], \"PriceFeed: forbidden\");\n        roundId = roundId + 1;\n        answer = _answer;\n        answers[roundId] = _answer;\n    }\n\n    // returns roundId, answer, startedAt, updatedAt, answeredInRound\n    function getRoundData(uint80 _roundId) public override view\n        returns (uint80, int256, uint256, uint256, uint80)\n    {\n        return (_roundId, answers[_roundId], 0, 0, 0);\n    }\n}\n"
    },
    "contracts/core/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/Address.sol\";\n\nimport \"../tokens/interfaces/IWETH.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRouter.sol\";\n\ncontract Router is IRouter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    address public gov;\n\n    // wrapped BNB / ETH\n    address public weth;\n    address public usdg;\n    address public vault;\n\n    mapping (address => bool) public plugins;\n    mapping (address => mapping (address => bool)) public approvedPlugins;\n\n    event Swap(address account, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Router: forbidden\");\n        _;\n    }\n\n    constructor(address _vault, address _usdg, address _weth) public {\n        vault = _vault;\n        usdg = _usdg;\n        weth = _weth;\n\n        gov = msg.sender;\n    }\n\n    receive() external payable {\n        require(msg.sender == weth, \"Router: invalid sender\");\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function addPlugin(address _plugin) external override onlyGov {\n        plugins[_plugin] = true;\n    }\n\n    function removePlugin(address _plugin) external onlyGov {\n        plugins[_plugin] = false;\n    }\n\n    function approvePlugin(address _plugin) external {\n        approvedPlugins[msg.sender][_plugin] = true;\n    }\n\n    function denyPlugin(address _plugin) external {\n        approvedPlugins[msg.sender][_plugin] = false;\n    }\n\n    function pluginTransfer(address _token, address _account, address _receiver, uint256 _amount) external override {\n        _validatePlugin(_account);\n        IERC20(_token).safeTransferFrom(_account, _receiver, _amount);\n    }\n\n    function pluginIncreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external override {\n        _validatePlugin(_account);\n        IVault(vault).increasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n    }\n\n    function pluginDecreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external override returns (uint256) {\n        _validatePlugin(_account);\n        return IVault(vault).decreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n\n    function directPoolDeposit(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransferFrom(_sender(), vault, _amount);\n        IVault(vault).directPoolDeposit(_token);\n    }\n\n    function swap(address[] memory _path, uint256 _amountIn, uint256 _minOut, address _receiver) public override {\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Swap(msg.sender, _path[0], _path[_path.length - 1], _amountIn, amountOut);\n    }\n\n    function swapETHToTokens(address[] memory _path, uint256 _minOut, address _receiver) external payable {\n        require(_path[0] == weth, \"Router: invalid _path\");\n        _transferETHToVault();\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Swap(msg.sender, _path[0], _path[_path.length - 1], msg.value, amountOut);\n    }\n\n    function swapTokensToETH(address[] memory _path, uint256 _amountIn, uint256 _minOut, address payable _receiver) external {\n        require(_path[_path.length - 1] == weth, \"Router: invalid _path\");\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, address(this));\n        _transferOutETH(amountOut, _receiver);\n        emit Swap(msg.sender, _path[0], _path[_path.length - 1], _amountIn, amountOut);\n    }\n\n    function increasePosition(address[] memory _path, address _indexToken, uint256 _amountIn, uint256 _minOut, uint256 _sizeDelta, bool _isLong, uint256 _price) external {\n        if (_amountIn > 0) {\n            IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        }\n        if (_path.length > 1 && _amountIn > 0) {\n            uint256 amountOut = _swap(_path, _minOut, address(this));\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, amountOut);\n        }\n        _increasePosition(_path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n\n    function increasePositionETH(address[] memory _path, address _indexToken, uint256 _minOut, uint256 _sizeDelta, bool _isLong, uint256 _price) external payable {\n        require(_path[0] == weth, \"Router: invalid _path\");\n        if (msg.value > 0) {\n            _transferETHToVault();\n        }\n        if (_path.length > 1 && msg.value > 0) {\n            uint256 amountOut = _swap(_path, _minOut, address(this));\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, amountOut);\n        }\n        _increasePosition(_path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n\n    function decreasePosition(address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price) external {\n        _decreasePosition(_collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver, _price);\n    }\n\n    function decreasePositionETH(address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address payable _receiver, uint256 _price) external {\n        uint256 amountOut = _decreasePosition(_collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        _transferOutETH(amountOut, _receiver);\n    }\n\n    function decreasePositionAndSwap(address[] memory _path, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price, uint256 _minOut) external {\n        uint256 amount = _decreasePosition(_path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        IERC20(_path[0]).safeTransfer(vault, amount);\n        _swap(_path, _minOut, _receiver);\n    }\n\n    function decreasePositionAndSwapETH(address[] memory _path, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address payable _receiver, uint256 _price, uint256 _minOut) external {\n        require(_path[_path.length - 1] == weth, \"Router: invalid _path\");\n        uint256 amount = _decreasePosition(_path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        IERC20(_path[0]).safeTransfer(vault, amount);\n        uint256 amountOut = _swap(_path, _minOut, address(this));\n        _transferOutETH(amountOut, _receiver);\n    }\n\n    function _increasePosition(address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _price) private {\n        if (_isLong) {\n            require(IVault(vault).getMaxPrice(_indexToken) <= _price, \"Router: mark price higher than limit\");\n        } else {\n            require(IVault(vault).getMinPrice(_indexToken) >= _price, \"Router: mark price lower than limit\");\n        }\n\n        IVault(vault).increasePosition(_sender(), _collateralToken, _indexToken, _sizeDelta, _isLong);\n    }\n\n    function _decreasePosition(address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price) private returns (uint256) {\n        if (_isLong) {\n            require(IVault(vault).getMinPrice(_indexToken) >= _price, \"Router: mark price lower than limit\");\n        } else {\n            require(IVault(vault).getMaxPrice(_indexToken) <= _price, \"Router: mark price higher than limit\");\n        }\n\n        return IVault(vault).decreasePosition(_sender(), _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n\n    function _transferETHToVault() private {\n        IWETH(weth).deposit{value: msg.value}();\n        IERC20(weth).safeTransfer(vault, msg.value);\n    }\n\n    function _transferOutETH(uint256 _amountOut, address payable _receiver) private {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.sendValue(_amountOut);\n    }\n\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) private returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        if (_path.length == 3) {\n            uint256 midOut = _vaultSwap(_path[0], _path[1], 0, address(this));\n            IERC20(_path[1]).safeTransfer(vault, midOut);\n            return _vaultSwap(_path[1], _path[2], _minOut, _receiver);\n        }\n\n        revert(\"Router: invalid _path.length\");\n    }\n\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) private returns (uint256) {\n        uint256 amountOut;\n\n        if (_tokenOut == usdg) { // buyUSDG\n            amountOut = IVault(vault).buyUSDG(_tokenIn, _receiver);\n        } else if (_tokenIn == usdg) { // sellUSDG\n            amountOut = IVault(vault).sellUSDG(_tokenOut, _receiver);\n        } else { // swap\n            amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        }\n\n        require(amountOut >= _minOut, \"Router: insufficient amountOut\");\n        return amountOut;\n    }\n\n    function _sender() private view returns (address) {\n        return msg.sender;\n    }\n\n    function _validatePlugin(address _account) private view {\n        require(plugins[msg.sender], \"Router: invalid plugin\");\n        require(approvedPlugins[_account][msg.sender], \"Router: plugin not approved\");\n    }\n}\n"
    },
    "contracts/staking/RewardRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\nimport \"../libraries/utils/Address.sol\";\n\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"./interfaces/IVester.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../tokens/interfaces/IWETH.sol\";\nimport \"../core/interfaces/IXlxManager.sol\";\nimport \"../access/Governable.sol\";\n\ncontract RewardRouterV2 is ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    bool public isInitialized;\n\n    address public weth;\n\n    address public xdx;\n    address public esXdx;\n    address public bnXdx;\n\n    address public xlx; // XDX Liquidity Provider token\n\n    address public stakedXdxTracker;\n    address public bonusXdxTracker;\n    address public feeXdxTracker;\n\n    address public stakedXlxTracker;\n    address public feeXlxTracker;\n\n    address public xlxManager;\n\n    address public xdxVester;\n    address public xlxVester;\n\n    mapping (address => address) public pendingReceivers;\n\n    event StakeXdx(address account, address token, uint256 amount);\n    event UnstakeXdx(address account, address token, uint256 amount);\n\n    event StakeXlx(address account, uint256 amount);\n    event UnstakeXlx(address account, uint256 amount);\n\n    receive() external payable {\n        require(msg.sender == weth, \"Router: invalid sender\");\n    }\n\n    function initialize(\n        address _weth,\n        address _xdx,\n        address _esXdx,\n        address _bnXdx,\n        address _xlx,\n        address _stakedXdxTracker,\n        address _bonusXdxTracker,\n        address _feeXdxTracker,\n        address _feeXlxTracker,\n        address _stakedXlxTracker,\n        address _xlxManager,\n        address _xdxVester,\n        address _xlxVester\n    ) external onlyGov {\n        require(!isInitialized, \"RewardRouter: already initialized\");\n        isInitialized = true;\n\n        weth = _weth;\n\n        xdx = _xdx;\n        esXdx = _esXdx;\n        bnXdx = _bnXdx;\n\n        xlx = _xlx;\n\n        stakedXdxTracker = _stakedXdxTracker;\n        bonusXdxTracker = _bonusXdxTracker;\n        feeXdxTracker = _feeXdxTracker;\n\n        feeXlxTracker = _feeXlxTracker;\n        stakedXlxTracker = _stakedXlxTracker;\n\n        xlxManager = _xlxManager;\n\n        xdxVester = _xdxVester;\n        xlxVester = _xlxVester;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function batchStakeXdxForAccount(address[] memory _accounts, uint256[] memory _amounts) external nonReentrant onlyGov {\n        address _xdx = xdx;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _stakeXdx(msg.sender, _accounts[i], _xdx, _amounts[i]);\n        }\n    }\n\n    function stakeXdxForAccount(address _account, uint256 _amount) external nonReentrant onlyGov {\n        _stakeXdx(msg.sender, _account, xdx, _amount);\n    }\n\n    function stakeXdx(uint256 _amount) external nonReentrant {\n        _stakeXdx(msg.sender, msg.sender, xdx, _amount);\n    }\n\n    function stakeEsXdx(uint256 _amount) external nonReentrant {\n        _stakeXdx(msg.sender, msg.sender, esXdx, _amount);\n    }\n\n    function unstakeXdx(uint256 _amount) external nonReentrant {\n        _unstakeXdx(msg.sender, xdx, _amount, true);\n    }\n\n    function unstakeEsXdx(uint256 _amount) external nonReentrant {\n        _unstakeXdx(msg.sender, esXdx, _amount, true);\n    }\n\n    function mintAndStakeXlx(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minXlx) external nonReentrant returns (uint256) {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        address account = msg.sender;\n        uint256 xlxAmount = IXlxManager(xlxManager).addLiquidityForAccount(account, account, _token, _amount, _minUsdg, _minXlx);\n        IRewardTracker(feeXlxTracker).stakeForAccount(account, account, xlx, xlxAmount);\n        IRewardTracker(stakedXlxTracker).stakeForAccount(account, account, feeXlxTracker, xlxAmount);\n\n        emit StakeXlx(account, xlxAmount);\n\n        return xlxAmount;\n    }\n\n    function mintAndStakeXlxETH(uint256 _minUsdg, uint256 _minXlx) external payable nonReentrant returns (uint256) {\n        require(msg.value > 0, \"RewardRouter: invalid msg.value\");\n\n        IWETH(weth).deposit{value: msg.value}();\n        IERC20(weth).approve(xlxManager, msg.value);\n\n        address account = msg.sender;\n        uint256 xlxAmount = IXlxManager(xlxManager).addLiquidityForAccount(address(this), account, weth, msg.value, _minUsdg, _minXlx);\n\n        IRewardTracker(feeXlxTracker).stakeForAccount(account, account, xlx, xlxAmount);\n        IRewardTracker(stakedXlxTracker).stakeForAccount(account, account, feeXlxTracker, xlxAmount);\n\n        emit StakeXlx(account, xlxAmount);\n\n        return xlxAmount;\n    }\n\n    function unstakeAndRedeemXlx(address _tokenOut, uint256 _xlxAmount, uint256 _minOut, address _receiver) external nonReentrant returns (uint256) {\n        require(_xlxAmount > 0, \"RewardRouter: invalid _xlxAmount\");\n\n        address account = msg.sender;\n        IRewardTracker(stakedXlxTracker).unstakeForAccount(account, feeXlxTracker, _xlxAmount, account);\n        IRewardTracker(feeXlxTracker).unstakeForAccount(account, xlx, _xlxAmount, account);\n        uint256 amountOut = IXlxManager(xlxManager).removeLiquidityForAccount(account, _tokenOut, _xlxAmount, _minOut, _receiver);\n\n        emit UnstakeXlx(account, _xlxAmount);\n\n        return amountOut;\n    }\n\n    function unstakeAndRedeemXlxETH(uint256 _xlxAmount, uint256 _minOut, address payable _receiver) external nonReentrant returns (uint256) {\n        require(_xlxAmount > 0, \"RewardRouter: invalid _xlxAmount\");\n\n        address account = msg.sender;\n        IRewardTracker(stakedXlxTracker).unstakeForAccount(account, feeXlxTracker, _xlxAmount, account);\n        IRewardTracker(feeXlxTracker).unstakeForAccount(account, xlx, _xlxAmount, account);\n        uint256 amountOut = IXlxManager(xlxManager).removeLiquidityForAccount(account, weth, _xlxAmount, _minOut, address(this));\n\n        IWETH(weth).withdraw(amountOut);\n\n        _receiver.sendValue(amountOut);\n\n        emit UnstakeXlx(account, _xlxAmount);\n\n        return amountOut;\n    }\n\n    function claim() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(feeXdxTracker).claimForAccount(account, account);\n        IRewardTracker(feeXlxTracker).claimForAccount(account, account);\n\n        IRewardTracker(stakedXdxTracker).claimForAccount(account, account);\n        IRewardTracker(stakedXlxTracker).claimForAccount(account, account);\n    }\n\n    function claimEsXdx() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(stakedXdxTracker).claimForAccount(account, account);\n        IRewardTracker(stakedXlxTracker).claimForAccount(account, account);\n    }\n\n    function claimFees() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(feeXdxTracker).claimForAccount(account, account);\n        IRewardTracker(feeXlxTracker).claimForAccount(account, account);\n    }\n\n    function compound() external nonReentrant {\n        _compound(msg.sender);\n    }\n\n    function compoundForAccount(address _account) external nonReentrant onlyGov {\n        _compound(_account);\n    }\n\n    function handleRewards(\n        bool _shouldClaimXdx,\n        bool _shouldStakeXdx,\n        bool _shouldClaimEsXdx,\n        bool _shouldStakeEsXdx,\n        bool _shouldStakeMultiplierPoints,\n        bool _shouldClaimWeth,\n        bool _shouldConvertWethToEth\n    ) external nonReentrant {\n        address account = msg.sender;\n\n        uint256 xdxAmount = 0;\n        if (_shouldClaimXdx) {\n            uint256 xdxAmount0 = IVester(xdxVester).claimForAccount(account, account);\n            uint256 xdxAmount1 = IVester(xlxVester).claimForAccount(account, account);\n            xdxAmount = xdxAmount0.add(xdxAmount1);\n        }\n\n        if (_shouldStakeXdx && xdxAmount > 0) {\n            _stakeXdx(account, account, xdx, xdxAmount);\n        }\n\n        uint256 esXdxAmount = 0;\n        if (_shouldClaimEsXdx) {\n            uint256 esXdxAmount0 = IRewardTracker(stakedXdxTracker).claimForAccount(account, account);\n            uint256 esXdxAmount1 = IRewardTracker(stakedXlxTracker).claimForAccount(account, account);\n            esXdxAmount = esXdxAmount0.add(esXdxAmount1);\n        }\n\n        if (_shouldStakeEsXdx && esXdxAmount > 0) {\n            _stakeXdx(account, account, esXdx, esXdxAmount);\n        }\n\n        if (_shouldStakeMultiplierPoints) {\n            uint256 bnXdxAmount = IRewardTracker(bonusXdxTracker).claimForAccount(account, account);\n            if (bnXdxAmount > 0) {\n                IRewardTracker(feeXdxTracker).stakeForAccount(account, account, bnXdx, bnXdxAmount);\n            }\n        }\n\n        if (_shouldClaimWeth) {\n            if (_shouldConvertWethToEth) {\n                uint256 weth0 = IRewardTracker(feeXdxTracker).claimForAccount(account, address(this));\n                uint256 weth1 = IRewardTracker(feeXlxTracker).claimForAccount(account, address(this));\n\n                uint256 wethAmount = weth0.add(weth1);\n                IWETH(weth).withdraw(wethAmount);\n\n                payable(account).sendValue(wethAmount);\n            } else {\n                IRewardTracker(feeXdxTracker).claimForAccount(account, account);\n                IRewardTracker(feeXlxTracker).claimForAccount(account, account);\n            }\n        }\n    }\n\n    function batchCompoundForAccounts(address[] memory _accounts) external nonReentrant onlyGov {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _compound(_accounts[i]);\n        }\n    }\n\n    function signalTransfer(address _receiver) external nonReentrant {\n        require(IERC20(xdxVester).balanceOf(msg.sender) == 0, \"RewardRouter: sender has vested tokens\");\n        require(IERC20(xlxVester).balanceOf(msg.sender) == 0, \"RewardRouter: sender has vested tokens\");\n\n        _validateReceiver(_receiver);\n        pendingReceivers[msg.sender] = _receiver;\n    }\n\n    function acceptTransfer(address _sender) external nonReentrant {\n        require(IERC20(xdxVester).balanceOf(_sender) == 0, \"RewardRouter: sender has vested tokens\");\n        require(IERC20(xlxVester).balanceOf(_sender) == 0, \"RewardRouter: sender has vested tokens\");\n\n        address receiver = msg.sender;\n        require(pendingReceivers[_sender] == receiver, \"RewardRouter: transfer not signalled\");\n        delete pendingReceivers[_sender];\n\n        _validateReceiver(receiver);\n        _compound(_sender);\n\n        uint256 stakedXdx = IRewardTracker(stakedXdxTracker).depositBalances(_sender, xdx);\n        if (stakedXdx > 0) {\n            _unstakeXdx(_sender, xdx, stakedXdx, false);\n            _stakeXdx(_sender, receiver, xdx, stakedXdx);\n        }\n\n        uint256 stakedEsXdx = IRewardTracker(stakedXdxTracker).depositBalances(_sender, esXdx);\n        if (stakedEsXdx > 0) {\n            _unstakeXdx(_sender, esXdx, stakedEsXdx, false);\n            _stakeXdx(_sender, receiver, esXdx, stakedEsXdx);\n        }\n\n        uint256 stakedBnXdx = IRewardTracker(feeXdxTracker).depositBalances(_sender, bnXdx);\n        if (stakedBnXdx > 0) {\n            IRewardTracker(feeXdxTracker).unstakeForAccount(_sender, bnXdx, stakedBnXdx, _sender);\n            IRewardTracker(feeXdxTracker).stakeForAccount(_sender, receiver, bnXdx, stakedBnXdx);\n        }\n\n        uint256 esXdxBalance = IERC20(esXdx).balanceOf(_sender);\n        if (esXdxBalance > 0) {\n            IERC20(esXdx).transferFrom(_sender, receiver, esXdxBalance);\n        }\n\n        uint256 xlxAmount = IRewardTracker(feeXlxTracker).depositBalances(_sender, xlx);\n        if (xlxAmount > 0) {\n            IRewardTracker(stakedXlxTracker).unstakeForAccount(_sender, feeXlxTracker, xlxAmount, _sender);\n            IRewardTracker(feeXlxTracker).unstakeForAccount(_sender, xlx, xlxAmount, _sender);\n\n            IRewardTracker(feeXlxTracker).stakeForAccount(_sender, receiver, xlx, xlxAmount);\n            IRewardTracker(stakedXlxTracker).stakeForAccount(receiver, receiver, feeXlxTracker, xlxAmount);\n        }\n\n        IVester(xdxVester).transferStakeValues(_sender, receiver);\n        IVester(xlxVester).transferStakeValues(_sender, receiver);\n    }\n\n    function _validateReceiver(address _receiver) private view {\n        require(IRewardTracker(stakedXdxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: stakedXdxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(stakedXdxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: stakedXdxTracker.cumulativeRewards > 0\");\n\n        require(IRewardTracker(bonusXdxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: bonusXdxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(bonusXdxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: bonusXdxTracker.cumulativeRewards > 0\");\n\n        require(IRewardTracker(feeXdxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: feeXdxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(feeXdxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: feeXdxTracker.cumulativeRewards > 0\");\n\n        require(IVester(xdxVester).transferredAverageStakedAmounts(_receiver) == 0, \"RewardRouter: xdxVester.transferredAverageStakedAmounts > 0\");\n        require(IVester(xdxVester).transferredCumulativeRewards(_receiver) == 0, \"RewardRouter: xdxVester.transferredCumulativeRewards > 0\");\n\n        require(IRewardTracker(stakedXlxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: stakedXlxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(stakedXlxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: stakedXlxTracker.cumulativeRewards > 0\");\n\n        require(IRewardTracker(feeXlxTracker).averageStakedAmounts(_receiver) == 0, \"RewardRouter: feeXlxTracker.averageStakedAmounts > 0\");\n        require(IRewardTracker(feeXlxTracker).cumulativeRewards(_receiver) == 0, \"RewardRouter: feeXlxTracker.cumulativeRewards > 0\");\n\n        require(IVester(xlxVester).transferredAverageStakedAmounts(_receiver) == 0, \"RewardRouter: xdxVester.transferredAverageStakedAmounts > 0\");\n        require(IVester(xlxVester).transferredCumulativeRewards(_receiver) == 0, \"RewardRouter: xdxVester.transferredCumulativeRewards > 0\");\n\n        require(IERC20(xdxVester).balanceOf(_receiver) == 0, \"RewardRouter: xdxVester.balance > 0\");\n        require(IERC20(xlxVester).balanceOf(_receiver) == 0, \"RewardRouter: xlxVester.balance > 0\");\n    }\n\n    function _compound(address _account) private {\n        _compoundXdx(_account);\n        _compoundXlx(_account);\n    }\n\n    function _compoundXdx(address _account) private {\n        uint256 esXdxAmount = IRewardTracker(stakedXdxTracker).claimForAccount(_account, _account);\n        if (esXdxAmount > 0) {\n            _stakeXdx(_account, _account, esXdx, esXdxAmount);\n        }\n\n        uint256 bnXdxAmount = IRewardTracker(bonusXdxTracker).claimForAccount(_account, _account);\n        if (bnXdxAmount > 0) {\n            IRewardTracker(feeXdxTracker).stakeForAccount(_account, _account, bnXdx, bnXdxAmount);\n        }\n    }\n\n    function _compoundXlx(address _account) private {\n        uint256 esXdxAmount = IRewardTracker(stakedXlxTracker).claimForAccount(_account, _account);\n        if (esXdxAmount > 0) {\n            _stakeXdx(_account, _account, esXdx, esXdxAmount);\n        }\n    }\n\n    function _stakeXdx(address _fundingAccount, address _account, address _token, uint256 _amount) private {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        IRewardTracker(stakedXdxTracker).stakeForAccount(_fundingAccount, _account, _token, _amount);\n        IRewardTracker(bonusXdxTracker).stakeForAccount(_account, _account, stakedXdxTracker, _amount);\n        IRewardTracker(feeXdxTracker).stakeForAccount(_account, _account, bonusXdxTracker, _amount);\n\n        emit StakeXdx(_account, _token, _amount);\n    }\n\n    function _unstakeXdx(address _account, address _token, uint256 _amount, bool _shouldReduceBnXdx) private {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        uint256 balance = IRewardTracker(stakedXdxTracker).stakedAmounts(_account);\n\n        IRewardTracker(feeXdxTracker).unstakeForAccount(_account, bonusXdxTracker, _amount, _account);\n        IRewardTracker(bonusXdxTracker).unstakeForAccount(_account, stakedXdxTracker, _amount, _account);\n        IRewardTracker(stakedXdxTracker).unstakeForAccount(_account, _token, _amount, _account);\n\n        if (_shouldReduceBnXdx) {\n            uint256 bnXdxAmount = IRewardTracker(bonusXdxTracker).claimForAccount(_account, _account);\n            if (bnXdxAmount > 0) {\n                IRewardTracker(feeXdxTracker).stakeForAccount(_account, _account, bnXdx, bnXdxAmount);\n            }\n\n            uint256 stakedBnXdx = IRewardTracker(feeXdxTracker).depositBalances(_account, bnXdx);\n            if (stakedBnXdx > 0) {\n                uint256 reductionAmount = stakedBnXdx.mul(_amount).div(balance);\n                IRewardTracker(feeXdxTracker).unstakeForAccount(_account, bnXdx, reductionAmount, _account);\n                IMintable(bnXdx).burn(_account, reductionAmount);\n            }\n        }\n\n        emit UnstakeXdx(_account, _token, _amount);\n    }\n}\n"
    },
    "contracts/staking/XlxBalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../core/interfaces/IXlxManager.sol\";\n\ncontract XlxBalance {\n    using SafeMath for uint256;\n\n    IXlxManager public xlxManager;\n    address public stakedXlxTracker;\n\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(\n        IXlxManager _xlxManager,\n        address _stakedXlxTracker\n    ) public {\n        xlxManager = _xlxManager;\n        stakedXlxTracker = _stakedXlxTracker;\n    }\n\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"XlxBalance: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"XlxBalance: approve from the zero address\");\n        require(_spender != address(0), \"XlxBalance: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"XlxBalance: transfer from the zero address\");\n        require(_recipient != address(0), \"XlxBalance: transfer to the zero address\");\n\n        require(\n            xlxManager.lastAddedAt(_sender).add(xlxManager.cooldownDuration()) <= block.timestamp,\n            \"XlxBalance: cooldown duration not yet passed\"\n        );\n\n        IERC20(stakedXlxTracker).transferFrom(_sender, _recipient, _amount);\n    }\n}\n"
    },
    "contracts/staking/StakedXlx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\n\nimport \"../core/interfaces/IXlxManager.sol\";\n\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"./interfaces/IRewardTracker.sol\";\n\n// provide a way to transfer staked XLX tokens by unstaking from the sender\n// and staking for the receiver\n// tests in RewardRouterV2.js\ncontract StakedXlx {\n    using SafeMath for uint256;\n\n    string public constant name = \"StakedXlx\";\n    string public constant symbol = \"sXLX\";\n    uint8 public constant decimals = 18;\n\n    address public xlx;\n    IXlxManager public xlxManager;\n    address public stakedXlxTracker;\n    address public feeXlxTracker;\n\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(\n        address _xlx,\n        IXlxManager _xlxManager,\n        address _stakedXlxTracker,\n        address _feeXlxTracker\n    ) public {\n        xlx = _xlx;\n        xlxManager = _xlxManager;\n        stakedXlxTracker = _stakedXlxTracker;\n        feeXlxTracker = _feeXlxTracker;\n    }\n\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"StakedXlx: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function balanceOf(address _account) external view returns (uint256) {\n        IRewardTracker(stakedXlxTracker).depositBalances(_account, xlx);\n    }\n\n    function totalSupply() external view returns (uint256) {\n        IERC20(stakedXlxTracker).totalSupply();\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"StakedXlx: approve from the zero address\");\n        require(_spender != address(0), \"StakedXlx: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"StakedXlx: transfer from the zero address\");\n        require(_recipient != address(0), \"StakedXlx: transfer to the zero address\");\n\n        require(\n            xlxManager.lastAddedAt(_sender).add(xlxManager.cooldownDuration()) <= block.timestamp,\n            \"StakedXlx: cooldown duration not yet passed\"\n        );\n\n        IRewardTracker(stakedXlxTracker).unstakeForAccount(_sender, feeXlxTracker, _amount, _sender);\n        IRewardTracker(feeXlxTracker).unstakeForAccount(_sender, xlx, _amount, _sender);\n\n        IRewardTracker(feeXlxTracker).stakeForAccount(_sender, _recipient, xlx, _amount);\n        IRewardTracker(stakedXlxTracker).stakeForAccount(_recipient, _recipient, feeXlxTracker, _amount);\n    }\n}\n"
    },
    "contracts/staking/StakeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"../access/Governable.sol\";\n\ncontract StakeManager is Governable {\n    function stakeForAccount(\n        address _rewardTracker,\n        address _account,\n        address _token,\n        uint256 _amount\n    ) external onlyGov {\n        IRewardTracker(_rewardTracker).stakeForAccount(_account, _account, _token, _amount);\n    }\n}\n"
    },
    "contracts/staking/RewardTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IRewardDistributor.sol\";\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"../access/Governable.sol\";\n\ncontract RewardTracker is IERC20, ReentrancyGuard, IRewardTracker, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant PRECISION = 1e30;\n\n    uint8 public constant decimals = 18;\n\n    bool public isInitialized;\n\n    string public name;\n    string public symbol;\n\n    address public distributor;\n    mapping (address => bool) public isDepositToken;\n    mapping (address => mapping (address => uint256)) public override depositBalances;\n    mapping (address => uint256) public totalDepositSupply;\n\n    uint256 public override totalSupply;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    uint256 public cumulativeRewardPerToken;\n    mapping (address => uint256) public override stakedAmounts;\n    mapping (address => uint256) public claimableReward;\n    mapping (address => uint256) public previousCumulatedRewardPerToken;\n    mapping (address => uint256) public override cumulativeRewards;\n    mapping (address => uint256) public override averageStakedAmounts;\n\n    bool public inPrivateTransferMode;\n    bool public inPrivateStakingMode;\n    bool public inPrivateClaimingMode;\n    mapping (address => bool) public isHandler;\n\n    event Claim(address receiver, uint256 amount);\n\n    constructor(string memory _name, string memory _symbol) public {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function initialize(\n        address[] memory _depositTokens,\n        address _distributor\n    ) external onlyGov {\n        require(!isInitialized, \"RewardTracker: already initialized\");\n        isInitialized = true;\n\n        for (uint256 i = 0; i < _depositTokens.length; i++) {\n            address depositToken = _depositTokens[i];\n            isDepositToken[depositToken] = true;\n        }\n\n        distributor = _distributor;\n    }\n\n    function setDepositToken(address _depositToken, bool _isDepositToken) external onlyGov {\n        isDepositToken[_depositToken] = _isDepositToken;\n    }\n\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external onlyGov {\n        inPrivateTransferMode = _inPrivateTransferMode;\n    }\n\n    function setInPrivateStakingMode(bool _inPrivateStakingMode) external onlyGov {\n        inPrivateStakingMode = _inPrivateStakingMode;\n    }\n\n    function setInPrivateClaimingMode(bool _inPrivateClaimingMode) external onlyGov {\n        inPrivateClaimingMode = _inPrivateClaimingMode;\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function stake(address _depositToken, uint256 _amount) external override nonReentrant {\n        if (inPrivateStakingMode) { revert(\"RewardTracker: action not enabled\"); }\n        _stake(msg.sender, msg.sender, _depositToken, _amount);\n    }\n\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external override nonReentrant {\n        _validateHandler();\n        _stake(_fundingAccount, _account, _depositToken, _amount);\n    }\n\n    function unstake(address _depositToken, uint256 _amount) external override nonReentrant {\n        if (inPrivateStakingMode) { revert(\"RewardTracker: action not enabled\"); }\n        _unstake(msg.sender, _depositToken, _amount, msg.sender);\n    }\n\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external override nonReentrant {\n        _validateHandler();\n        _unstake(_account, _depositToken, _amount, _receiver);\n    }\n\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        if (isHandler[msg.sender]) {\n            _transfer(_sender, _recipient, _amount);\n            return true;\n        }\n\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"RewardTracker: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function tokensPerInterval() external override view returns (uint256) {\n        return IRewardDistributor(distributor).tokensPerInterval();\n    }\n\n    function updateRewards() external override nonReentrant {\n        _updateRewards(address(0));\n    }\n\n    function claim(address _receiver) external override nonReentrant returns (uint256) {\n        if (inPrivateClaimingMode) { revert(\"RewardTracker: action not enabled\"); }\n        return _claim(msg.sender, _receiver);\n    }\n\n    function claimForAccount(address _account, address _receiver) external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _claim(_account, _receiver);\n    }\n\n    function claimable(address _account) public override view returns (uint256) {\n        uint256 stakedAmount = stakedAmounts[_account];\n        if (stakedAmount == 0) {\n            return claimableReward[_account];\n        }\n        uint256 supply = totalSupply;\n        uint256 pendingRewards = IRewardDistributor(distributor).pendingRewards().mul(PRECISION);\n        uint256 nextCumulativeRewardPerToken = cumulativeRewardPerToken.add(pendingRewards.div(supply));\n        return claimableReward[_account].add(\n            stakedAmount.mul(nextCumulativeRewardPerToken.sub(previousCumulatedRewardPerToken[_account])).div(PRECISION));\n    }\n\n    function rewardToken() public view returns (address) {\n        return IRewardDistributor(distributor).rewardToken();\n    }\n\n    function _claim(address _account, address _receiver) private returns (uint256) {\n        _updateRewards(_account);\n\n        uint256 tokenAmount = claimableReward[_account];\n        claimableReward[_account] = 0;\n\n        if (tokenAmount > 0) {\n            IERC20(rewardToken()).safeTransfer(_receiver, tokenAmount);\n            emit Claim(_account, tokenAmount);\n        }\n\n        return tokenAmount;\n    }\n\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"RewardTracker: mint to the zero address\");\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"RewardTracker: burn from the zero address\");\n\n        balances[_account] = balances[_account].sub(_amount, \"RewardTracker: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(_amount);\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"RewardTracker: transfer from the zero address\");\n        require(_recipient != address(0), \"RewardTracker: transfer to the zero address\");\n\n        if (inPrivateTransferMode) { _validateHandler(); }\n\n        balances[_sender] = balances[_sender].sub(_amount, \"RewardTracker: transfer amount exceeds balance\");\n        balances[_recipient] = balances[_recipient].add(_amount);\n\n        emit Transfer(_sender, _recipient,_amount);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"RewardTracker: approve from the zero address\");\n        require(_spender != address(0), \"RewardTracker: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _validateHandler() private view {\n        require(isHandler[msg.sender], \"RewardTracker: forbidden\");\n    }\n\n    function _stake(address _fundingAccount, address _account, address _depositToken, uint256 _amount) private {\n        require(_amount > 0, \"RewardTracker: invalid _amount\");\n        require(isDepositToken[_depositToken], \"RewardTracker: invalid _depositToken\");\n\n        IERC20(_depositToken).safeTransferFrom(_fundingAccount, address(this), _amount);\n\n        _updateRewards(_account);\n\n        stakedAmounts[_account] = stakedAmounts[_account].add(_amount);\n        depositBalances[_account][_depositToken] = depositBalances[_account][_depositToken].add(_amount);\n        totalDepositSupply[_depositToken] = totalDepositSupply[_depositToken].add(_amount);\n\n        _mint(_account, _amount);\n    }\n\n    function _unstake(address _account, address _depositToken, uint256 _amount, address _receiver) private {\n        require(_amount > 0, \"RewardTracker: invalid _amount\");\n        require(isDepositToken[_depositToken], \"RewardTracker: invalid _depositToken\");\n\n        _updateRewards(_account);\n\n        uint256 stakedAmount = stakedAmounts[_account];\n        require(stakedAmounts[_account] >= _amount, \"RewardTracker: _amount exceeds stakedAmount\");\n\n        stakedAmounts[_account] = stakedAmount.sub(_amount);\n\n        uint256 depositBalance = depositBalances[_account][_depositToken];\n        require(depositBalance >= _amount, \"RewardTracker: _amount exceeds depositBalance\");\n        depositBalances[_account][_depositToken] = depositBalance.sub(_amount);\n        totalDepositSupply[_depositToken] = totalDepositSupply[_depositToken].sub(_amount);\n\n        _burn(_account, _amount);\n        IERC20(_depositToken).safeTransfer(_receiver, _amount);\n    }\n\n    function _updateRewards(address _account) private {\n        uint256 blockReward = IRewardDistributor(distributor).distribute();\n\n        uint256 supply = totalSupply;\n        uint256 _cumulativeRewardPerToken = cumulativeRewardPerToken;\n        if (supply > 0 && blockReward > 0) {\n            _cumulativeRewardPerToken = _cumulativeRewardPerToken.add(blockReward.mul(PRECISION).div(supply));\n            cumulativeRewardPerToken = _cumulativeRewardPerToken;\n        }\n\n        // cumulativeRewardPerToken can only increase\n        // so if cumulativeRewardPerToken is zero, it means there are no rewards yet\n        if (_cumulativeRewardPerToken == 0) {\n            return;\n        }\n\n        if (_account != address(0)) {\n            uint256 stakedAmount = stakedAmounts[_account];\n            uint256 accountReward = stakedAmount.mul(_cumulativeRewardPerToken.sub(previousCumulatedRewardPerToken[_account])).div(PRECISION);\n            uint256 _claimableReward = claimableReward[_account].add(accountReward);\n\n            claimableReward[_account] = _claimableReward;\n            previousCumulatedRewardPerToken[_account] = _cumulativeRewardPerToken;\n\n            if (_claimableReward > 0 && stakedAmounts[_account] > 0) {\n                uint256 nextCumulativeReward = cumulativeRewards[_account].add(accountReward);\n\n                averageStakedAmounts[_account] = averageStakedAmounts[_account].mul(cumulativeRewards[_account]).div(nextCumulativeReward)\n                    .add(stakedAmount.mul(accountReward).div(nextCumulativeReward));\n\n                cumulativeRewards[_account] = nextCumulativeReward;\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/interfaces/IRewardDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IRewardDistributor {\n    function rewardToken() external view returns (address);\n    function tokensPerInterval() external view returns (uint256);\n    function pendingRewards() external view returns (uint256);\n    function distribute() external returns (uint256);\n}\n"
    },
    "contracts/staking/RewardDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IRewardDistributor.sol\";\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"../access/Governable.sol\";\n\ncontract RewardDistributor is IRewardDistributor, ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public override rewardToken;\n    uint256 public override tokensPerInterval;\n    uint256 public lastDistributionTime;\n    address public rewardTracker;\n\n    address public admin;\n\n    event Distribute(uint256 amount);\n    event TokensPerIntervalChange(uint256 amount);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"RewardDistributor: forbidden\");\n        _;\n    }\n\n    constructor(address _rewardToken, address _rewardTracker) public {\n        rewardToken = _rewardToken;\n        rewardTracker = _rewardTracker;\n        admin = msg.sender;\n    }\n\n    function setAdmin(address _admin) external onlyGov {\n        admin = _admin;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function updateLastDistributionTime() external onlyAdmin {\n        lastDistributionTime = block.timestamp;\n    }\n\n    function setTokensPerInterval(uint256 _amount) external onlyAdmin {\n        require(lastDistributionTime != 0, \"RewardDistributor: invalid lastDistributionTime\");\n        IRewardTracker(rewardTracker).updateRewards();\n        tokensPerInterval = _amount;\n        emit TokensPerIntervalChange(_amount);\n    }\n\n    function pendingRewards() public view override returns (uint256) {\n        if (block.timestamp == lastDistributionTime) {\n            return 0;\n        }\n\n        uint256 timeDiff = block.timestamp.sub(lastDistributionTime);\n        return tokensPerInterval.mul(timeDiff);\n    }\n\n    function distribute() external override returns (uint256) {\n        require(msg.sender == rewardTracker, \"RewardDistributor: invalid msg.sender\");\n        uint256 amount = pendingRewards();\n        if (amount == 0) { return 0; }\n\n        lastDistributionTime = block.timestamp;\n\n        uint256 balance = IERC20(rewardToken).balanceOf(address(this));\n        if (amount > balance) { amount = balance; }\n\n        IERC20(rewardToken).safeTransfer(msg.sender, amount);\n\n        emit Distribute(amount);\n        return amount;\n    }\n}\n"
    },
    "contracts/tokens/YieldFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./YieldToken.sol\";\n\ncontract YieldFarm is YieldToken, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address public stakingToken;\n\n    constructor(string memory _name, string memory _symbol, address _stakingToken) public YieldToken(_name, _symbol, 0) {\n        stakingToken = _stakingToken;\n    }\n\n    function stake(uint256 _amount) external nonReentrant {\n        IERC20(stakingToken).safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _amount);\n    }\n\n    function unstake(uint256 _amount) external nonReentrant {\n        _burn(msg.sender, _amount);\n        IERC20(stakingToken).safeTransfer(msg.sender, _amount);\n    }\n}\n"
    },
    "contracts/tokens/TimeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\n\nimport \"./interfaces/IDistributor.sol\";\n\ncontract TimeDistributor is IDistributor {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DISTRIBUTION_INTERVAL = 1 hours;\n    address public gov;\n    address public admin;\n\n    mapping (address => address) public rewardTokens;\n    mapping (address => uint256) public override tokensPerInterval;\n    mapping (address => uint256) public lastDistributionTime;\n\n    event Distribute(address receiver, uint256 amount);\n    event DistributionChange(address receiver, uint256 amount, address rewardToken);\n    event TokensPerIntervalChange(address receiver, uint256 amount);\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"TimeDistributor: forbidden\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"TimeDistributor: forbidden\");\n        _;\n    }\n\n    constructor() public {\n        gov = msg.sender;\n        admin = msg.sender;\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setTokensPerInterval(address _receiver, uint256 _amount) external onlyAdmin {\n        if (lastDistributionTime[_receiver] != 0) {\n            uint256 intervals = getIntervals(_receiver);\n            require(intervals == 0, \"TimeDistributor: pending distribution\");\n        }\n\n        tokensPerInterval[_receiver] = _amount;\n        _updateLastDistributionTime(_receiver);\n        emit TokensPerIntervalChange(_receiver, _amount);\n    }\n\n    function updateLastDistributionTime(address _receiver) external onlyAdmin {\n        _updateLastDistributionTime(_receiver);\n    }\n\n    function setDistribution(\n        address[] calldata _receivers,\n        uint256[] calldata _amounts,\n        address[] calldata _rewardTokens\n    ) external onlyGov {\n        for (uint256 i = 0; i < _receivers.length; i++) {\n            address receiver = _receivers[i];\n\n            if (lastDistributionTime[receiver] != 0) {\n                uint256 intervals = getIntervals(receiver);\n                require(intervals == 0, \"TimeDistributor: pending distribution\");\n            }\n\n            uint256 amount = _amounts[i];\n            address rewardToken = _rewardTokens[i];\n            tokensPerInterval[receiver] = amount;\n            rewardTokens[receiver] = rewardToken;\n            _updateLastDistributionTime(receiver);\n            emit DistributionChange(receiver, amount, rewardToken);\n        }\n    }\n\n    function distribute() external override returns (uint256) {\n        address receiver = msg.sender;\n        uint256 intervals = getIntervals(receiver);\n\n        if (intervals == 0) { return 0; }\n\n        uint256 amount = getDistributionAmount(receiver);\n        _updateLastDistributionTime(receiver);\n\n        if (amount == 0) { return 0; }\n\n        IERC20(rewardTokens[receiver]).safeTransfer(receiver, amount);\n\n        emit Distribute(receiver, amount);\n        return amount;\n    }\n\n    function getRewardToken(address _receiver) external override view returns (address) {\n        return rewardTokens[_receiver];\n    }\n\n    function getDistributionAmount(address _receiver) public override view returns (uint256) {\n        uint256 _tokensPerInterval = tokensPerInterval[_receiver];\n        if (_tokensPerInterval == 0) { return 0; }\n\n        uint256 intervals = getIntervals(_receiver);\n        uint256 amount = _tokensPerInterval.mul(intervals);\n\n        if (IERC20(rewardTokens[_receiver]).balanceOf(address(this)) < amount) { return 0; }\n\n        return amount;\n    }\n\n    function getIntervals(address _receiver) public view returns (uint256) {\n        uint256 timeDiff = block.timestamp.sub(lastDistributionTime[_receiver]);\n        return timeDiff.div(DISTRIBUTION_INTERVAL);\n    }\n\n    function _updateLastDistributionTime(address _receiver) private {\n        lastDistributionTime[_receiver] = block.timestamp.div(DISTRIBUTION_INTERVAL).mul(DISTRIBUTION_INTERVAL);\n    }\n}\n"
    },
    "contracts/staking/RewardRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\nimport \"../libraries/utils/Address.sol\";\n\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../tokens/interfaces/IWETH.sol\";\nimport \"../core/interfaces/IXlxManager.sol\";\nimport \"../access/Governable.sol\";\n\ncontract RewardRouter is ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    bool public isInitialized;\n\n    address public weth;\n\n    address public xdx;\n    address public esXdx;\n    address public bnXdx;\n\n    address public xlx; // XDX Liquidity Provider token\n\n    address public stakedXdxTracker;\n    address public bonusXdxTracker;\n    address public feeXdxTracker;\n\n    address public stakedXlxTracker;\n    address public feeXlxTracker;\n\n    address public xlxManager;\n\n    event StakeXdx(address account, uint256 amount);\n    event UnstakeXdx(address account, uint256 amount);\n\n    event StakeXlx(address account, uint256 amount);\n    event UnstakeXlx(address account, uint256 amount);\n\n    receive() external payable {\n        require(msg.sender == weth, \"Router: invalid sender\");\n    }\n\n    function initialize(\n        address _weth,\n        address _xdx,\n        address _esXdx,\n        address _bnXdx,\n        address _xlx,\n        address _stakedXdxTracker,\n        address _bonusXdxTracker,\n        address _feeXdxTracker,\n        address _feeXlxTracker,\n        address _stakedXlxTracker,\n        address _xlxManager\n    ) external onlyGov {\n        require(!isInitialized, \"RewardRouter: already initialized\");\n        isInitialized = true;\n\n        weth = _weth;\n\n        xdx = _xdx;\n        esXdx = _esXdx;\n        bnXdx = _bnXdx;\n\n        xlx = _xlx;\n\n        stakedXdxTracker = _stakedXdxTracker;\n        bonusXdxTracker = _bonusXdxTracker;\n        feeXdxTracker = _feeXdxTracker;\n\n        feeXlxTracker = _feeXlxTracker;\n        stakedXlxTracker = _stakedXlxTracker;\n\n        xlxManager = _xlxManager;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function batchStakeXdxForAccount(address[] memory _accounts, uint256[] memory _amounts) external nonReentrant onlyGov {\n        address _xdx = xdx;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _stakeXdx(msg.sender, _accounts[i], _xdx, _amounts[i]);\n        }\n    }\n\n    function stakeXdxForAccount(address _account, uint256 _amount) external nonReentrant onlyGov {\n        _stakeXdx(msg.sender, _account, xdx, _amount);\n    }\n\n    function stakeXdx(uint256 _amount) external nonReentrant {\n        _stakeXdx(msg.sender, msg.sender, xdx, _amount);\n    }\n\n    function stakeEsXdx(uint256 _amount) external nonReentrant {\n        _stakeXdx(msg.sender, msg.sender, esXdx, _amount);\n    }\n\n    function unstakeXdx(uint256 _amount) external nonReentrant {\n        _unstakeXdx(msg.sender, xdx, _amount);\n    }\n\n    function unstakeEsXdx(uint256 _amount) external nonReentrant {\n        _unstakeXdx(msg.sender, esXdx, _amount);\n    }\n\n    function mintAndStakeXlx(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minXlx) external nonReentrant returns (uint256) {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        address account = msg.sender;\n        uint256 xlxAmount = IXlxManager(xlxManager).addLiquidityForAccount(account, account, _token, _amount, _minUsdg, _minXlx);\n        IRewardTracker(feeXlxTracker).stakeForAccount(account, account, xlx, xlxAmount);\n        IRewardTracker(stakedXlxTracker).stakeForAccount(account, account, feeXlxTracker, xlxAmount);\n\n        emit StakeXlx(account, xlxAmount);\n\n        return xlxAmount;\n    }\n\n    function mintAndStakeXlxETH(uint256 _minUsdg, uint256 _minXlx) external payable nonReentrant returns (uint256) {\n        require(msg.value > 0, \"RewardRouter: invalid msg.value\");\n\n        IWETH(weth).deposit{value: msg.value}();\n        IERC20(weth).approve(xlxManager, msg.value);\n\n        address account = msg.sender;\n        uint256 xlxAmount = IXlxManager(xlxManager).addLiquidityForAccount(address(this), account, weth, msg.value, _minUsdg, _minXlx);\n\n        IRewardTracker(feeXlxTracker).stakeForAccount(account, account, xlx, xlxAmount);\n        IRewardTracker(stakedXlxTracker).stakeForAccount(account, account, feeXlxTracker, xlxAmount);\n\n        emit StakeXlx(account, xlxAmount);\n\n        return xlxAmount;\n    }\n\n    function unstakeAndRedeemXlx(address _tokenOut, uint256 _xlxAmount, uint256 _minOut, address _receiver) external nonReentrant returns (uint256) {\n        require(_xlxAmount > 0, \"RewardRouter: invalid _xlxAmount\");\n\n        address account = msg.sender;\n        IRewardTracker(stakedXlxTracker).unstakeForAccount(account, feeXlxTracker, _xlxAmount, account);\n        IRewardTracker(feeXlxTracker).unstakeForAccount(account, xlx, _xlxAmount, account);\n        uint256 amountOut = IXlxManager(xlxManager).removeLiquidityForAccount(account, _tokenOut, _xlxAmount, _minOut, _receiver);\n\n        emit UnstakeXlx(account, _xlxAmount);\n\n        return amountOut;\n    }\n\n    function unstakeAndRedeemXlxETH(uint256 _xlxAmount, uint256 _minOut, address payable _receiver) external nonReentrant returns (uint256) {\n        require(_xlxAmount > 0, \"RewardRouter: invalid _xlxAmount\");\n\n        address account = msg.sender;\n        IRewardTracker(stakedXlxTracker).unstakeForAccount(account, feeXlxTracker, _xlxAmount, account);\n        IRewardTracker(feeXlxTracker).unstakeForAccount(account, xlx, _xlxAmount, account);\n        uint256 amountOut = IXlxManager(xlxManager).removeLiquidityForAccount(account, weth, _xlxAmount, _minOut, address(this));\n\n        IWETH(weth).withdraw(amountOut);\n\n        _receiver.sendValue(amountOut);\n\n        emit UnstakeXlx(account, _xlxAmount);\n\n        return amountOut;\n    }\n\n    function claim() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(feeXdxTracker).claimForAccount(account, account);\n        IRewardTracker(feeXlxTracker).claimForAccount(account, account);\n\n        IRewardTracker(stakedXdxTracker).claimForAccount(account, account);\n        IRewardTracker(stakedXlxTracker).claimForAccount(account, account);\n    }\n\n    function claimEsXdx() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(stakedXdxTracker).claimForAccount(account, account);\n        IRewardTracker(stakedXlxTracker).claimForAccount(account, account);\n    }\n\n    function claimFees() external nonReentrant {\n        address account = msg.sender;\n\n        IRewardTracker(feeXdxTracker).claimForAccount(account, account);\n        IRewardTracker(feeXlxTracker).claimForAccount(account, account);\n    }\n\n    function compound() external nonReentrant {\n        _compound(msg.sender);\n    }\n\n    function compoundForAccount(address _account) external nonReentrant onlyGov {\n        _compound(_account);\n    }\n\n    function batchCompoundForAccounts(address[] memory _accounts) external nonReentrant onlyGov {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _compound(_accounts[i]);\n        }\n    }\n\n    function _compound(address _account) private {\n        _compoundXdx(_account);\n        _compoundXlx(_account);\n    }\n\n    function _compoundXdx(address _account) private {\n        uint256 esXdxAmount = IRewardTracker(stakedXdxTracker).claimForAccount(_account, _account);\n        if (esXdxAmount > 0) {\n            _stakeXdx(_account, _account, esXdx, esXdxAmount);\n        }\n\n        uint256 bnXdxAmount = IRewardTracker(bonusXdxTracker).claimForAccount(_account, _account);\n        if (bnXdxAmount > 0) {\n            IRewardTracker(feeXdxTracker).stakeForAccount(_account, _account, bnXdx, bnXdxAmount);\n        }\n    }\n\n    function _compoundXlx(address _account) private {\n        uint256 esXdxAmount = IRewardTracker(stakedXlxTracker).claimForAccount(_account, _account);\n        if (esXdxAmount > 0) {\n            _stakeXdx(_account, _account, esXdx, esXdxAmount);\n        }\n    }\n\n    function _stakeXdx(address _fundingAccount, address _account, address _token, uint256 _amount) private {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        IRewardTracker(stakedXdxTracker).stakeForAccount(_fundingAccount, _account, _token, _amount);\n        IRewardTracker(bonusXdxTracker).stakeForAccount(_account, _account, stakedXdxTracker, _amount);\n        IRewardTracker(feeXdxTracker).stakeForAccount(_account, _account, bonusXdxTracker, _amount);\n\n        emit StakeXdx(_account, _amount);\n    }\n\n    function _unstakeXdx(address _account, address _token, uint256 _amount) private {\n        require(_amount > 0, \"RewardRouter: invalid _amount\");\n\n        uint256 balance = IRewardTracker(stakedXdxTracker).stakedAmounts(_account);\n\n        IRewardTracker(feeXdxTracker).unstakeForAccount(_account, bonusXdxTracker, _amount, _account);\n        IRewardTracker(bonusXdxTracker).unstakeForAccount(_account, stakedXdxTracker, _amount, _account);\n        IRewardTracker(stakedXdxTracker).unstakeForAccount(_account, _token, _amount, _account);\n\n        uint256 bnXdxAmount = IRewardTracker(bonusXdxTracker).claimForAccount(_account, _account);\n        if (bnXdxAmount > 0) {\n            IRewardTracker(feeXdxTracker).stakeForAccount(_account, _account, bnXdx, bnXdxAmount);\n        }\n\n        uint256 stakedBnXdx = IRewardTracker(feeXdxTracker).depositBalances(_account, bnXdx);\n        if (stakedBnXdx > 0) {\n            uint256 reductionAmount = stakedBnXdx.mul(_amount).div(balance);\n            IRewardTracker(feeXdxTracker).unstakeForAccount(_account, bnXdx, reductionAmount, _account);\n            IMintable(bnXdx).burn(_account, reductionAmount);\n        }\n\n        emit UnstakeXdx(_account, _amount);\n    }\n}\n"
    },
    "contracts/libraries/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // If there is no base URI, return the token URI.\n        if (bytes(_baseURI).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "contracts/libraries/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/libraries/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "contracts/libraries/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "contracts/libraries/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/libraries/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        return _get(map, key, \"EnumerableMap: nonexistent key\");\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\n    }\n}\n"
    },
    "contracts/libraries/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = byte(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/libraries/token/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/libraries/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() internal {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"
    },
    "contracts/core/OrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../tokens/interfaces/IWETH.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/Address.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOrderBook.sol\";\n\ncontract OrderBook is ReentrancyGuard, IOrderBook {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    uint256 public constant PRICE_PRECISION = 1e30;\n    uint256 public constant USDG_PRECISION = 1e18;\n\n    struct IncreaseOrder {\n        address account;\n        address purchaseToken;\n        uint256 purchaseTokenAmount;\n        address collateralToken;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n    struct DecreaseOrder {\n        address account;\n        address collateralToken;\n        uint256 collateralDelta;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n    struct SwapOrder {\n        address account;\n        address[] path;\n        uint256 amountIn;\n        uint256 minOut;\n        uint256 triggerRatio;\n        bool triggerAboveThreshold;\n        bool shouldUnwrap;\n        uint256 executionFee;\n    }\n\n    mapping (address => mapping(uint256 => IncreaseOrder)) public increaseOrders;\n    mapping (address => uint256) public increaseOrdersIndex;\n    mapping (address => mapping(uint256 => DecreaseOrder)) public decreaseOrders;\n    mapping (address => uint256) public decreaseOrdersIndex;\n    mapping (address => mapping(uint256 => SwapOrder)) public swapOrders;\n    mapping (address => uint256) public swapOrdersIndex;\n\n    address public gov;\n    address public weth;\n    address public usdg;\n    address public router;\n    address public vault;\n    uint256 public minExecutionFee;\n    uint256 public minPurchaseTokenAmountUsd;\n    bool public isInitialized = false;\n\n    event CreateIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n    event CancelIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n    event ExecuteIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee,\n        uint256 executionPrice\n    );\n    event UpdateIncreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 sizeDelta,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold\n    );\n    event CreateDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n    event CancelDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    );\n    event ExecuteDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee,\n        uint256 executionPrice\n    );\n    event UpdateDecreaseOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold\n    );\n    event CreateSwapOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address[] path,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 triggerRatio,\n        bool triggerAboveThreshold,\n        bool shouldUnwrap,\n        uint256 executionFee\n    );\n    event CancelSwapOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address[] path,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 triggerRatio,\n        bool triggerAboveThreshold,\n        bool shouldUnwrap,\n        uint256 executionFee\n    );\n    event UpdateSwapOrder(\n        address indexed account,\n        uint256 ordexIndex,\n        address[] path,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 triggerRatio,\n        bool triggerAboveThreshold,\n        bool shouldUnwrap,\n        uint256 executionFee\n    );\n    event ExecuteSwapOrder(\n        address indexed account,\n        uint256 orderIndex,\n        address[] path,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 amountOut,\n        uint256 triggerRatio,\n        bool triggerAboveThreshold,\n        bool shouldUnwrap,\n        uint256 executionFee\n    );\n\n    event Initialize(\n        address router,\n        address vault,\n        address weth,\n        address usdg,\n        uint256 minExecutionFee,\n        uint256 minPurchaseTokenAmountUsd\n    );\n    event UpdateMinExecutionFee(uint256 minExecutionFee);\n    event UpdateMinPurchaseTokenAmountUsd(uint256 minPurchaseTokenAmountUsd);\n    event UpdateGov(address gov);\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"OrderBook: forbidden\");\n        _;\n    }\n\n    constructor() public {\n        gov = msg.sender;\n    }\n\n    function initialize(\n        address _router,\n        address _vault,\n        address _weth,\n        address _usdg,\n        uint256 _minExecutionFee,\n        uint256 _minPurchaseTokenAmountUsd\n    ) external onlyGov {\n        require(!isInitialized, \"OrderBook: already initialized\");\n        isInitialized = true;\n\n        router = _router;\n        vault = _vault;\n        weth = _weth;\n        usdg = _usdg;\n        minExecutionFee = _minExecutionFee;\n        minPurchaseTokenAmountUsd = _minPurchaseTokenAmountUsd;\n\n        emit Initialize(_router, _vault, _weth, _usdg, _minExecutionFee, _minPurchaseTokenAmountUsd);\n    }\n\n    receive() external payable {\n        require(msg.sender == weth, \"OrderBook: invalid sender\");\n    }\n\n    function setMinExecutionFee(uint256 _minExecutionFee) external onlyGov {\n        minExecutionFee = _minExecutionFee;\n\n        emit UpdateMinExecutionFee(_minExecutionFee);\n    }\n\n    function setMinPurchaseTokenAmountUsd(uint256 _minPurchaseTokenAmountUsd) external onlyGov {\n        minPurchaseTokenAmountUsd = _minPurchaseTokenAmountUsd;\n\n        emit UpdateMinPurchaseTokenAmountUsd(_minPurchaseTokenAmountUsd);\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n\n        emit UpdateGov(_gov);\n    }\n\n    function getSwapOrder(address _account, uint256 _orderIndex) override public view returns (\n        address path0,\n        address path1,\n        address path2,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 triggerRatio,\n        bool triggerAboveThreshold,\n        bool shouldUnwrap,\n        uint256 executionFee\n    ) {\n        SwapOrder memory order = swapOrders[_account][_orderIndex];\n        return (\n            order.path.length > 0 ? order.path[0] : address(0),\n            order.path.length > 1 ? order.path[1] : address(0),\n            order.path.length > 2 ? order.path[2] : address(0),\n            order.amountIn,\n            order.minOut,\n            order.triggerRatio,\n            order.triggerAboveThreshold,\n            order.shouldUnwrap,\n            order.executionFee\n        );\n    }\n\n    function createSwapOrder(\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _triggerRatio, // tokenB / tokenA\n        bool _triggerAboveThreshold,\n        uint256 _executionFee,\n        bool _shouldWrap,\n        bool _shouldUnwrap\n    ) external payable nonReentrant {\n        require(_path.length == 2 || _path.length == 3, \"OrderBook: invalid _path.length\");\n        require(_path[0] != _path[_path.length - 1], \"OrderBook: invalid _path\");\n        require(_amountIn > 0, \"OrderBook: invalid _amountIn\");\n        require(_executionFee >= minExecutionFee, \"OrderBook: insufficient execution fee\");\n\n        // always need this call because of mandatory executionFee user has to transfer in ETH\n        _transferInETH();\n\n        if (_shouldWrap) {\n            require(_path[0] == weth, \"OrderBook: only weth could be wrapped\");\n            require(msg.value == _executionFee.add(_amountIn), \"OrderBook: incorrect value transferred\");\n        } else {\n            require(msg.value == _executionFee, \"OrderBook: incorrect execution fee transferred\");\n            IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n        }\n\n        _createSwapOrder(msg.sender, _path, _amountIn, _minOut, _triggerRatio, _triggerAboveThreshold, _shouldUnwrap, _executionFee);\n    }\n\n    function _createSwapOrder(\n        address _account,\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _triggerRatio,\n        bool _triggerAboveThreshold,\n        bool _shouldUnwrap,\n        uint256 _executionFee\n    ) private {\n        uint256 _orderIndex = swapOrdersIndex[_account];\n        SwapOrder memory order = SwapOrder(\n            _account,\n            _path,\n            _amountIn,\n            _minOut,\n            _triggerRatio,\n            _triggerAboveThreshold,\n            _shouldUnwrap,\n            _executionFee\n        );\n        swapOrdersIndex[_account] = _orderIndex.add(1);\n        swapOrders[_account][_orderIndex] = order;\n\n        emit CreateSwapOrder(\n            _account,\n            _orderIndex,\n            _path,\n            _amountIn,\n            _minOut,\n            _triggerRatio,\n            _triggerAboveThreshold,\n            _shouldUnwrap,\n            _executionFee\n        );\n    }\n\n    function cancelMultiple(\n        uint256[] memory _swapOrderIndexes,\n        uint256[] memory _increaseOrderIndexes,\n        uint256[] memory _decreaseOrderIndexes\n    ) external {\n        for (uint256 i = 0; i < _swapOrderIndexes.length; i++) {\n            cancelSwapOrder(_swapOrderIndexes[i]);\n        }\n        for (uint256 i = 0; i < _increaseOrderIndexes.length; i++) {\n            cancelIncreaseOrder(_increaseOrderIndexes[i]);\n        }\n        for (uint256 i = 0; i < _decreaseOrderIndexes.length; i++) {\n            cancelDecreaseOrder(_decreaseOrderIndexes[i]);\n        }\n    }\n\n    function cancelSwapOrder(uint256 _orderIndex) public nonReentrant {\n        SwapOrder memory order = swapOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        delete swapOrders[msg.sender][_orderIndex];\n\n        if (order.path[0] == weth) {\n            _transferOutETH(order.executionFee.add(order.amountIn), msg.sender);\n        } else {\n            IERC20(order.path[0]).safeTransfer(msg.sender, order.amountIn);\n            _transferOutETH(order.executionFee, msg.sender);\n        }\n\n        emit CancelSwapOrder(\n            msg.sender,\n            _orderIndex,\n            order.path,\n            order.amountIn,\n            order.minOut,\n            order.triggerRatio,\n            order.triggerAboveThreshold,\n            order.shouldUnwrap,\n            order.executionFee\n        );\n    }\n\n    function getUsdgMinPrice(address _otherToken) public view returns (uint256) {\n        // USDG_PRECISION is the same as 1 USDG\n        uint256 redemptionAmount = IVault(vault).getRedemptionAmount(_otherToken, USDG_PRECISION);\n        uint256 otherTokenPrice = IVault(vault).getMinPrice(_otherToken);\n\n        uint256 otherTokenDecimals = IVault(vault).tokenDecimals(_otherToken);\n        return redemptionAmount.mul(otherTokenPrice).div(10 ** otherTokenDecimals);\n    }\n\n    function validateSwapOrderPriceWithTriggerAboveThreshold(\n        address[] memory _path,\n        uint256 _triggerRatio\n    ) public view returns (bool) {\n        require(_path.length == 2 || _path.length == 3, \"OrderBook: invalid _path.length\");\n\n        // limit orders don't need this validation because minOut is enough\n        // so this validation handles scenarios for stop orders only\n        // when a user wants to swap when a price of tokenB increases relative to tokenA\n        address tokenA = _path[0];\n        address tokenB = _path[_path.length - 1];\n        uint256 tokenAPrice;\n        uint256 tokenBPrice;\n\n        // 1. USDG doesn't have a price feed so we need to calculate it based on redepmtion amount of a specific token\n        // That's why USDG price in USD can vary depending on the redepmtion token\n        // 2. In complex scenarios with path=[USDG, BNB, BTC] we need to know how much BNB we'll get for provided USDG\n        // to know how much BTC will be received\n        // That's why in such scenario BNB should be used to determine price of USDG\n        if (tokenA == usdg) {\n            // with both _path.length == 2 or 3 we need usdg price against _path[1]\n            tokenAPrice = getUsdgMinPrice(_path[1]);\n        } else {\n            tokenAPrice = IVault(vault).getMinPrice(tokenA);\n        }\n\n        if (tokenB == usdg) {\n            tokenBPrice = PRICE_PRECISION;\n        } else {\n            tokenBPrice = IVault(vault).getMaxPrice(tokenB);\n        }\n\n        uint256 currentRatio = tokenBPrice.mul(PRICE_PRECISION).div(tokenAPrice);\n\n        bool isValid = currentRatio > _triggerRatio;\n        return isValid;\n    }\n\n    function updateSwapOrder(uint256 _orderIndex, uint256 _minOut, uint256 _triggerRatio, bool _triggerAboveThreshold) external nonReentrant {\n        SwapOrder storage order = swapOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        order.minOut = _minOut;\n        order.triggerRatio = _triggerRatio;\n        order.triggerAboveThreshold = _triggerAboveThreshold;\n\n        emit UpdateSwapOrder(\n            msg.sender,\n            _orderIndex,\n            order.path,\n            order.amountIn,\n            _minOut,\n            _triggerRatio,\n            _triggerAboveThreshold,\n            order.shouldUnwrap,\n            order.executionFee\n        );\n    }\n\n    function executeSwapOrder(address _account, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n        SwapOrder memory order = swapOrders[_account][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        if (order.triggerAboveThreshold) {\n            // gas optimisation\n            // order.minAmount should prevent wrong price execution in case of simple limit order\n            require(\n                validateSwapOrderPriceWithTriggerAboveThreshold(order.path, order.triggerRatio),\n                \"OrderBook: invalid price for execution\"\n            );\n        }\n\n        delete swapOrders[_account][_orderIndex];\n\n        IERC20(order.path[0]).safeTransfer(vault, order.amountIn);\n\n        uint256 _amountOut;\n        if (order.path[order.path.length - 1] == weth && order.shouldUnwrap) {\n            _amountOut = _swap(order.path, order.minOut, address(this));\n            _transferOutETH(_amountOut, payable(order.account));\n        } else {\n            _amountOut = _swap(order.path, order.minOut, order.account);\n        }\n\n        // pay executor\n        _transferOutETH(order.executionFee, _feeReceiver);\n\n        emit ExecuteSwapOrder(\n            _account,\n            _orderIndex,\n            order.path,\n            order.amountIn,\n            order.minOut,\n            _amountOut,\n            order.triggerRatio,\n            order.triggerAboveThreshold,\n            order.shouldUnwrap,\n            order.executionFee\n        );\n    }\n\n    function validatePositionOrderPrice(\n        bool _triggerAboveThreshold,\n        uint256 _triggerPrice,\n        address _indexToken,\n        bool _maximizePrice,\n        bool _raise\n    ) public view returns (uint256, bool) {\n        uint256 currentPrice = _maximizePrice\n            ? IVault(vault).getMaxPrice(_indexToken) : IVault(vault).getMinPrice(_indexToken);\n        bool isPriceValid = _triggerAboveThreshold ? currentPrice > _triggerPrice : currentPrice < _triggerPrice;\n        if (_raise) {\n            require(isPriceValid, \"OrderBook: invalid price for execution\");\n        }\n        return (currentPrice, isPriceValid);\n    }\n\n    function getDecreaseOrder(address _account, uint256 _orderIndex) override public view returns (\n        address collateralToken,\n        uint256 collateralDelta,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    ) {\n        DecreaseOrder memory order = decreaseOrders[_account][_orderIndex];\n        return (\n            order.collateralToken,\n            order.collateralDelta,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee\n        );\n    }\n\n    function getIncreaseOrder(address _account, uint256 _orderIndex) override public view returns (\n        address purchaseToken,\n        uint256 purchaseTokenAmount,\n        address collateralToken,\n        address indexToken,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 triggerPrice,\n        bool triggerAboveThreshold,\n        uint256 executionFee\n    ) {\n        IncreaseOrder memory order = increaseOrders[_account][_orderIndex];\n        return (\n            order.purchaseToken,\n            order.purchaseTokenAmount,\n            order.collateralToken,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee\n        );\n    }\n\n    function createIncreaseOrder(\n        address[] memory _path,\n        uint256 _amountIn,\n        address _indexToken,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        address _collateralToken,\n        bool _isLong,\n        uint256 _triggerPrice,\n        bool _triggerAboveThreshold,\n        uint256 _executionFee,\n        bool _shouldWrap\n    ) external payable nonReentrant {\n        // always need this call because of mandatory executionFee user has to transfer in ETH\n        _transferInETH();\n\n        require(_executionFee >= minExecutionFee, \"OrderBook: insufficient execution fee\");\n        if (_shouldWrap) {\n            require(_path[0] == weth, \"OrderBook: only weth could be wrapped\");\n            require(msg.value == _executionFee.add(_amountIn), \"OrderBook: incorrect value transferred\");\n        } else {\n            require(msg.value == _executionFee, \"OrderBook: incorrect execution fee transferred\");\n            IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n        }\n\n        address _purchaseToken = _path[_path.length - 1];\n        uint256 _purchaseTokenAmount;\n        if (_path.length > 1) {\n            require(_path[0] != _purchaseToken, \"OrderBook: invalid _path\");\n            IERC20(_path[0]).safeTransfer(vault, _amountIn);\n            _purchaseTokenAmount = _swap(_path, _minOut, address(this));\n        } else {\n            _purchaseTokenAmount = _amountIn;\n        }\n\n        {\n            uint256 _purchaseTokenAmountUsd = IVault(vault).tokenToUsdMin(_purchaseToken, _purchaseTokenAmount);\n            require(_purchaseTokenAmountUsd >= minPurchaseTokenAmountUsd, \"OrderBook: insufficient collateral\");\n        }\n\n        _createIncreaseOrder(\n            msg.sender,\n            _purchaseToken,\n            _purchaseTokenAmount,\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            _executionFee\n        );\n    }\n\n    function _createIncreaseOrder(\n        address _account,\n        address _purchaseToken,\n        uint256 _purchaseTokenAmount,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _triggerPrice,\n        bool _triggerAboveThreshold,\n        uint256 _executionFee\n    ) private {\n        uint256 _orderIndex = increaseOrdersIndex[msg.sender];\n        IncreaseOrder memory order = IncreaseOrder(\n            _account,\n            _purchaseToken,\n            _purchaseTokenAmount,\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            _executionFee\n        );\n        increaseOrdersIndex[_account] = _orderIndex.add(1);\n        increaseOrders[_account][_orderIndex] = order;\n\n        emit CreateIncreaseOrder(\n            _account,\n            _orderIndex,\n            _purchaseToken,\n            _purchaseTokenAmount,\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            _executionFee\n        );\n    }\n\n    function updateIncreaseOrder(uint256 _orderIndex, uint256 _sizeDelta, uint256 _triggerPrice, bool _triggerAboveThreshold) external nonReentrant {\n        IncreaseOrder storage order = increaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        order.triggerPrice = _triggerPrice;\n        order.triggerAboveThreshold = _triggerAboveThreshold;\n        order.sizeDelta = _sizeDelta;\n\n        emit UpdateIncreaseOrder(\n            msg.sender,\n            _orderIndex,\n            order.collateralToken,\n            order.indexToken,\n            order.isLong,\n            _sizeDelta,\n            _triggerPrice,\n            _triggerAboveThreshold\n        );\n    }\n\n    function cancelIncreaseOrder(uint256 _orderIndex) public nonReentrant {\n        IncreaseOrder memory order = increaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        delete increaseOrders[msg.sender][_orderIndex];\n\n        if (order.purchaseToken == weth) {\n            _transferOutETH(order.executionFee.add(order.purchaseTokenAmount), msg.sender);\n        } else {\n            IERC20(order.purchaseToken).safeTransfer(msg.sender, order.purchaseTokenAmount);\n            _transferOutETH(order.executionFee, msg.sender);\n        }\n\n        emit CancelIncreaseOrder(\n            order.account,\n            _orderIndex,\n            order.purchaseToken,\n            order.purchaseTokenAmount,\n            order.collateralToken,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee\n        );\n    }\n\n    function executeIncreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n        IncreaseOrder memory order = increaseOrders[_address][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        // increase long should use max price\n        // increase short should use min price\n        (uint256 currentPrice, ) = validatePositionOrderPrice(\n            order.triggerAboveThreshold,\n            order.triggerPrice,\n            order.indexToken,\n            order.isLong,\n            true\n        );\n\n        delete increaseOrders[_address][_orderIndex];\n\n        IERC20(order.purchaseToken).safeTransfer(vault, order.purchaseTokenAmount);\n\n        if (order.purchaseToken != order.collateralToken) {\n            address[] memory path = new address[](2);\n            path[0] = order.purchaseToken;\n            path[1] = order.collateralToken;\n\n            uint256 amountOut = _swap(path, 0, address(this));\n            IERC20(order.collateralToken).safeTransfer(vault, amountOut);\n        }\n\n        IRouter(router).pluginIncreasePosition(order.account, order.collateralToken, order.indexToken, order.sizeDelta, order.isLong);\n\n        // pay executor\n        _transferOutETH(order.executionFee, _feeReceiver);\n\n        emit ExecuteIncreaseOrder(\n            order.account,\n            _orderIndex,\n            order.purchaseToken,\n            order.purchaseTokenAmount,\n            order.collateralToken,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee,\n            currentPrice\n        );\n    }\n\n    function createDecreaseOrder(\n        address _indexToken,\n        uint256 _sizeDelta,\n        address _collateralToken,\n        uint256 _collateralDelta,\n        bool _isLong,\n        uint256 _triggerPrice,\n        bool _triggerAboveThreshold\n    ) external payable nonReentrant {\n        _transferInETH();\n\n        require(msg.value > minExecutionFee, \"OrderBook: insufficient execution fee\");\n\n        _createDecreaseOrder(\n            msg.sender,\n            _collateralToken,\n            _collateralDelta,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold\n        );\n    }\n\n    function _createDecreaseOrder(\n        address _account,\n        address _collateralToken,\n        uint256 _collateralDelta,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _triggerPrice,\n        bool _triggerAboveThreshold\n    ) private {\n        uint256 _orderIndex = decreaseOrdersIndex[_account];\n        DecreaseOrder memory order = DecreaseOrder(\n            _account,\n            _collateralToken,\n            _collateralDelta,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            msg.value\n        );\n        decreaseOrdersIndex[_account] = _orderIndex.add(1);\n        decreaseOrders[_account][_orderIndex] = order;\n\n        emit CreateDecreaseOrder(\n            _account,\n            _orderIndex,\n            _collateralToken,\n            _collateralDelta,\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _triggerPrice,\n            _triggerAboveThreshold,\n            msg.value\n        );\n    }\n\n    function executeDecreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n        DecreaseOrder memory order = decreaseOrders[_address][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        // decrease long should use min price\n        // decrease short should use max price\n        (uint256 currentPrice, ) = validatePositionOrderPrice(\n            order.triggerAboveThreshold,\n            order.triggerPrice,\n            order.indexToken,\n            !order.isLong,\n            true\n        );\n\n        delete decreaseOrders[_address][_orderIndex];\n\n        uint256 amountOut = IRouter(router).pluginDecreasePosition(\n            order.account,\n            order.collateralToken,\n            order.indexToken,\n            order.collateralDelta,\n            order.sizeDelta,\n            order.isLong,\n            address(this)\n        );\n\n        // transfer released collateral to user\n        if (order.collateralToken == weth) {\n            _transferOutETH(amountOut, payable(order.account));\n        } else {\n            IERC20(order.collateralToken).safeTransfer(order.account, amountOut);\n        }\n\n        // pay executor\n        _transferOutETH(order.executionFee, _feeReceiver);\n\n        emit ExecuteDecreaseOrder(\n            order.account,\n            _orderIndex,\n            order.collateralToken,\n            order.collateralDelta,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee,\n            currentPrice\n        );\n    }\n\n    function cancelDecreaseOrder(uint256 _orderIndex) public nonReentrant {\n        DecreaseOrder memory order = decreaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        delete decreaseOrders[msg.sender][_orderIndex];\n        _transferOutETH(order.executionFee, msg.sender);\n\n        emit CancelDecreaseOrder(\n            order.account,\n            _orderIndex,\n            order.collateralToken,\n            order.collateralDelta,\n            order.indexToken,\n            order.sizeDelta,\n            order.isLong,\n            order.triggerPrice,\n            order.triggerAboveThreshold,\n            order.executionFee\n        );\n    }\n\n    function updateDecreaseOrder(\n        uint256 _orderIndex,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _triggerPrice,\n        bool _triggerAboveThreshold\n    ) external nonReentrant {\n        DecreaseOrder storage order = decreaseOrders[msg.sender][_orderIndex];\n        require(order.account != address(0), \"OrderBook: non-existent order\");\n\n        order.triggerPrice = _triggerPrice;\n        order.triggerAboveThreshold = _triggerAboveThreshold;\n        order.sizeDelta = _sizeDelta;\n        order.collateralDelta = _collateralDelta;\n\n        emit UpdateDecreaseOrder(\n            msg.sender,\n            _orderIndex,\n            order.collateralToken,\n            _collateralDelta,\n            order.indexToken,\n            _sizeDelta,\n            order.isLong,\n            _triggerPrice,\n            _triggerAboveThreshold\n        );\n    }\n\n    function _transferInETH() private {\n        if (msg.value != 0) {\n            IWETH(weth).deposit{value: msg.value}();\n        }\n    }\n\n    function _transferOutETH(uint256 _amountOut, address payable _receiver) private {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.sendValue(_amountOut);\n    }\n\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) private returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        if (_path.length == 3) {\n            uint256 midOut = _vaultSwap(_path[0], _path[1], 0, address(this));\n            IERC20(_path[1]).safeTransfer(vault, midOut);\n            return _vaultSwap(_path[1], _path[2], _minOut, _receiver);\n        }\n\n        revert(\"OrderBook: invalid _path.length\");\n    }\n\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) private returns (uint256) {\n        uint256 amountOut;\n\n        if (_tokenOut == usdg) { // buyUSDG\n            amountOut = IVault(vault).buyUSDG(_tokenIn, _receiver);\n        } else if (_tokenIn == usdg) { // sellUSDG\n            amountOut = IVault(vault).sellUSDG(_tokenOut, _receiver);\n        } else { // swap\n            amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        }\n\n        require(amountOut >= _minOut, \"OrderBook: insufficient amountOut\");\n        return amountOut;\n    }\n}\n"
    },
    "contracts/peripherals/OrderBookReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"../core/interfaces/IOrderBook.sol\";\n\ncontract OrderBookReader {\n    using SafeMath for uint256;\n\n    struct Vars {\n        uint256 i;\n        uint256 index;\n        address account;\n        uint256 uintLength;\n        uint256 addressLength;\n    }\n\n    function getIncreaseOrders(\n        address payable _orderBookAddress, \n        address _account,\n        uint256[] memory _indices\n    ) external view returns (uint256[] memory, address[] memory) {\n        Vars memory vars = Vars(0, 0, _account, 5, 3);\n\n        uint256[] memory uintProps = new uint256[](vars.uintLength * _indices.length);\n        address[] memory addressProps = new address[](vars.addressLength * _indices.length);\n\n        IOrderBook orderBook = IOrderBook(_orderBookAddress);\n\n        while (vars.i < _indices.length) {\n            vars.index = _indices[vars.i];\n            (\n                address purchaseToken,\n                uint256 purchaseTokenAmount,\n                address collateralToken,\n                address indexToken,\n                uint256 sizeDelta,\n                bool isLong,\n                uint256 triggerPrice,\n                bool triggerAboveThreshold,\n                // uint256 executionFee\n            ) = orderBook.getIncreaseOrder(vars.account, vars.index);\n\n            uintProps[vars.i * vars.uintLength] = uint256(purchaseTokenAmount);\n            uintProps[vars.i * vars.uintLength + 1] = uint256(sizeDelta);\n            uintProps[vars.i * vars.uintLength + 2] = uint256(isLong ? 1 : 0);\n            uintProps[vars.i * vars.uintLength + 3] = uint256(triggerPrice);\n            uintProps[vars.i * vars.uintLength + 4] = uint256(triggerAboveThreshold ? 1 : 0);\n\n            addressProps[vars.i * vars.addressLength] = (purchaseToken);\n            addressProps[vars.i * vars.addressLength + 1] = (collateralToken);\n            addressProps[vars.i * vars.addressLength + 2] = (indexToken);\n\n            vars.i++;\n        }\n\n        return (uintProps, addressProps);\n    }\n\n    function getDecreaseOrders(\n        address payable _orderBookAddress, \n        address _account,\n        uint256[] memory _indices\n    ) external view returns (uint256[] memory, address[] memory) {\n        Vars memory vars = Vars(0, 0, _account, 5, 2);\n\n        uint256[] memory uintProps = new uint256[](vars.uintLength * _indices.length);\n        address[] memory addressProps = new address[](vars.addressLength * _indices.length);\n\n        IOrderBook orderBook = IOrderBook(_orderBookAddress);\n\n        while (vars.i < _indices.length) {\n            vars.index = _indices[vars.i];\n            (\n                address collateralToken,\n                uint256 collateralDelta,\n                address indexToken,\n                uint256 sizeDelta,\n                bool isLong,\n                uint256 triggerPrice,\n                bool triggerAboveThreshold,\n                // uint256 executionFee\n            ) = orderBook.getDecreaseOrder(vars.account, vars.index);\n\n            uintProps[vars.i * vars.uintLength] = uint256(collateralDelta);\n            uintProps[vars.i * vars.uintLength + 1] = uint256(sizeDelta);\n            uintProps[vars.i * vars.uintLength + 2] = uint256(isLong ? 1 : 0);\n            uintProps[vars.i * vars.uintLength + 3] = uint256(triggerPrice);\n            uintProps[vars.i * vars.uintLength + 4] = uint256(triggerAboveThreshold ? 1 : 0);\n\n            addressProps[vars.i * vars.addressLength] = (collateralToken);\n            addressProps[vars.i * vars.addressLength + 1] = (indexToken);\n\n            vars.i++;\n        }\n\n        return (uintProps, addressProps);\n    }\n\n    function getSwapOrders(\n        address payable _orderBookAddress, \n        address _account,\n        uint256[] memory _indices\n    ) external view returns (uint256[] memory, address[] memory) {\n        Vars memory vars = Vars(0, 0, _account, 5, 3);\n\n        uint256[] memory uintProps = new uint256[](vars.uintLength * _indices.length);\n        address[] memory addressProps = new address[](vars.addressLength * _indices.length);\n\n        IOrderBook orderBook = IOrderBook(_orderBookAddress);\n\n        while (vars.i < _indices.length) {\n            vars.index = _indices[vars.i];\n            (\n                address path0,\n                address path1,\n                address path2,\n                uint256 amountIn, \n                uint256 minOut, \n                uint256 triggerRatio, \n                bool triggerAboveThreshold,\n                bool shouldUnwrap,\n                // uint256 executionFee\n            ) = orderBook.getSwapOrder(vars.account, vars.index);\n\n            uintProps[vars.i * vars.uintLength] = uint256(amountIn);\n            uintProps[vars.i * vars.uintLength + 1] = uint256(minOut);\n            uintProps[vars.i * vars.uintLength + 2] = uint256(triggerRatio);\n            uintProps[vars.i * vars.uintLength + 3] = uint256(triggerAboveThreshold ? 1 : 0);\n            uintProps[vars.i * vars.uintLength + 4] = uint256(shouldUnwrap ? 1 : 0);\n\n            addressProps[vars.i * vars.addressLength] = (path0);\n            addressProps[vars.i * vars.addressLength + 1] = (path1);\n            addressProps[vars.i * vars.addressLength + 2] = (path2);\n\n            vars.i++;\n        }\n\n        return (uintProps, addressProps);\n    }\n}\n"
    },
    "contracts/core/PositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOrderBook.sol\";\n\nimport \"../peripherals/interfaces/ITimelock.sol\";\nimport \"./BasePositionManager.sol\";\n\ncontract PositionManager is BasePositionManager {\n\n    address public orderBook;\n    bool public inLegacyMode;\n\n    bool public shouldValidateIncreaseOrder = true;\n\n    mapping (address => bool) public isOrderKeeper;\n    mapping (address => bool) public isPartner;\n    mapping (address => bool) public isLiquidator;\n\n    event SetOrderKeeper(address indexed account, bool isActive);\n    event SetLiquidator(address indexed account, bool isActive);\n    event SetPartner(address account, bool isActive);\n    event SetInLegacyMode(bool inLegacyMode);\n    event SetShouldValidateIncreaseOrder(bool shouldValidateIncreaseOrder);\n\n    modifier onlyOrderKeeper() {\n        require(isOrderKeeper[msg.sender], \"PositionManager: forbidden\");\n        _;\n    }\n\n    modifier onlyLiquidator() {\n        require(isLiquidator[msg.sender], \"PositionManager: forbidden\");\n        _;\n    }\n\n    modifier onlyPartnersOrLegacyMode() {\n        require(isPartner[msg.sender] || inLegacyMode, \"PositionManager: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _router,\n        address _weth,\n        uint256 _depositFee,\n        address _orderBook\n    ) public BasePositionManager(_vault, _router, _weth, _depositFee) {\n        orderBook = _orderBook;\n    }\n\n    function setOrderKeeper(address _account, bool _isActive) external onlyAdmin {\n        isOrderKeeper[_account] = _isActive;\n        emit SetOrderKeeper(_account, _isActive);\n    }\n\n    function setLiquidator(address _account, bool _isActive) external onlyAdmin {\n        isLiquidator[_account] = _isActive;\n        emit SetLiquidator(_account, _isActive);\n    }\n\n    function setPartner(address _account, bool _isActive) external onlyAdmin {\n        isPartner[_account] = _isActive;\n        emit SetPartner(_account, _isActive);\n    }\n\n    function setInLegacyMode(bool _inLegacyMode) external onlyAdmin {\n        inLegacyMode = _inLegacyMode;\n        emit SetInLegacyMode(_inLegacyMode);\n    }\n\n    function setShouldValidateIncreaseOrder(bool _shouldValidateIncreaseOrder) external onlyAdmin {\n        shouldValidateIncreaseOrder = _shouldValidateIncreaseOrder;\n        emit SetShouldValidateIncreaseOrder(_shouldValidateIncreaseOrder);\n    }\n\n    function increasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) external nonReentrant onlyPartnersOrLegacyMode {\n        require(_path.length == 1 || _path.length == 2, \"PositionManager: invalid _path.length\");\n\n        if (_amountIn > 0) {\n            if (_path.length == 1) {\n                IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n            } else {\n                IRouter(router).pluginTransfer(_path[0], msg.sender, vault, _amountIn);\n                _amountIn = _swap(_path, _minOut, address(this));\n            }\n\n            uint256 afterFeeAmount = _collectFees(msg.sender, _path, _amountIn, _indexToken, _isLong, _sizeDelta);\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, afterFeeAmount);\n        }\n\n        _increasePosition(msg.sender, _path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n\n    function increasePositionETH(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) external payable nonReentrant onlyPartnersOrLegacyMode {\n        require(_path.length == 1 || _path.length == 2, \"PositionManager: invalid _path.length\");\n        require(_path[0] == weth, \"PositionManager: invalid _path\");\n\n        if (msg.value > 0) {\n            _transferInETH();\n            uint256 _amountIn = msg.value;\n\n            if (_path.length > 1) {\n                IERC20(weth).safeTransfer(vault, msg.value);\n                _amountIn = _swap(_path, _minOut, address(this));\n            }\n\n            uint256 afterFeeAmount = _collectFees(msg.sender, _path, _amountIn, _indexToken, _isLong, _sizeDelta);\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, afterFeeAmount);\n        }\n\n        _increasePosition(msg.sender, _path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n\n    function decreasePosition(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _price\n    ) external nonReentrant onlyPartnersOrLegacyMode {\n        _decreasePosition(msg.sender, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver, _price);\n    }\n\n    function decreasePositionETH(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address payable _receiver,\n        uint256 _price\n    ) external nonReentrant onlyPartnersOrLegacyMode {\n        require(_collateralToken == weth, \"PositionManager: invalid _collateralToken\");\n\n        uint256 amountOut = _decreasePosition(msg.sender, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        _transferOutETH(amountOut, _receiver);\n    }\n\n    function decreasePositionAndSwap(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _price,\n        uint256 _minOut\n    ) external nonReentrant onlyPartnersOrLegacyMode {\n        require(_path.length == 2, \"PositionManager: invalid _path.length\");\n\n        uint256 amount = _decreasePosition(msg.sender, _path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        IERC20(_path[0]).safeTransfer(vault, amount);\n        _swap(_path, _minOut, _receiver);\n    }\n\n    function decreasePositionAndSwapETH(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address payable _receiver,\n        uint256 _price,\n        uint256 _minOut\n    ) external nonReentrant onlyPartnersOrLegacyMode {\n        require(_path.length == 2, \"PositionManager: invalid _path.length\");\n        require(_path[_path.length - 1] == weth, \"PositionManager: invalid _path\");\n\n        uint256 amount = _decreasePosition(msg.sender, _path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        IERC20(_path[0]).safeTransfer(vault, amount);\n        uint256 amountOut = _swap(_path, _minOut, address(this));\n        _transferOutETH(amountOut, _receiver);\n    }\n\n    function liquidatePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        address _feeReceiver\n    ) external nonReentrant onlyLiquidator {\n        address _vault = vault;\n        address timelock = IVault(_vault).gov();\n\n        ITimelock(timelock).enableLeverage(_vault);\n        IVault(_vault).liquidatePosition(_account, _collateralToken, _indexToken, _isLong, _feeReceiver);\n        ITimelock(timelock).disableLeverage(_vault);\n    }\n\n    function executeSwapOrder(address _account, uint256 _orderIndex, address payable _feeReceiver) external onlyOrderKeeper {\n        IOrderBook(orderBook).executeSwapOrder(_account, _orderIndex, _feeReceiver);\n    }\n\n    function executeIncreaseOrder(address _account, uint256 _orderIndex, address payable _feeReceiver) external onlyOrderKeeper {\n        uint256 sizeDelta =  _validateIncreaseOrder(_account, _orderIndex);\n\n        address _vault = vault;\n        address timelock = IVault(_vault).gov();\n\n        ITimelock(timelock).enableLeverage(_vault);\n        IOrderBook(orderBook).executeIncreaseOrder(_account, _orderIndex, _feeReceiver);\n        ITimelock(timelock).disableLeverage(_vault);\n\n        _emitIncreasePositionReferral(_account, sizeDelta);\n    }\n\n    function executeDecreaseOrder(address _account, uint256 _orderIndex, address payable _feeReceiver) external onlyOrderKeeper {\n        address _vault = vault;\n        address timelock = IVault(_vault).gov();\n\n        (\n            , // _collateralToken\n            , // _collateralDelta\n            , // _indexToken\n            uint256 _sizeDelta,\n            , // _isLong\n            , // triggerPrice\n            , // triggerAboveThreshold\n            // executionFee\n        ) = IOrderBook(orderBook).getDecreaseOrder(_account, _orderIndex);\n\n        ITimelock(timelock).enableLeverage(_vault);\n        IOrderBook(orderBook).executeDecreaseOrder(_account, _orderIndex, _feeReceiver);\n        ITimelock(timelock).disableLeverage(_vault);\n\n        _emitDecreasePositionReferral(_account, _sizeDelta);\n    }\n\n    function _validateIncreaseOrder(address _account, uint256 _orderIndex) internal view returns (uint256) {\n        (\n            address _purchaseToken,\n            uint256 _purchaseTokenAmount,\n            address _collateralToken,\n            address _indexToken,\n            uint256 _sizeDelta,\n            bool _isLong,\n            , // triggerPrice\n            , // triggerAboveThreshold\n            // executionFee\n        ) = IOrderBook(orderBook).getIncreaseOrder(_account, _orderIndex);\n\n        if (!shouldValidateIncreaseOrder) { return _sizeDelta; }\n\n        // shorts are okay\n        if (!_isLong) { return _sizeDelta; }\n\n        // if the position size is not increasing, this is a collateral deposit\n        require(_sizeDelta > 0, \"PositionManager: long deposit\");\n\n        IVault _vault = IVault(vault);\n        (uint256 size, uint256 collateral, , , , , , ) = _vault.getPosition(_account, _collateralToken, _indexToken, _isLong);\n\n        // if there is no existing position, do not charge a fee\n        if (size == 0) { return _sizeDelta; }\n\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 collateralDelta = _vault.tokenToUsdMin(_purchaseToken, _purchaseTokenAmount);\n        uint256 nextCollateral = collateral.add(collateralDelta);\n\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\n        // allow for a maximum of a increasePositionBufferBps decrease since there might be some swap fees taken from the collateral\n        uint256 nextLeverageWithBuffer = nextSize.mul(BASIS_POINTS_DIVISOR + increasePositionBufferBps).div(nextCollateral);\n\n        require(nextLeverageWithBuffer >= prevLeverage, \"PositionManager: long leverage decrease\");\n\n        return _sizeDelta;\n    }\n}\n"
    },
    "contracts/core/OrderExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOrderBook.sol\";\nimport \"../peripherals/interfaces/ITimelock.sol\";\n\ncontract OrderExecutor {\n    using SafeMath for uint256;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    address public vault;\n    address public orderBook;\n\n    constructor(address _vault, address _orderBook) public {\n        require(_vault != address(0) && _orderBook != address(0), \"OrderExecutor: invalid address\");\n        vault = _vault;\n        orderBook = _orderBook;\n    }\n\n    function executeSwapOrder(address _account, uint256 _orderIndex, address payable _feeReceiver) external {\n        IOrderBook(orderBook).executeSwapOrder(_account, _orderIndex, _feeReceiver);\n    }\n\n    function executeIncreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) external {\n        _validateIncreaseOrder(_address, _orderIndex);\n        address timelock = IVault(vault).gov();\n        ITimelock(timelock).setIsLeverageEnabled(vault, true);\n        IOrderBook(orderBook).executeIncreaseOrder(_address, _orderIndex, _feeReceiver);\n        ITimelock(timelock).setIsLeverageEnabled(vault, false);\n    }\n\n    function executeDecreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) external {\n        IOrderBook(orderBook).executeDecreaseOrder(_address, _orderIndex, _feeReceiver);\n    }\n\n    function _validateIncreaseOrder(address _account, uint256 _orderIndex) internal view {\n        (\n            address _purchaseToken,\n            uint256 _purchaseTokenAmount,\n            address _collateralToken,\n            address _indexToken,\n            uint256 _sizeDelta,\n            bool _isLong,\n            , // triggerPrice\n            , // triggerAboveThreshold\n            // executionFee\n        ) = IOrderBook(orderBook).getIncreaseOrder(_account, _orderIndex);\n\n        // shorts are okay\n        if (!_isLong) { return; }\n\n        // if the position size is not increasing, this is a collateral deposit\n        require(_sizeDelta > 0, \"OrderExecutor: long deposit\");\n\n        IVault _vault = IVault(vault);\n        (uint256 size, uint256 collateral, , , , , , ) = _vault.getPosition(_account, _collateralToken, _indexToken, _isLong);\n\n        // if there is no existing position, do not charge a fee\n        if (size == 0) { return; }\n\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 collateralDelta = _vault.tokenToUsdMin(_purchaseToken, _purchaseTokenAmount);\n        uint256 nextCollateral = collateral.add(collateralDelta);\n\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\n        // add 100 to allow for a maximum of a 1% decrease since there might be some swap fees taken from the collateral\n        uint256 nextLeverageWithBuffer = nextSize.mul(BASIS_POINTS_DIVISOR + 100).div(nextCollateral);\n\n        require(nextLeverageWithBuffer >= prevLeverage, \"OrderExecutor: long leverage decrease\");\n    }\n}"
    },
    "contracts/staking/BonusDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IRewardDistributor.sol\";\nimport \"./interfaces/IRewardTracker.sol\";\nimport \"../access/Governable.sol\";\n\ncontract BonusDistributor is IRewardDistributor, ReentrancyGuard, Governable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant BONUS_DURATION = 365 days;\n\n    uint256 public bonusMultiplierBasisPoints;\n\n    address public override rewardToken;\n    uint256 public lastDistributionTime;\n    address public rewardTracker;\n\n    address public admin;\n\n    event Distribute(uint256 amount);\n    event BonusMultiplierChange(uint256 amount);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"BonusDistributor: forbidden\");\n        _;\n    }\n\n    constructor(address _rewardToken, address _rewardTracker) public {\n        rewardToken = _rewardToken;\n        rewardTracker = _rewardTracker;\n        admin = msg.sender;\n    }\n\n    function setAdmin(address _admin) external onlyGov {\n        admin = _admin;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function updateLastDistributionTime() external onlyAdmin {\n        lastDistributionTime = block.timestamp;\n    }\n\n    function setBonusMultiplier(uint256 _bonusMultiplierBasisPoints) external onlyAdmin {\n        require(lastDistributionTime != 0, \"BonusDistributor: invalid lastDistributionTime\");\n        IRewardTracker(rewardTracker).updateRewards();\n        bonusMultiplierBasisPoints = _bonusMultiplierBasisPoints;\n        emit BonusMultiplierChange(_bonusMultiplierBasisPoints);\n    }\n\n    function tokensPerInterval() public view override returns (uint256) {\n        uint256 supply = IERC20(rewardTracker).totalSupply();\n        return supply.mul(bonusMultiplierBasisPoints).div(BASIS_POINTS_DIVISOR).div(BONUS_DURATION);\n    }\n\n    function pendingRewards() public view override returns (uint256) {\n        if (block.timestamp == lastDistributionTime) {\n            return 0;\n        }\n\n        uint256 supply = IERC20(rewardTracker).totalSupply();\n        uint256 timeDiff = block.timestamp.sub(lastDistributionTime);\n\n        return timeDiff.mul(supply).mul(bonusMultiplierBasisPoints).div(BASIS_POINTS_DIVISOR).div(BONUS_DURATION);\n    }\n\n    function distribute() external override returns (uint256) {\n        require(msg.sender == rewardTracker, \"BonusDistributor: invalid msg.sender\");\n        uint256 amount = pendingRewards();\n        if (amount == 0) { return 0; }\n\n        lastDistributionTime = block.timestamp;\n\n        uint256 balance = IERC20(rewardToken).balanceOf(address(this));\n        if (amount > balance) { amount = balance; }\n\n        IERC20(rewardToken).safeTransfer(msg.sender, amount);\n\n        emit Distribute(amount);\n        return amount;\n    }\n}\n"
    },
    "contracts/core/XlxManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IXlxManager.sol\";\nimport \"../tokens/interfaces/IUSDG.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../access/Governable.sol\";\n\npragma solidity 0.6.12;\n\ncontract XlxManager is ReentrancyGuard, Governable, IXlxManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant USDG_DECIMALS = 18;\n    uint256 public constant MAX_COOLDOWN_DURATION = 48 hours;\n\n    IVault public vault;\n    address public override usdg;\n    address public xlx;\n\n    uint256 public override cooldownDuration;\n    mapping (address => uint256) public override lastAddedAt;\n\n    uint256 public aumAddition;\n    uint256 public aumDeduction;\n\n    bool public inPrivateMode;\n    mapping (address => bool) public isHandler;\n\n    event AddLiquidity(\n        address account,\n        address token,\n        uint256 amount,\n        uint256 aumInUsdg,\n        uint256 xlxSupply,\n        uint256 usdgAmount,\n        uint256 mintAmount\n    );\n\n    event RemoveLiquidity(\n        address account,\n        address token,\n        uint256 xlxAmount,\n        uint256 aumInUsdg,\n        uint256 xlxSupply,\n        uint256 usdgAmount,\n        uint256 amountOut\n    );\n\n    constructor(address _vault, address _usdg, address _xlx, uint256 _cooldownDuration) public {\n        gov = msg.sender;\n        vault = IVault(_vault);\n        usdg = _usdg;\n        xlx = _xlx;\n        cooldownDuration = _cooldownDuration;\n    }\n\n    function setInPrivateMode(bool _inPrivateMode) external onlyGov {\n        inPrivateMode = _inPrivateMode;\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n\n    function setCooldownDuration(uint256 _cooldownDuration) external onlyGov {\n        require(_cooldownDuration <= MAX_COOLDOWN_DURATION, \"XlxManager: invalid _cooldownDuration\");\n        cooldownDuration = _cooldownDuration;\n    }\n\n    function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external onlyGov {\n        aumAddition = _aumAddition;\n        aumDeduction = _aumDeduction;\n    }\n\n    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minXlx) external override nonReentrant returns (uint256) {\n        if (inPrivateMode) { revert(\"XlxManager: action not enabled\"); }\n        return _addLiquidity(msg.sender, msg.sender, _token, _amount, _minUsdg, _minXlx);\n    }\n\n    function addLiquidityForAccount(address _fundingAccount, address _account, address _token, uint256 _amount, uint256 _minUsdg, uint256 _minXlx) external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _addLiquidity(_fundingAccount, _account, _token, _amount, _minUsdg, _minXlx);\n    }\n\n    function removeLiquidity(address _tokenOut, uint256 _xlxAmount, uint256 _minOut, address _receiver) external override nonReentrant returns (uint256) {\n        if (inPrivateMode) { revert(\"XlxManager: action not enabled\"); }\n        return _removeLiquidity(msg.sender, _tokenOut, _xlxAmount, _minOut, _receiver);\n    }\n\n    function removeLiquidityForAccount(address _account, address _tokenOut, uint256 _xlxAmount, uint256 _minOut, address _receiver) external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _removeLiquidity(_account, _tokenOut, _xlxAmount, _minOut, _receiver);\n    }\n\n    function getAums() public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = getAum(true);\n        amounts[1] = getAum(false);\n        return amounts;\n    }\n\n    function getAumInUsdg(bool maximise) public override view returns (uint256) {\n        uint256 aum = getAum(maximise);\n        return aum.mul(10 ** USDG_DECIMALS).div(PRICE_PRECISION);\n    }\n\n    function getAum(bool maximise) public view returns (uint256) {\n        uint256 length = vault.allWhitelistedTokensLength();\n        uint256 aum = aumAddition;\n        uint256 shortProfits = 0;\n\n        for (uint256 i = 0; i < length; i++) {\n            address token = vault.allWhitelistedTokens(i);\n            bool isWhitelisted = vault.whitelistedTokens(token);\n\n            if (!isWhitelisted) {\n                continue;\n            }\n\n            uint256 price = maximise ? vault.getMaxPrice(token) : vault.getMinPrice(token);\n            uint256 poolAmount = vault.poolAmounts(token);\n            uint256 decimals = vault.tokenDecimals(token);\n\n            if (vault.stableTokens(token)) {\n                aum = aum.add(poolAmount.mul(price).div(10 ** decimals));\n            } else {\n                // add global short profit / loss\n                uint256 size = vault.globalShortSizes(token);\n                if (size > 0) {\n                    uint256 averagePrice = vault.globalShortAveragePrices(token);\n                    uint256 priceDelta = averagePrice > price ? averagePrice.sub(price) : price.sub(averagePrice);\n                    uint256 delta = size.mul(priceDelta).div(averagePrice);\n                    if (price > averagePrice) {\n                        // add losses from shorts\n                        aum = aum.add(delta);\n                    } else {\n                        shortProfits = shortProfits.add(delta);\n                    }\n                }\n\n                aum = aum.add(vault.guaranteedUsd(token));\n\n                uint256 reservedAmount = vault.reservedAmounts(token);\n                aum = aum.add(poolAmount.sub(reservedAmount).mul(price).div(10 ** decimals));\n            }\n        }\n\n        aum = shortProfits > aum ? 0 : aum.sub(shortProfits);\n        return aumDeduction > aum ? 0 : aum.sub(aumDeduction);\n    }\n\n    function _addLiquidity(address _fundingAccount, address _account, address _token, uint256 _amount, uint256 _minUsdg, uint256 _minXlx) private returns (uint256) {\n        require(_amount > 0, \"XlxManager: invalid _amount\");\n\n        // calculate aum before buyUSDG\n        uint256 aumInUsdg = getAumInUsdg(true);\n        uint256 xlxSupply = IERC20(xlx).totalSupply();\n\n        IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount);\n        uint256 usdgAmount = vault.buyUSDG(_token, address(this));\n        require(usdgAmount >= _minUsdg, \"XlxManager: insufficient USDG output\");\n\n        uint256 mintAmount = aumInUsdg == 0 ? usdgAmount : usdgAmount.mul(xlxSupply).div(aumInUsdg);\n        require(mintAmount >= _minXlx, \"XlxManager: insufficient XLX output\");\n\n        IMintable(xlx).mint(_account, mintAmount);\n\n        lastAddedAt[_account] = block.timestamp;\n\n        emit AddLiquidity(_account, _token, _amount, aumInUsdg, xlxSupply, usdgAmount, mintAmount);\n\n        return mintAmount;\n    }\n\n    function _removeLiquidity(address _account, address _tokenOut, uint256 _xlxAmount, uint256 _minOut, address _receiver) private returns (uint256) {\n        require(_xlxAmount > 0, \"XlxManager: invalid _xlxAmount\");\n        require(lastAddedAt[_account].add(cooldownDuration) <= block.timestamp, \"XlxManager: cooldown duration not yet passed\");\n\n        // calculate aum before sellUSDG\n        uint256 aumInUsdg = getAumInUsdg(false);\n        uint256 xlxSupply = IERC20(xlx).totalSupply();\n\n        uint256 usdgAmount = _xlxAmount.mul(aumInUsdg).div(xlxSupply);\n        uint256 usdgBalance = IERC20(usdg).balanceOf(address(this));\n        if (usdgAmount > usdgBalance) {\n            IUSDG(usdg).mint(address(this), usdgAmount.sub(usdgBalance));\n        }\n\n        IMintable(xlx).burn(_account, _xlxAmount);\n\n        IERC20(usdg).transfer(address(vault), usdgAmount);\n        uint256 amountOut = vault.sellUSDG(_tokenOut, _receiver);\n        require(amountOut >= _minOut, \"XlxManager: insufficient output\");\n\n        emit RemoveLiquidity(_account, _tokenOut, _xlxAmount, aumInUsdg, xlxSupply, usdgAmount, amountOut);\n\n        return amountOut;\n    }\n\n    function _validateHandler() private view {\n        require(isHandler[msg.sender], \"XlxManager: forbidden\");\n    }\n}\n"
    },
    "contracts/core/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"../tokens/interfaces/IUSDG.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IVaultUtils.sol\";\nimport \"./interfaces/IVaultPriceFeed.sol\";\n\ncontract Vault is ReentrancyGuard, IVault {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct Position {\n        uint256 size;\n        uint256 collateral;\n        uint256 averagePrice;\n        uint256 entryFundingRate;\n        uint256 reserveAmount;\n        int256 realisedPnl;\n        uint256 lastIncreasedTime;\n    }\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant FUNDING_RATE_PRECISION = 1000000;\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant MIN_LEVERAGE = 10000; // 1x\n    uint256 public constant USDG_DECIMALS = 18;\n    uint256 public constant MAX_FEE_BASIS_POINTS = 500; // 5%\n    uint256 public constant MAX_LIQUIDATION_FEE_USD = 100 * PRICE_PRECISION; // 100 USD\n    uint256 public constant MIN_FUNDING_RATE_INTERVAL = 1 hours;\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 10000; // 1%\n\n    bool public override isInitialized;\n    bool public override isSwapEnabled = true;\n    bool public override isLeverageEnabled = true;\n\n    IVaultUtils public vaultUtils;\n\n    address public errorController;\n\n    address public override router;\n    address public override priceFeed;\n\n    address public override usdg;\n    address public override gov;\n\n    uint256 public override whitelistedTokenCount;\n\n    uint256 public override maxLeverage = 50 * 10000; // 50x\n\n    uint256 public override liquidationFeeUsd;\n    uint256 public override taxBasisPoints = 50; // 0.5%\n    uint256 public override stableTaxBasisPoints = 20; // 0.2%\n    uint256 public override mintBurnFeeBasisPoints = 30; // 0.3%\n    uint256 public override swapFeeBasisPoints = 30; // 0.3%\n    uint256 public override stableSwapFeeBasisPoints = 4; // 0.04%\n    uint256 public override marginFeeBasisPoints = 10; // 0.1%\n\n    uint256 public override minProfitTime;\n    bool public override hasDynamicFees = false;\n\n    uint256 public override fundingInterval = 8 hours;\n    uint256 public override fundingRateFactor;\n    uint256 public override stableFundingRateFactor;\n    uint256 public override totalTokenWeights;\n\n    bool public includeAmmPrice = true;\n    bool public useSwapPricing = false;\n\n    bool public override inManagerMode = false;\n    bool public override inPrivateLiquidationMode = false;\n\n    uint256 public override maxGasPrice;\n\n    mapping (address => mapping (address => bool)) public override approvedRouters;\n    mapping (address => bool) public override isLiquidator;\n    mapping (address => bool) public override isManager;\n\n    address[] public override allWhitelistedTokens;\n\n    mapping (address => bool) public override whitelistedTokens;\n    mapping (address => uint256) public override tokenDecimals;\n    mapping (address => uint256) public override minProfitBasisPoints;\n    mapping (address => bool) public override stableTokens;\n    mapping (address => bool) public override shortableTokens;\n\n    // tokenBalances is used only to determine _transferIn values\n    mapping (address => uint256) public override tokenBalances;\n\n    // tokenWeights allows customisation of index composition\n    mapping (address => uint256) public override tokenWeights;\n\n    // usdgAmounts tracks the amount of USDG debt for each whitelisted token\n    mapping (address => uint256) public override usdgAmounts;\n\n    // maxUsdgAmounts allows setting a max amount of USDG debt for a token\n    mapping (address => uint256) public override maxUsdgAmounts;\n\n    // poolAmounts tracks the number of received tokens that can be used for leverage\n    // this is tracked separately from tokenBalances to exclude funds that are deposited as margin collateral\n    mapping (address => uint256) public override poolAmounts;\n\n    // reservedAmounts tracks the number of tokens reserved for open leverage positions\n    mapping (address => uint256) public override reservedAmounts;\n\n    // bufferAmounts allows specification of an amount to exclude from swaps\n    // this can be used to ensure a certain amount of liquidity is available for leverage positions\n    mapping (address => uint256) public override bufferAmounts;\n\n    // guaranteedUsd tracks the amount of USD that is \"guaranteed\" by opened leverage positions\n    // this value is used to calculate the redemption values for selling of USDG\n    // this is an estimated amount, it is possible for the actual guaranteed value to be lower\n    // in the case of sudden price decreases, the guaranteed value should be corrected\n    // after liquidations are carried out\n    mapping (address => uint256) public override guaranteedUsd;\n\n    // cumulativeFundingRates tracks the funding rates based on utilization\n    mapping (address => uint256) public override cumulativeFundingRates;\n    // lastFundingTimes tracks the last time funding was updated for a token\n    mapping (address => uint256) public override lastFundingTimes;\n\n    // positions tracks all open positions\n    mapping (bytes32 => Position) public positions;\n\n    // feeReserves tracks the amount of fees per token\n    mapping (address => uint256) public override feeReserves;\n\n    mapping (address => uint256) public override globalShortSizes;\n    mapping (address => uint256) public override globalShortAveragePrices;\n    mapping (address => uint256) public override maxGlobalShortSizes;\n\n    mapping (uint256 => string) public errors;\n\n    event BuyUSDG(address account, address token, uint256 tokenAmount, uint256 usdgAmount, uint256 feeBasisPoints);\n    event SellUSDG(address account, address token, uint256 usdgAmount, uint256 tokenAmount, uint256 feeBasisPoints);\n    event Swap(address account, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, uint256 amountOutAfterFees, uint256 feeBasisPoints);\n\n    event IncreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event DecreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event LiquidatePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 size,\n        uint256 collateral,\n        uint256 reserveAmount,\n        int256 realisedPnl,\n        uint256 markPrice\n    );\n    event UpdatePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl,\n        uint256 markPrice\n    );\n    event ClosePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n\n    event DirectPoolDeposit(address token, uint256 amount);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event IncreaseUsdgAmount(address token, uint256 amount);\n    event DecreaseUsdgAmount(address token, uint256 amount);\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n\n    // once the parameters are verified to be working correctly,\n    // gov should be set to a timelock contract or a governance contract\n    constructor() public {\n        gov = msg.sender;\n    }\n\n    function initialize(\n        address _router,\n        address _usdg,\n        address _priceFeed,\n        uint256 _liquidationFeeUsd,\n        uint256 _fundingRateFactor,\n        uint256 _stableFundingRateFactor\n    ) external {\n        _onlyGov();\n        _validate(!isInitialized, 1);\n        isInitialized = true;\n\n        router = _router;\n        usdg = _usdg;\n        priceFeed = _priceFeed;\n        liquidationFeeUsd = _liquidationFeeUsd;\n        fundingRateFactor = _fundingRateFactor;\n        stableFundingRateFactor = _stableFundingRateFactor;\n    }\n\n    function setVaultUtils(IVaultUtils _vaultUtils) external override {\n        _onlyGov();\n        vaultUtils = _vaultUtils;\n    }\n\n    function setErrorController(address _errorController) external {\n        _onlyGov();\n        errorController = _errorController;\n    }\n\n    function setError(uint256 _errorCode, string calldata _error) external override {\n        require(msg.sender == errorController, \"Vault: invalid errorController\");\n        errors[_errorCode] = _error;\n    }\n\n    function allWhitelistedTokensLength() external override view returns (uint256) {\n        return allWhitelistedTokens.length;\n    }\n\n    function setInManagerMode(bool _inManagerMode) external override {\n        _onlyGov();\n        inManagerMode = _inManagerMode;\n    }\n\n    function setManager(address _manager, bool _isManager) external override {\n        _onlyGov();\n        isManager[_manager] = _isManager;\n    }\n\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external override {\n        _onlyGov();\n        inPrivateLiquidationMode = _inPrivateLiquidationMode;\n    }\n\n    function setLiquidator(address _liquidator, bool _isActive) external override {\n        _onlyGov();\n        isLiquidator[_liquidator] = _isActive;\n    }\n\n    function setIsSwapEnabled(bool _isSwapEnabled) external override {\n        _onlyGov();\n        isSwapEnabled = _isSwapEnabled;\n    }\n\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external override {\n        _onlyGov();\n        isLeverageEnabled = _isLeverageEnabled;\n    }\n\n    function setMaxGasPrice(uint256 _maxGasPrice) external override {\n        _onlyGov();\n        maxGasPrice = _maxGasPrice;\n    }\n\n    function setGov(address _gov) external {\n        _onlyGov();\n        gov = _gov;\n    }\n\n    function setPriceFeed(address _priceFeed) external override {\n        _onlyGov();\n        priceFeed = _priceFeed;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override {\n        _onlyGov();\n        _validate(_maxLeverage > MIN_LEVERAGE, 2);\n        maxLeverage = _maxLeverage;\n    }\n\n    function setBufferAmount(address _token, uint256 _amount) external override {\n        _onlyGov();\n        bufferAmounts[_token] = _amount;\n    }\n\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external override {\n        _onlyGov();\n        maxGlobalShortSizes[_token] = _amount;\n    }\n\n    function setFees(\n        uint256 _taxBasisPoints,\n        uint256 _stableTaxBasisPoints,\n        uint256 _mintBurnFeeBasisPoints,\n        uint256 _swapFeeBasisPoints,\n        uint256 _stableSwapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd,\n        uint256 _minProfitTime,\n        bool _hasDynamicFees\n    ) external override {\n        _onlyGov();\n        _validate(_taxBasisPoints <= MAX_FEE_BASIS_POINTS, 3);\n        _validate(_stableTaxBasisPoints <= MAX_FEE_BASIS_POINTS, 4);\n        _validate(_mintBurnFeeBasisPoints <= MAX_FEE_BASIS_POINTS, 5);\n        _validate(_swapFeeBasisPoints <= MAX_FEE_BASIS_POINTS, 6);\n        _validate(_stableSwapFeeBasisPoints <= MAX_FEE_BASIS_POINTS, 7);\n        _validate(_marginFeeBasisPoints <= MAX_FEE_BASIS_POINTS, 8);\n        _validate(_liquidationFeeUsd <= MAX_LIQUIDATION_FEE_USD, 9);\n        taxBasisPoints = _taxBasisPoints;\n        stableTaxBasisPoints = _stableTaxBasisPoints;\n        mintBurnFeeBasisPoints = _mintBurnFeeBasisPoints;\n        swapFeeBasisPoints = _swapFeeBasisPoints;\n        stableSwapFeeBasisPoints = _stableSwapFeeBasisPoints;\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        liquidationFeeUsd = _liquidationFeeUsd;\n        minProfitTime = _minProfitTime;\n        hasDynamicFees = _hasDynamicFees;\n    }\n\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external override {\n        _onlyGov();\n        _validate(_fundingInterval >= MIN_FUNDING_RATE_INTERVAL, 10);\n        _validate(_fundingRateFactor <= MAX_FUNDING_RATE_FACTOR, 11);\n        _validate(_stableFundingRateFactor <= MAX_FUNDING_RATE_FACTOR, 12);\n        fundingInterval = _fundingInterval;\n        fundingRateFactor = _fundingRateFactor;\n        stableFundingRateFactor = _stableFundingRateFactor;\n    }\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _tokenWeight,\n        uint256 _minProfitBps,\n        uint256 _maxUsdgAmount,\n        bool _isStable,\n        bool _isShortable\n    ) external override {\n        _onlyGov();\n        // increment token count for the first time\n        if (!whitelistedTokens[_token]) {\n            whitelistedTokenCount = whitelistedTokenCount.add(1);\n            allWhitelistedTokens.push(_token);\n        }\n\n        uint256 _totalTokenWeights = totalTokenWeights;\n        _totalTokenWeights = _totalTokenWeights.sub(tokenWeights[_token]);\n\n        whitelistedTokens[_token] = true;\n        tokenDecimals[_token] = _tokenDecimals;\n        tokenWeights[_token] = _tokenWeight;\n        minProfitBasisPoints[_token] = _minProfitBps;\n        maxUsdgAmounts[_token] = _maxUsdgAmount;\n        stableTokens[_token] = _isStable;\n        shortableTokens[_token] = _isShortable;\n\n        totalTokenWeights = _totalTokenWeights.add(_tokenWeight);\n\n        // validate price feed\n        getMaxPrice(_token);\n    }\n\n    function clearTokenConfig(address _token) external {\n        _onlyGov();\n        _validate(whitelistedTokens[_token], 13);\n        totalTokenWeights = totalTokenWeights.sub(tokenWeights[_token]);\n        delete whitelistedTokens[_token];\n        delete tokenDecimals[_token];\n        delete tokenWeights[_token];\n        delete minProfitBasisPoints[_token];\n        delete maxUsdgAmounts[_token];\n        delete stableTokens[_token];\n        delete shortableTokens[_token];\n        whitelistedTokenCount = whitelistedTokenCount.sub(1);\n    }\n\n    function withdrawFees(address _token, address _receiver) external override returns (uint256) {\n        _onlyGov();\n        uint256 amount = feeReserves[_token];\n        if(amount == 0) { return 0; }\n        feeReserves[_token] = 0;\n        _transferOut(_token, amount, _receiver);\n        return amount;\n    }\n\n    function addRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = true;\n    }\n\n    function removeRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = false;\n    }\n\n    function setUsdgAmount(address _token, uint256 _amount) external override {\n        _onlyGov();\n\n        uint256 usdgAmount = usdgAmounts[_token];\n        if (_amount > usdgAmount) {\n            _increaseUsdgAmount(_token, _amount.sub(usdgAmount));\n            return;\n        }\n\n        _decreaseUsdgAmount(_token, usdgAmount.sub(_amount));\n    }\n\n    // the governance controlling this function should have a timelock\n    function upgradeVault(address _newVault, address _token, uint256 _amount) external {\n        _onlyGov();\n        IERC20(_token).safeTransfer(_newVault, _amount);\n    }\n\n    // deposit into the pool without minting USDG tokens\n    // useful in allowing the pool to become over-collaterised\n    function directPoolDeposit(address _token) external override nonReentrant {\n        _validate(whitelistedTokens[_token], 14);\n        uint256 tokenAmount = _transferIn(_token);\n        _validate(tokenAmount > 0, 15);\n        _increasePoolAmount(_token, tokenAmount);\n        emit DirectPoolDeposit(_token, tokenAmount);\n    }\n\n    function buyUSDG(address _token, address _receiver) external override nonReentrant returns (uint256) {\n        _validateManager();\n        _validate(whitelistedTokens[_token], 16);\n        useSwapPricing = true;\n\n        uint256 tokenAmount = _transferIn(_token);\n        _validate(tokenAmount > 0, 17);\n\n        updateCumulativeFundingRate(_token, _token);\n\n        uint256 price = getMinPrice(_token);\n\n        uint256 usdgAmount = tokenAmount.mul(price).div(PRICE_PRECISION);\n        usdgAmount = adjustForDecimals(usdgAmount, _token, usdg);\n        _validate(usdgAmount > 0, 18);\n\n        uint256 feeBasisPoints = vaultUtils.getBuyUsdgFeeBasisPoints(_token, usdgAmount);\n        uint256 amountAfterFees = _collectSwapFees(_token, tokenAmount, feeBasisPoints);\n        uint256 mintAmount = amountAfterFees.mul(price).div(PRICE_PRECISION);\n        mintAmount = adjustForDecimals(mintAmount, _token, usdg);\n\n        _increaseUsdgAmount(_token, mintAmount);\n        _increasePoolAmount(_token, amountAfterFees);\n\n        IUSDG(usdg).mint(_receiver, mintAmount);\n\n        emit BuyUSDG(_receiver, _token, tokenAmount, mintAmount, feeBasisPoints);\n\n        useSwapPricing = false;\n        return mintAmount;\n    }\n\n    function sellUSDG(address _token, address _receiver) external override nonReentrant returns (uint256) {\n        _validateManager();\n        _validate(whitelistedTokens[_token], 19);\n        useSwapPricing = true;\n\n        uint256 usdgAmount = _transferIn(usdg);\n        _validate(usdgAmount > 0, 20);\n\n        updateCumulativeFundingRate(_token, _token);\n\n        uint256 redemptionAmount = getRedemptionAmount(_token, usdgAmount);\n        _validate(redemptionAmount > 0, 21);\n\n        _decreaseUsdgAmount(_token, usdgAmount);\n        _decreasePoolAmount(_token, redemptionAmount);\n\n        IUSDG(usdg).burn(address(this), usdgAmount);\n\n        // the _transferIn call increased the value of tokenBalances[usdg]\n        // usually decreases in token balances are synced by calling _transferOut\n        // however, for usdg, the tokens are burnt, so _updateTokenBalance should\n        // be manually called to record the decrease in tokens\n        _updateTokenBalance(usdg);\n\n        uint256 feeBasisPoints = vaultUtils.getSellUsdgFeeBasisPoints(_token, usdgAmount);\n        uint256 amountOut = _collectSwapFees(_token, redemptionAmount, feeBasisPoints);\n        _validate(amountOut > 0, 22);\n\n        _transferOut(_token, amountOut, _receiver);\n\n        emit SellUSDG(_receiver, _token, usdgAmount, amountOut, feeBasisPoints);\n\n        useSwapPricing = false;\n        return amountOut;\n    }\n\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external override nonReentrant returns (uint256) {\n        _validate(isSwapEnabled, 23);\n        _validate(whitelistedTokens[_tokenIn], 24);\n        _validate(whitelistedTokens[_tokenOut], 25);\n        _validate(_tokenIn != _tokenOut, 26);\n\n        useSwapPricing = true;\n\n        updateCumulativeFundingRate(_tokenIn, _tokenIn);\n        updateCumulativeFundingRate(_tokenOut, _tokenOut);\n\n        uint256 amountIn = _transferIn(_tokenIn);\n        _validate(amountIn > 0, 27);\n\n        uint256 priceIn = getMinPrice(_tokenIn);\n        uint256 priceOut = getMaxPrice(_tokenOut);\n\n        uint256 amountOut = amountIn.mul(priceIn).div(priceOut);\n        amountOut = adjustForDecimals(amountOut, _tokenIn, _tokenOut);\n\n        // adjust usdgAmounts by the same usdgAmount as debt is shifted between the assets\n        uint256 usdgAmount = amountIn.mul(priceIn).div(PRICE_PRECISION);\n        usdgAmount = adjustForDecimals(usdgAmount, _tokenIn, usdg);\n\n        uint256 feeBasisPoints = vaultUtils.getSwapFeeBasisPoints(_tokenIn, _tokenOut, usdgAmount);\n        uint256 amountOutAfterFees = _collectSwapFees(_tokenOut, amountOut, feeBasisPoints);\n\n        _increaseUsdgAmount(_tokenIn, usdgAmount);\n        _decreaseUsdgAmount(_tokenOut, usdgAmount);\n\n        _increasePoolAmount(_tokenIn, amountIn);\n        _decreasePoolAmount(_tokenOut, amountOut);\n\n        _validateBufferAmount(_tokenOut);\n\n        _transferOut(_tokenOut, amountOutAfterFees, _receiver);\n\n        emit Swap(_receiver, _tokenIn, _tokenOut, amountIn, amountOut, amountOutAfterFees, feeBasisPoints);\n\n        useSwapPricing = false;\n        return amountOutAfterFees;\n    }\n\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external override nonReentrant {\n        _validate(isLeverageEnabled, 28);\n        _validateGasPrice();\n        _validateRouter(_account);\n        _validateTokens(_collateralToken, _indexToken, _isLong);\n        vaultUtils.validateIncreasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        Position storage position = positions[key];\n\n        uint256 price = _isLong ? getMaxPrice(_indexToken) : getMinPrice(_indexToken);\n\n        if (position.size == 0) {\n            position.averagePrice = price;\n        }\n\n        if (position.size > 0 && _sizeDelta > 0) {\n            position.averagePrice = getNextAveragePrice(_indexToken, position.size, position.averagePrice, _isLong, price, _sizeDelta, position.lastIncreasedTime);\n        }\n\n        uint256 fee = _collectMarginFees(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, position.size, position.entryFundingRate);\n        uint256 collateralDelta = _transferIn(_collateralToken);\n        uint256 collateralDeltaUsd = tokenToUsdMin(_collateralToken, collateralDelta);\n\n        position.collateral = position.collateral.add(collateralDeltaUsd);\n        _validate(position.collateral >= fee, 29);\n\n        position.collateral = position.collateral.sub(fee);\n        position.entryFundingRate = getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n        position.size = position.size.add(_sizeDelta);\n        position.lastIncreasedTime = block.timestamp;\n\n        _validate(position.size > 0, 30);\n        _validatePosition(position.size, position.collateral);\n        validateLiquidation(_account, _collateralToken, _indexToken, _isLong, true);\n\n        // reserve tokens to pay profits on the position\n        uint256 reserveDelta = usdToTokenMax(_collateralToken, _sizeDelta);\n        position.reserveAmount = position.reserveAmount.add(reserveDelta);\n        _increaseReservedAmount(_collateralToken, reserveDelta);\n\n        if (_isLong) {\n            // guaranteedUsd stores the sum of (position.size - position.collateral) for all positions\n            // if a fee is charged on the collateral then guaranteedUsd should be increased by that fee amount\n            // since (position.size - position.collateral) would have increased by `fee`\n            _increaseGuaranteedUsd(_collateralToken, _sizeDelta.add(fee));\n            _decreaseGuaranteedUsd(_collateralToken, collateralDeltaUsd);\n            // treat the deposited collateral as part of the pool\n            _increasePoolAmount(_collateralToken, collateralDelta);\n            // fees need to be deducted from the pool since fees are deducted from position.collateral\n            // and collateral is treated as part of the pool\n            _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, fee));\n        } else {\n            if (globalShortSizes[_indexToken] == 0) {\n                globalShortAveragePrices[_indexToken] = price;\n            } else {\n                globalShortAveragePrices[_indexToken] = getNextGlobalShortAveragePrice(_indexToken, price, _sizeDelta);\n            }\n\n            _increaseGlobalShortSize(_indexToken, _sizeDelta);\n        }\n\n        emit IncreasePosition(key, _account, _collateralToken, _indexToken, collateralDeltaUsd, _sizeDelta, _isLong, price, fee);\n        emit UpdatePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl, price);\n    }\n\n    function decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external override nonReentrant returns (uint256) {\n        _validateGasPrice();\n        _validateRouter(_account);\n        return _decreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n\n    function _decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) private returns (uint256) {\n        vaultUtils.validateDecreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        Position storage position = positions[key];\n        _validate(position.size > 0, 31);\n        _validate(position.size >= _sizeDelta, 32);\n        _validate(position.collateral >= _collateralDelta, 33);\n\n        uint256 collateral = position.collateral;\n        // scrop variables to avoid stack too deep errors\n        {\n        uint256 reserveDelta = position.reserveAmount.mul(_sizeDelta).div(position.size);\n        position.reserveAmount = position.reserveAmount.sub(reserveDelta);\n        _decreaseReservedAmount(_collateralToken, reserveDelta);\n        }\n\n        (uint256 usdOut, uint256 usdOutAfterFee) = _reduceCollateral(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong);\n\n        if (position.size != _sizeDelta) {\n            position.entryFundingRate = getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n            position.size = position.size.sub(_sizeDelta);\n\n            _validatePosition(position.size, position.collateral);\n            validateLiquidation(_account, _collateralToken, _indexToken, _isLong, true);\n\n            if (_isLong) {\n                _increaseGuaranteedUsd(_collateralToken, collateral.sub(position.collateral));\n                _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n            }\n\n            uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n            emit DecreasePosition(key, _account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, price, usdOut.sub(usdOutAfterFee));\n            emit UpdatePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl, price);\n        } else {\n            if (_isLong) {\n                _increaseGuaranteedUsd(_collateralToken, collateral);\n                _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n            }\n\n            uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n            emit DecreasePosition(key, _account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, price, usdOut.sub(usdOutAfterFee));\n            emit ClosePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl);\n\n            delete positions[key];\n        }\n\n        if (!_isLong) {\n            _decreaseGlobalShortSize(_indexToken, _sizeDelta);\n        }\n\n        if (usdOut > 0) {\n            if (_isLong) {\n                _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, usdOut));\n            }\n            uint256 amountOutAfterFees = usdToTokenMin(_collateralToken, usdOutAfterFee);\n            _transferOut(_collateralToken, amountOutAfterFees, _receiver);\n            return amountOutAfterFees;\n        }\n\n        return 0;\n    }\n\n    function liquidatePosition(address _account, address _collateralToken, address _indexToken, bool _isLong, address _feeReceiver) external override nonReentrant {\n        if (inPrivateLiquidationMode) {\n            _validate(isLiquidator[msg.sender], 34);\n        }\n\n        // set includeAmmPrice to false to prevent manipulated liquidations\n        includeAmmPrice = false;\n\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        Position memory position = positions[key];\n        _validate(position.size > 0, 35);\n\n        (uint256 liquidationState, uint256 marginFees) = validateLiquidation(_account, _collateralToken, _indexToken, _isLong, false);\n        _validate(liquidationState != 0, 36);\n        if (liquidationState == 2) {\n            // max leverage exceeded but there is collateral remaining after deducting losses so decreasePosition instead\n            _decreasePosition(_account, _collateralToken, _indexToken, 0, position.size, _isLong, _account);\n            includeAmmPrice = true;\n            return;\n        }\n\n        uint256 feeTokens = usdToTokenMin(_collateralToken, marginFees);\n        feeReserves[_collateralToken] = feeReserves[_collateralToken].add(feeTokens);\n        emit CollectMarginFees(_collateralToken, marginFees, feeTokens);\n\n        _decreaseReservedAmount(_collateralToken, position.reserveAmount);\n        if (_isLong) {\n            _decreaseGuaranteedUsd(_collateralToken, position.size.sub(position.collateral));\n            _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, marginFees));\n        }\n\n        uint256 markPrice = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n        emit LiquidatePosition(key, _account, _collateralToken, _indexToken, _isLong, position.size, position.collateral, position.reserveAmount, position.realisedPnl, markPrice);\n\n        if (!_isLong && marginFees < position.collateral) {\n            uint256 remainingCollateral = position.collateral.sub(marginFees);\n            _increasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, remainingCollateral));\n        }\n\n        if (!_isLong) {\n            _decreaseGlobalShortSize(_indexToken, position.size);\n        }\n\n        delete positions[key];\n\n        // pay the fee receiver using the pool, we assume that in general the liquidated amount should be sufficient to cover\n        // the liquidation fees\n        _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, liquidationFeeUsd));\n        _transferOut(_collateralToken, usdToTokenMin(_collateralToken, liquidationFeeUsd), _feeReceiver);\n\n        includeAmmPrice = true;\n    }\n\n    // validateLiquidation returns (state, fees)\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) public view returns (uint256, uint256) {\n        return vaultUtils.validateLiquidation(_account, _collateralToken, _indexToken, _isLong, _raise);\n    }\n\n    function getMaxPrice(address _token) public override view returns (uint256) {\n        return IVaultPriceFeed(priceFeed).getPrice(_token, true, includeAmmPrice, useSwapPricing);\n    }\n\n    function getMinPrice(address _token) public override view returns (uint256) {\n        return IVaultPriceFeed(priceFeed).getPrice(_token, false, includeAmmPrice, useSwapPricing);\n    }\n\n    function getRedemptionAmount(address _token, uint256 _usdgAmount) public override view returns (uint256) {\n        uint256 price = getMaxPrice(_token);\n        uint256 redemptionAmount = _usdgAmount.mul(PRICE_PRECISION).div(price);\n        return adjustForDecimals(redemptionAmount, usdg, _token);\n    }\n\n    function getRedemptionCollateral(address _token) public view returns (uint256) {\n        if (stableTokens[_token]) {\n            return poolAmounts[_token];\n        }\n        uint256 collateral = usdToTokenMin(_token, guaranteedUsd[_token]);\n        return collateral.add(poolAmounts[_token]).sub(reservedAmounts[_token]);\n    }\n\n    function getRedemptionCollateralUsd(address _token) public view returns (uint256) {\n        return tokenToUsdMin(_token, getRedemptionCollateral(_token));\n    }\n\n    function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) public view returns (uint256) {\n        uint256 decimalsDiv = _tokenDiv == usdg ? USDG_DECIMALS : tokenDecimals[_tokenDiv];\n        uint256 decimalsMul = _tokenMul == usdg ? USDG_DECIMALS : tokenDecimals[_tokenMul];\n        return _amount.mul(10 ** decimalsMul).div(10 ** decimalsDiv);\n    }\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) public override view returns (uint256) {\n        if (_tokenAmount == 0) { return 0; }\n        uint256 price = getMinPrice(_token);\n        uint256 decimals = tokenDecimals[_token];\n        return _tokenAmount.mul(price).div(10 ** decimals);\n    }\n\n    function usdToTokenMax(address _token, uint256 _usdAmount) public view returns (uint256) {\n        if (_usdAmount == 0) { return 0; }\n        return usdToToken(_token, _usdAmount, getMinPrice(_token));\n    }\n\n    function usdToTokenMin(address _token, uint256 _usdAmount) public view returns (uint256) {\n        if (_usdAmount == 0) { return 0; }\n        return usdToToken(_token, _usdAmount, getMaxPrice(_token));\n    }\n\n    function usdToToken(address _token, uint256 _usdAmount, uint256 _price) public view returns (uint256) {\n        if (_usdAmount == 0) { return 0; }\n        uint256 decimals = tokenDecimals[_token];\n        return _usdAmount.mul(10 ** decimals).div(_price);\n    }\n\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) public override view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        Position memory position = positions[key];\n        uint256 realisedPnl = position.realisedPnl > 0 ? uint256(position.realisedPnl) : uint256(-position.realisedPnl);\n        return (\n            position.size, // 0\n            position.collateral, // 1\n            position.averagePrice, // 2\n            position.entryFundingRate, // 3\n            position.reserveAmount, // 4\n            realisedPnl, // 5\n            position.realisedPnl >= 0, // 6\n            position.lastIncreasedTime // 7\n        );\n    }\n\n    function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        ));\n    }\n\n    function updateCumulativeFundingRate(address _collateralToken, address _indexToken) public {\n        bool shouldUpdate = vaultUtils.updateCumulativeFundingRate(_collateralToken, _indexToken);\n        if (!shouldUpdate) {\n            return;\n        }\n\n        if (lastFundingTimes[_collateralToken] == 0) {\n            lastFundingTimes[_collateralToken] = block.timestamp.div(fundingInterval).mul(fundingInterval);\n            return;\n        }\n\n        if (lastFundingTimes[_collateralToken].add(fundingInterval) > block.timestamp) {\n            return;\n        }\n\n        uint256 fundingRate = getNextFundingRate(_collateralToken);\n        cumulativeFundingRates[_collateralToken] = cumulativeFundingRates[_collateralToken].add(fundingRate);\n        lastFundingTimes[_collateralToken] = block.timestamp.div(fundingInterval).mul(fundingInterval);\n\n        emit UpdateFundingRate(_collateralToken, cumulativeFundingRates[_collateralToken]);\n    }\n\n    function getNextFundingRate(address _token) public override view returns (uint256) {\n        if (lastFundingTimes[_token].add(fundingInterval) > block.timestamp) { return 0; }\n\n        uint256 intervals = block.timestamp.sub(lastFundingTimes[_token]).div(fundingInterval);\n        uint256 poolAmount = poolAmounts[_token];\n        if (poolAmount == 0) { return 0; }\n\n        uint256 _fundingRateFactor = stableTokens[_token] ? stableFundingRateFactor : fundingRateFactor;\n        return _fundingRateFactor.mul(reservedAmounts[_token]).mul(intervals).div(poolAmount);\n    }\n\n    function getUtilisation(address _token) public view returns (uint256) {\n        uint256 poolAmount = poolAmounts[_token];\n        if (poolAmount == 0) { return 0; }\n\n        return reservedAmounts[_token].mul(FUNDING_RATE_PRECISION).div(poolAmount);\n    }\n\n    function getPositionLeverage(address _account, address _collateralToken, address _indexToken, bool _isLong) public view returns (uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        Position memory position = positions[key];\n        _validate(position.collateral > 0, 37);\n        return position.size.mul(BASIS_POINTS_DIVISOR).div(position.collateral);\n    }\n\n    // for longs: nextAveragePrice = (nextPrice * nextSize)/ (nextSize + delta)\n    // for shorts: nextAveragePrice = (nextPrice * nextSize) / (nextSize - delta)\n    function getNextAveragePrice(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _nextPrice, uint256 _sizeDelta, uint256 _lastIncreasedTime) public view returns (uint256) {\n        (bool hasProfit, uint256 delta) = getDelta(_indexToken, _size, _averagePrice, _isLong, _lastIncreasedTime);\n        uint256 nextSize = _size.add(_sizeDelta);\n        uint256 divisor;\n        if (_isLong) {\n            divisor = hasProfit ? nextSize.add(delta) : nextSize.sub(delta);\n        } else {\n            divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n        }\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n\n    // for longs: nextAveragePrice = (nextPrice * nextSize)/ (nextSize + delta)\n    // for shorts: nextAveragePrice = (nextPrice * nextSize) / (nextSize - delta)\n    function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) public view returns (uint256) {\n        uint256 size = globalShortSizes[_indexToken];\n        uint256 averagePrice = globalShortAveragePrices[_indexToken];\n        uint256 priceDelta = averagePrice > _nextPrice ? averagePrice.sub(_nextPrice) : _nextPrice.sub(averagePrice);\n        uint256 delta = size.mul(priceDelta).div(averagePrice);\n        bool hasProfit = averagePrice > _nextPrice;\n\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n\n    function getGlobalShortDelta(address _token) public view returns (bool, uint256) {\n        uint256 size = globalShortSizes[_token];\n        if (size == 0) { return (false, 0); }\n\n        uint256 nextPrice = getMaxPrice(_token);\n        uint256 averagePrice = globalShortAveragePrices[_token];\n        uint256 priceDelta = averagePrice > nextPrice ? averagePrice.sub(nextPrice) : nextPrice.sub(averagePrice);\n        uint256 delta = size.mul(priceDelta).div(averagePrice);\n        bool hasProfit = averagePrice > nextPrice;\n\n        return (hasProfit, delta);\n    }\n\n    function getPositionDelta(address _account, address _collateralToken, address _indexToken, bool _isLong) public view returns (bool, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        Position memory position = positions[key];\n        return getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n    }\n\n    function getDelta(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _lastIncreasedTime) public override view returns (bool, uint256) {\n        _validate(_averagePrice > 0, 38);\n        uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n        uint256 priceDelta = _averagePrice > price ? _averagePrice.sub(price) : price.sub(_averagePrice);\n        uint256 delta = _size.mul(priceDelta).div(_averagePrice);\n\n        bool hasProfit;\n\n        if (_isLong) {\n            hasProfit = price > _averagePrice;\n        } else {\n            hasProfit = _averagePrice > price;\n        }\n\n        // if the minProfitTime has passed then there will be no min profit threshold\n        // the min profit threshold helps to prevent front-running issues\n        uint256 minBps = block.timestamp > _lastIncreasedTime.add(minProfitTime) ? 0 : minProfitBasisPoints[_indexToken];\n        if (hasProfit && delta.mul(BASIS_POINTS_DIVISOR) <= _size.mul(minBps)) {\n            delta = 0;\n        }\n\n        return (hasProfit, delta);\n    }\n\n    function getEntryFundingRate(address _collateralToken, address _indexToken, bool _isLong) public view returns (uint256) {\n        return vaultUtils.getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n    }\n\n    function getFundingFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _size, uint256 _entryFundingRate) public view returns (uint256) {\n        return vaultUtils.getFundingFee(_account, _collateralToken, _indexToken, _isLong, _size, _entryFundingRate);\n    }\n\n    function getPositionFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta) public view returns (uint256) {\n        return vaultUtils.getPositionFee(_account, _collateralToken, _indexToken, _isLong, _sizeDelta);\n    }\n\n    // cases to consider\n    // 1. initialAmount is far from targetAmount, action increases balance slightly => high rebate\n    // 2. initialAmount is far from targetAmount, action increases balance largely => high rebate\n    // 3. initialAmount is close to targetAmount, action increases balance slightly => low rebate\n    // 4. initialAmount is far from targetAmount, action reduces balance slightly => high tax\n    // 5. initialAmount is far from targetAmount, action reduces balance largely => high tax\n    // 6. initialAmount is close to targetAmount, action reduces balance largely => low tax\n    // 7. initialAmount is above targetAmount, nextAmount is below targetAmount and vice versa\n    // 8. a large swap should have similar fees as the same trade split into multiple smaller swaps\n    function getFeeBasisPoints(address _token, uint256 _usdgDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) public override view returns (uint256) {\n        return vaultUtils.getFeeBasisPoints(_token, _usdgDelta, _feeBasisPoints, _taxBasisPoints, _increment);\n    }\n\n    function getTargetUsdgAmount(address _token) public override view returns (uint256) {\n        uint256 supply = IERC20(usdg).totalSupply();\n        if (supply == 0) { return 0; }\n        uint256 weight = tokenWeights[_token];\n        return weight.mul(supply).div(totalTokenWeights);\n    }\n\n    function _reduceCollateral(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong) private returns (uint256, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        Position storage position = positions[key];\n\n        uint256 fee = _collectMarginFees(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, position.size, position.entryFundingRate);\n        bool hasProfit;\n        uint256 adjustedDelta;\n\n        // scope variables to avoid stack too deep errors\n        {\n        (bool _hasProfit, uint256 delta) = getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n        hasProfit = _hasProfit;\n        // get the proportional change in pnl\n        adjustedDelta = _sizeDelta.mul(delta).div(position.size);\n        }\n\n        uint256 usdOut;\n        // transfer profits out\n        if (hasProfit && adjustedDelta > 0) {\n            usdOut = adjustedDelta;\n            position.realisedPnl = position.realisedPnl + int256(adjustedDelta);\n\n            // pay out realised profits from the pool amount for short positions\n            if (!_isLong) {\n                uint256 tokenAmount = usdToTokenMin(_collateralToken, adjustedDelta);\n                _decreasePoolAmount(_collateralToken, tokenAmount);\n            }\n        }\n\n        if (!hasProfit && adjustedDelta > 0) {\n            position.collateral = position.collateral.sub(adjustedDelta);\n\n            // transfer realised losses to the pool for short positions\n            // realised losses for long positions are not transferred here as\n            // _increasePoolAmount was already called in increasePosition for longs\n            if (!_isLong) {\n                uint256 tokenAmount = usdToTokenMin(_collateralToken, adjustedDelta);\n                _increasePoolAmount(_collateralToken, tokenAmount);\n            }\n\n            position.realisedPnl = position.realisedPnl - int256(adjustedDelta);\n        }\n\n        // reduce the position's collateral by _collateralDelta\n        // transfer _collateralDelta out\n        if (_collateralDelta > 0) {\n            usdOut = usdOut.add(_collateralDelta);\n            position.collateral = position.collateral.sub(_collateralDelta);\n        }\n\n        // if the position will be closed, then transfer the remaining collateral out\n        if (position.size == _sizeDelta) {\n            usdOut = usdOut.add(position.collateral);\n            position.collateral = 0;\n        }\n\n        // if the usdOut is more than the fee then deduct the fee from the usdOut directly\n        // else deduct the fee from the position's collateral\n        uint256 usdOutAfterFee = usdOut;\n        if (usdOut > fee) {\n            usdOutAfterFee = usdOut.sub(fee);\n        } else {\n            position.collateral = position.collateral.sub(fee);\n            if (_isLong) {\n                uint256 feeTokens = usdToTokenMin(_collateralToken, fee);\n                _decreasePoolAmount(_collateralToken, feeTokens);\n            }\n        }\n\n        emit UpdatePnl(key, hasProfit, adjustedDelta);\n\n        return (usdOut, usdOutAfterFee);\n    }\n\n    function _validatePosition(uint256 _size, uint256 _collateral) private view {\n        if (_size == 0) {\n            _validate(_collateral == 0, 39);\n            return;\n        }\n        _validate(_size >= _collateral, 40);\n    }\n\n    function _validateRouter(address _account) private view {\n        if (msg.sender == _account) { return; }\n        if (msg.sender == router) { return; }\n        _validate(approvedRouters[_account][msg.sender], 41);\n    }\n\n    function _validateTokens(address _collateralToken, address _indexToken, bool _isLong) private view {\n        if (_isLong) {\n            _validate(_collateralToken == _indexToken, 42);\n            _validate(whitelistedTokens[_collateralToken], 43);\n            _validate(!stableTokens[_collateralToken], 44);\n            return;\n        }\n\n        _validate(whitelistedTokens[_collateralToken], 45);\n        _validate(stableTokens[_collateralToken], 46);\n        _validate(!stableTokens[_indexToken], 47);\n        _validate(shortableTokens[_indexToken], 48);\n    }\n\n    function _collectSwapFees(address _token, uint256 _amount, uint256 _feeBasisPoints) private returns (uint256) {\n        uint256 afterFeeAmount = _amount.mul(BASIS_POINTS_DIVISOR.sub(_feeBasisPoints)).div(BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = _amount.sub(afterFeeAmount);\n        feeReserves[_token] = feeReserves[_token].add(feeAmount);\n        emit CollectSwapFees(_token, tokenToUsdMin(_token, feeAmount), feeAmount);\n        return afterFeeAmount;\n    }\n\n    function _collectMarginFees(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta, uint256 _size, uint256 _entryFundingRate) private returns (uint256) {\n        uint256 feeUsd = getPositionFee(_account, _collateralToken, _indexToken, _isLong, _sizeDelta);\n\n        uint256 fundingFee = getFundingFee(_account, _collateralToken, _indexToken, _isLong, _size, _entryFundingRate);\n        feeUsd = feeUsd.add(fundingFee);\n\n        uint256 feeTokens = usdToTokenMin(_collateralToken, feeUsd);\n        feeReserves[_collateralToken] = feeReserves[_collateralToken].add(feeTokens);\n\n        emit CollectMarginFees(_collateralToken, feeUsd, feeTokens);\n        return feeUsd;\n    }\n\n    function _transferIn(address _token) private returns (uint256) {\n        uint256 prevBalance = tokenBalances[_token];\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n\n        return nextBalance.sub(prevBalance);\n    }\n\n    function _transferOut(address _token, uint256 _amount, address _receiver) private {\n        IERC20(_token).safeTransfer(_receiver, _amount);\n        tokenBalances[_token] = IERC20(_token).balanceOf(address(this));\n    }\n\n    function _updateTokenBalance(address _token) private {\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n    }\n\n    function _increasePoolAmount(address _token, uint256 _amount) private {\n        poolAmounts[_token] = poolAmounts[_token].add(_amount);\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _validate(poolAmounts[_token] <= balance, 49);\n        emit IncreasePoolAmount(_token, _amount);\n    }\n\n    function _decreasePoolAmount(address _token, uint256 _amount) private {\n        poolAmounts[_token] = poolAmounts[_token].sub(_amount, \"Vault: poolAmount exceeded\");\n        _validate(reservedAmounts[_token] <= poolAmounts[_token], 50);\n        emit DecreasePoolAmount(_token, _amount);\n    }\n\n    function _validateBufferAmount(address _token) private view {\n        if (poolAmounts[_token] < bufferAmounts[_token]) {\n            revert(\"Vault: poolAmount < buffer\");\n        }\n    }\n\n    function _increaseUsdgAmount(address _token, uint256 _amount) private {\n        usdgAmounts[_token] = usdgAmounts[_token].add(_amount);\n        uint256 maxUsdgAmount = maxUsdgAmounts[_token];\n        if (maxUsdgAmount != 0) {\n            _validate(usdgAmounts[_token] <= maxUsdgAmount, 51);\n        }\n        emit IncreaseUsdgAmount(_token, _amount);\n    }\n\n    function _decreaseUsdgAmount(address _token, uint256 _amount) private {\n        uint256 value = usdgAmounts[_token];\n        // since USDG can be minted using multiple assets\n        // it is possible for the USDG debt for a single asset to be less than zero\n        // the USDG debt is capped to zero for this case\n        if (value <= _amount) {\n            usdgAmounts[_token] = 0;\n            emit DecreaseUsdgAmount(_token, value);\n            return;\n        }\n        usdgAmounts[_token] = value.sub(_amount);\n        emit DecreaseUsdgAmount(_token, _amount);\n    }\n\n    function _increaseReservedAmount(address _token, uint256 _amount) private {\n        reservedAmounts[_token] = reservedAmounts[_token].add(_amount);\n        _validate(reservedAmounts[_token] <= poolAmounts[_token], 52);\n        emit IncreaseReservedAmount(_token, _amount);\n    }\n\n    function _decreaseReservedAmount(address _token, uint256 _amount) private {\n        reservedAmounts[_token] = reservedAmounts[_token].sub(_amount, \"Vault: insufficient reserve\");\n        emit DecreaseReservedAmount(_token, _amount);\n    }\n\n    function _increaseGuaranteedUsd(address _token, uint256 _usdAmount) private {\n        guaranteedUsd[_token] = guaranteedUsd[_token].add(_usdAmount);\n        emit IncreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    function _decreaseGuaranteedUsd(address _token, uint256 _usdAmount) private {\n        guaranteedUsd[_token] = guaranteedUsd[_token].sub(_usdAmount);\n        emit DecreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    function _increaseGlobalShortSize(address _token, uint256 _amount) private {\n        globalShortSizes[_token] = globalShortSizes[_token].add(_amount);\n\n        uint256 maxSize = maxGlobalShortSizes[_token];\n        if (maxSize != 0) {\n            require(globalShortSizes[_token] <= maxSize, \"Vault: max shorts exceeded\");\n        }\n    }\n\n    function _decreaseGlobalShortSize(address _token, uint256 _amount) private {\n        uint256 size = globalShortSizes[_token];\n        if (_amount > size) {\n          globalShortSizes[_token] = 0;\n          return;\n        }\n\n        globalShortSizes[_token] = size.sub(_amount);\n    }\n\n    // we have this validation as a function instead of a modifier to reduce contract size\n    function _onlyGov() private view {\n        _validate(msg.sender == gov, 53);\n    }\n\n    // we have this validation as a function instead of a modifier to reduce contract size\n    function _validateManager() private view {\n        if (inManagerMode) {\n            _validate(isManager[msg.sender], 54);\n        }\n    }\n\n    // we have this validation as a function instead of a modifier to reduce contract size\n    function _validateGasPrice() private view {\n        if (maxGasPrice == 0) { return; }\n        _validate(tx.gasprice <= maxGasPrice, 55);\n    }\n\n    function _validate(bool _condition, uint256 _errorCode) private view {\n        require(_condition, errors[_errorCode]);\n    }\n}\n"
    },
    "contracts/core/VaultUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IVaultUtils.sol\";\n\nimport \"../access/Governable.sol\";\n\ncontract VaultUtils is IVaultUtils, Governable {\n    using SafeMath for uint256;\n\n    struct Position {\n        uint256 size;\n        uint256 collateral;\n        uint256 averagePrice;\n        uint256 entryFundingRate;\n        uint256 reserveAmount;\n        int256 realisedPnl;\n        uint256 lastIncreasedTime;\n    }\n\n    IVault public vault;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant FUNDING_RATE_PRECISION = 1000000;\n\n    constructor(IVault _vault) public {\n        vault = _vault;\n    }\n\n    function updateCumulativeFundingRate(address /* _collateralToken */, address /* _indexToken */) public override returns (bool) {\n        return true;\n    }\n\n    function validateIncreasePosition(address /* _account */, address /* _collateralToken */, address /* _indexToken */, uint256 /* _sizeDelta */, bool /* _isLong */) external override view {\n        // no additional validations\n    }\n\n    function validateDecreasePosition(address /* _account */, address /* _collateralToken */, address /* _indexToken */ , uint256 /* _collateralDelta */, uint256 /* _sizeDelta */, bool /* _isLong */, address /* _receiver */) external override view {\n        // no additional validations\n    }\n\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) internal view returns (Position memory) {\n        IVault _vault = vault;\n        Position memory position;\n        {\n            (uint256 size, uint256 collateral, uint256 averagePrice, uint256 entryFundingRate, /* reserveAmount */, /* realisedPnl */, /* hasProfit */, uint256 lastIncreasedTime) = _vault.getPosition(_account, _collateralToken, _indexToken, _isLong);\n            position.size = size;\n            position.collateral = collateral;\n            position.averagePrice = averagePrice;\n            position.entryFundingRate = entryFundingRate;\n            position.lastIncreasedTime = lastIncreasedTime;\n        }\n        return position;\n    }\n\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) public view override returns (uint256, uint256) {\n        Position memory position = getPosition(_account, _collateralToken, _indexToken, _isLong);\n        IVault _vault = vault;\n\n        (bool hasProfit, uint256 delta) = _vault.getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n        uint256 marginFees = getFundingFee(_account, _collateralToken, _indexToken, _isLong, position.size, position.entryFundingRate);\n        marginFees = marginFees.add(getPositionFee(_account, _collateralToken, _indexToken, _isLong, position.size));\n\n        if (!hasProfit && position.collateral < delta) {\n            if (_raise) { revert(\"Vault: losses exceed collateral\"); }\n            return (1, marginFees);\n        }\n\n        uint256 remainingCollateral = position.collateral;\n        if (!hasProfit) {\n            remainingCollateral = position.collateral.sub(delta);\n        }\n\n        if (remainingCollateral < marginFees) {\n            if (_raise) { revert(\"Vault: fees exceed collateral\"); }\n            // cap the fees to the remainingCollateral\n            return (1, remainingCollateral);\n        }\n\n        if (remainingCollateral < marginFees.add(_vault.liquidationFeeUsd())) {\n            if (_raise) { revert(\"Vault: liquidation fees exceed collateral\"); }\n            return (1, marginFees);\n        }\n\n        if (remainingCollateral.mul(_vault.maxLeverage()) < position.size.mul(BASIS_POINTS_DIVISOR)) {\n            if (_raise) { revert(\"Vault: maxLeverage exceeded\"); }\n            return (2, marginFees);\n        }\n\n        return (0, marginFees);\n    }\n\n    function getEntryFundingRate(address _collateralToken, address /* _indexToken */, bool /* _isLong */) public override view returns (uint256) {\n        return vault.cumulativeFundingRates(_collateralToken);\n    }\n\n    function getPositionFee(address /* _account */, address /* _collateralToken */, address /* _indexToken */, bool /* _isLong */, uint256 _sizeDelta) public override view returns (uint256) {\n        if (_sizeDelta == 0) { return 0; }\n        uint256 afterFeeUsd = _sizeDelta.mul(BASIS_POINTS_DIVISOR.sub(vault.marginFeeBasisPoints())).div(BASIS_POINTS_DIVISOR);\n        return _sizeDelta.sub(afterFeeUsd);\n    }\n\n    function getFundingFee(address /* _account */, address _collateralToken, address /* _indexToken */, bool /* _isLong */, uint256 _size, uint256 _entryFundingRate) public override view returns (uint256) {\n        if (_size == 0) { return 0; }\n\n        uint256 fundingRate = vault.cumulativeFundingRates(_collateralToken).sub(_entryFundingRate);\n        if (fundingRate == 0) { return 0; }\n\n        return _size.mul(fundingRate).div(FUNDING_RATE_PRECISION);\n    }\n\n    function getBuyUsdgFeeBasisPoints(address _token, uint256 _usdgAmount) public override view returns (uint256) {\n        return getFeeBasisPoints(_token, _usdgAmount, vault.mintBurnFeeBasisPoints(), vault.taxBasisPoints(), true);\n    }\n\n    function getSellUsdgFeeBasisPoints(address _token, uint256 _usdgAmount) public override view returns (uint256) {\n        return getFeeBasisPoints(_token, _usdgAmount, vault.mintBurnFeeBasisPoints(), vault.taxBasisPoints(), false);\n    }\n\n    function getSwapFeeBasisPoints(address _tokenIn, address _tokenOut, uint256 _usdgAmount) public override view returns (uint256) {\n        bool isStableSwap = vault.stableTokens(_tokenIn) && vault.stableTokens(_tokenOut);\n        uint256 baseBps = isStableSwap ? vault.stableSwapFeeBasisPoints() : vault.swapFeeBasisPoints();\n        uint256 taxBps = isStableSwap ? vault.stableTaxBasisPoints() : vault.taxBasisPoints();\n        uint256 feesBasisPoints0 = getFeeBasisPoints(_tokenIn, _usdgAmount, baseBps, taxBps, true);\n        uint256 feesBasisPoints1 = getFeeBasisPoints(_tokenOut, _usdgAmount, baseBps, taxBps, false);\n        // use the higher of the two fee basis points\n        return feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n    }\n\n    // cases to consider\n    // 1. initialAmount is far from targetAmount, action increases balance slightly => high rebate\n    // 2. initialAmount is far from targetAmount, action increases balance largely => high rebate\n    // 3. initialAmount is close to targetAmount, action increases balance slightly => low rebate\n    // 4. initialAmount is far from targetAmount, action reduces balance slightly => high tax\n    // 5. initialAmount is far from targetAmount, action reduces balance largely => high tax\n    // 6. initialAmount is close to targetAmount, action reduces balance largely => low tax\n    // 7. initialAmount is above targetAmount, nextAmount is below targetAmount and vice versa\n    // 8. a large swap should have similar fees as the same trade split into multiple smaller swaps\n    function getFeeBasisPoints(address _token, uint256 _usdgDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) public override view returns (uint256) {\n        if (!vault.hasDynamicFees()) { return _feeBasisPoints; }\n\n        uint256 initialAmount = vault.usdgAmounts(_token);\n        uint256 nextAmount = initialAmount.add(_usdgDelta);\n        if (!_increment) {\n            nextAmount = _usdgDelta > initialAmount ? 0 : initialAmount.sub(_usdgDelta);\n        }\n\n        uint256 targetAmount = vault.getTargetUsdgAmount(_token);\n        if (targetAmount == 0) { return _feeBasisPoints; }\n\n        uint256 initialDiff = initialAmount > targetAmount ? initialAmount.sub(targetAmount) : targetAmount.sub(initialAmount);\n        uint256 nextDiff = nextAmount > targetAmount ? nextAmount.sub(targetAmount) : targetAmount.sub(nextAmount);\n\n        // action improves relative asset balance\n        if (nextDiff < initialDiff) {\n            uint256 rebateBps = _taxBasisPoints.mul(initialDiff).div(targetAmount);\n            return rebateBps > _feeBasisPoints ? 0 : _feeBasisPoints.sub(rebateBps);\n        }\n\n        uint256 averageDiff = initialDiff.add(nextDiff).div(2);\n        if (averageDiff > targetAmount) {\n            averageDiff = targetAmount;\n        }\n        uint256 taxBps = _taxBasisPoints.mul(averageDiff).div(targetAmount);\n        return _feeBasisPoints.add(taxBps);\n    }\n}\n"
    },
    "contracts/peripherals/RewardReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"../staking/interfaces/IVester.sol\";\nimport \"../staking/interfaces/IRewardTracker.sol\";\n\ncontract RewardReader {\n    using SafeMath for uint256;\n\n    function getDepositBalances(address _account, address[] memory _depositTokens, address[] memory _rewardTrackers) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_rewardTrackers.length);\n        for (uint256 i = 0; i < _rewardTrackers.length; i++) {\n            IRewardTracker rewardTracker = IRewardTracker(_rewardTrackers[i]);\n            amounts[i] = rewardTracker.depositBalances(_account, _depositTokens[i]);\n        }\n        return amounts;\n    }\n\n    function getStakingInfo(address _account, address[] memory _rewardTrackers) public view returns (uint256[] memory) {\n        uint256 propsLength = 5;\n        uint256[] memory amounts = new uint256[](_rewardTrackers.length * propsLength);\n        for (uint256 i = 0; i < _rewardTrackers.length; i++) {\n            IRewardTracker rewardTracker = IRewardTracker(_rewardTrackers[i]);\n            amounts[i * propsLength] = rewardTracker.claimable(_account);\n            amounts[i * propsLength + 1] = rewardTracker.tokensPerInterval();\n            amounts[i * propsLength + 2] = rewardTracker.averageStakedAmounts(_account);\n            amounts[i * propsLength + 3] = rewardTracker.cumulativeRewards(_account);\n            amounts[i * propsLength + 4] = IERC20(_rewardTrackers[i]).totalSupply();\n        }\n        return amounts;\n    }\n\n    function getVestingInfoV2(address _account, address[] memory _vesters) public view returns (uint256[] memory) {\n        uint256 propsLength = 12;\n        uint256[] memory amounts = new uint256[](_vesters.length * propsLength);\n        for (uint256 i = 0; i < _vesters.length; i++) {\n            IVester vester = IVester(_vesters[i]);\n            IRewardTracker rewardTracker = IRewardTracker(vester.rewardTracker());\n            amounts[i * propsLength] = vester.pairAmounts(_account);\n            amounts[i * propsLength + 1] = vester.getVestedAmount(_account);\n            amounts[i * propsLength + 2] = IERC20(_vesters[i]).balanceOf(_account);\n            amounts[i * propsLength + 3] = vester.claimedAmounts(_account);\n            amounts[i * propsLength + 4] = vester.claimable(_account);\n            amounts[i * propsLength + 5] = vester.getMaxVestableAmount(_account);\n            amounts[i * propsLength + 6] = vester.getCombinedAverageStakedAmount(_account);\n            amounts[i * propsLength + 7] = rewardTracker.cumulativeRewards(_account);\n            amounts[i * propsLength + 8] = vester.transferredCumulativeRewards(_account);\n            amounts[i * propsLength + 9] = vester.bonusRewards(_account);\n            amounts[i * propsLength + 10] = rewardTracker.averageStakedAmounts(_account);\n            amounts[i * propsLength + 11] = vester.transferredAverageStakedAmounts(_account);\n        }\n        return amounts;\n    }\n}\n"
    },
    "contracts/peripherals/EsXdxBatchSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"../staking/interfaces/IVester.sol\";\nimport \"../staking/interfaces/IRewardTracker.sol\";\n\ncontract EsXdxBatchSender {\n    using SafeMath for uint256;\n\n    address public admin;\n    address public esXdx;\n\n    constructor(address _esXdx) public {\n        admin = msg.sender;\n        esXdx = _esXdx;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"EsXdxBatchSender: forbidden\");\n        _;\n    }\n\n    function send(\n        IVester _vester,\n        uint256 _minRatio,\n        address[] memory _accounts,\n        uint256[] memory _amounts\n    ) external onlyAdmin {\n        IRewardTracker rewardTracker = IRewardTracker(_vester.rewardTracker());\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            IERC20(esXdx).transferFrom(msg.sender, _accounts[i], _amounts[i]);\n\n            uint256 nextTransferredCumulativeReward = _vester.transferredCumulativeRewards(_accounts[i]).add(_amounts[i]);\n            _vester.setTransferredCumulativeRewards(_accounts[i], nextTransferredCumulativeReward);\n\n            uint256 cumulativeReward = rewardTracker.cumulativeRewards(_accounts[i]);\n            uint256 totalCumulativeReward = cumulativeReward.add(nextTransferredCumulativeReward);\n\n            uint256 combinedAverageStakedAmount = _vester.getCombinedAverageStakedAmount(_accounts[i]);\n\n            if (combinedAverageStakedAmount > totalCumulativeReward.mul(_minRatio)) {\n                continue;\n            }\n\n            uint256 nextTransferredAverageStakedAmount = _minRatio.mul(totalCumulativeReward);\n            nextTransferredAverageStakedAmount = nextTransferredAverageStakedAmount.sub(\n                rewardTracker.averageStakedAmounts(_accounts[i]).mul(cumulativeReward).div(totalCumulativeReward)\n            );\n\n            nextTransferredAverageStakedAmount = nextTransferredAverageStakedAmount.mul(totalCumulativeReward).div(nextTransferredCumulativeReward);\n\n            _vester.setTransferredAverageStakedAmounts(_accounts[i], nextTransferredAverageStakedAmount);\n        }\n    }\n}\n"
    },
    "contracts/gambit-token/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\n\nimport \"../amm/interfaces/IPancakeRouter.sol\";\nimport \"./interfaces/IGMT.sol\";\nimport \"../peripherals/interfaces/ITimelockTarget.sol\";\n\ncontract Treasury is ReentrancyGuard, ITimelockTarget {\n    using SafeMath for uint256;\n\n    uint256 constant PRECISION = 1000000;\n    uint256 constant BASIS_POINTS_DIVISOR = 10000;\n\n    bool public isInitialized;\n    bool public isSwapActive = true;\n    bool public isLiquidityAdded = false;\n\n    address public gmt;\n    address public busd;\n    address public router;\n    address public fund;\n\n    uint256 public gmtPresalePrice;\n    uint256 public gmtListingPrice;\n    uint256 public busdSlotCap;\n    uint256 public busdHardCap;\n    uint256 public busdBasisPoints;\n    uint256 public unlockTime;\n\n    uint256 public busdReceived;\n\n    address public gov;\n\n    mapping (address => uint256) public swapAmounts;\n    mapping (address => bool) public swapWhitelist;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Treasury: forbidden\");\n        _;\n    }\n\n    constructor() public {\n        gov = msg.sender;\n    }\n\n    function initialize(\n        address[] memory _addresses,\n        uint256[] memory _values\n    ) external onlyGov {\n        require(!isInitialized, \"Treasury: already initialized\");\n        isInitialized = true;\n\n        gmt = _addresses[0];\n        busd = _addresses[1];\n        router = _addresses[2];\n        fund = _addresses[3];\n\n        gmtPresalePrice = _values[0];\n        gmtListingPrice = _values[1];\n        busdSlotCap = _values[2];\n        busdHardCap = _values[3];\n        busdBasisPoints = _values[4];\n        unlockTime = _values[5];\n    }\n\n    function setGov(address _gov) external override onlyGov nonReentrant {\n        gov = _gov;\n    }\n\n    function setFund(address _fund) external onlyGov nonReentrant {\n        fund = _fund;\n    }\n\n    function extendUnlockTime(uint256 _unlockTime) external onlyGov nonReentrant {\n        require(_unlockTime > unlockTime, \"Treasury: invalid _unlockTime\");\n        unlockTime = _unlockTime;\n    }\n\n    function addWhitelists(address[] memory _accounts) external onlyGov nonReentrant {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            swapWhitelist[account] = true;\n        }\n    }\n\n    function removeWhitelists(address[] memory _accounts) external onlyGov nonReentrant {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            swapWhitelist[account] = false;\n        }\n    }\n\n    function updateWhitelist(address prevAccount, address nextAccount) external onlyGov nonReentrant {\n        require(swapWhitelist[prevAccount], \"Treasury: invalid prevAccount\");\n        swapWhitelist[prevAccount] = false;\n        swapWhitelist[nextAccount] = true;\n    }\n\n    function swap(uint256 _busdAmount) external nonReentrant {\n        address account = msg.sender;\n        require(swapWhitelist[account], \"Treasury: forbidden\");\n        require(isSwapActive, \"Treasury: swap is no longer active\");\n        require(_busdAmount > 0, \"Treasury: invalid _busdAmount\");\n\n        busdReceived = busdReceived.add(_busdAmount);\n        require(busdReceived <= busdHardCap, \"Treasury: busdHardCap exceeded\");\n\n        swapAmounts[account] = swapAmounts[account].add(_busdAmount);\n        require(swapAmounts[account] <= busdSlotCap, \"Treasury: busdSlotCap exceeded\");\n\n        // receive BUSD\n        uint256 busdBefore = IERC20(busd).balanceOf(address(this));\n        IERC20(busd).transferFrom(account, address(this), _busdAmount);\n        uint256 busdAfter = IERC20(busd).balanceOf(address(this));\n        require(busdAfter.sub(busdBefore) == _busdAmount, \"Treasury: invalid transfer\");\n\n        // send GMT\n        uint256 gmtAmount = _busdAmount.mul(PRECISION).div(gmtPresalePrice);\n        IERC20(gmt).transfer(account, gmtAmount);\n    }\n\n    function addLiquidity() external onlyGov nonReentrant {\n        require(!isLiquidityAdded, \"Treasury: liquidity already added\");\n        isLiquidityAdded = true;\n\n        uint256 busdAmount = busdReceived.mul(busdBasisPoints).div(BASIS_POINTS_DIVISOR);\n        uint256 gmtAmount = busdAmount.mul(PRECISION).div(gmtListingPrice);\n\n        IERC20(busd).approve(router, busdAmount);\n        IERC20(gmt).approve(router, gmtAmount);\n\n        IGMT(gmt).endMigration();\n\n        IPancakeRouter(router).addLiquidity(\n            busd, // tokenA\n            gmt, // tokenB\n            busdAmount, // amountADesired\n            gmtAmount, // amountBDesired\n            0, // amountAMin\n            0, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        IGMT(gmt).beginMigration();\n\n        uint256 fundAmount = busdReceived.sub(busdAmount);\n        IERC20(busd).transfer(fund, fundAmount);\n    }\n\n    function withdrawToken(address _token, address _account, uint256 _amount) external override onlyGov nonReentrant {\n        require(block.timestamp > unlockTime, \"Treasury: unlockTime not yet passed\");\n        IERC20(_token).transfer(_account, _amount);\n    }\n\n    function increaseBusdBasisPoints(uint256 _busdBasisPoints) external onlyGov nonReentrant {\n        require(_busdBasisPoints > busdBasisPoints, \"Treasury: invalid _busdBasisPoints\");\n        busdBasisPoints = _busdBasisPoints;\n    }\n\n    function endSwap() external onlyGov nonReentrant {\n        isSwapActive = false;\n    }\n}\n"
    },
    "contracts/amm/interfaces/IPancakeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakeRouter {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n"
    },
    "contracts/gambit-token/interfaces/IGMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IGMT {\n    function beginMigration() external;\n    function endMigration() external;\n}\n"
    },
    "contracts/gambit-token/GMT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"./interfaces/IGMT.sol\";\nimport \"../peripherals/interfaces/ITimelockTarget.sol\";\n\ncontract GMT is IERC20, IGMT, ITimelockTarget {\n    using SafeMath for uint256;\n\n    string public constant name = \"Gambit\";\n    string public constant symbol = \"GMT\";\n    uint8 public constant decimals = 18;\n\n    uint256 public override totalSupply;\n    address public gov;\n\n    bool public hasActiveMigration;\n    uint256 public migrationTime;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    mapping (address => bool) public admins;\n\n    // only checked when hasActiveMigration is true\n    // this can be used to block the AMM pair as a recipient\n    // and protect liquidity providers during a migration\n    // by disabling the selling of GMT\n    mapping (address => bool) public blockedRecipients;\n\n    // only checked when hasActiveMigration is true\n    // this can be used for:\n    // - only allowing tokens to be transferred by the distribution contract\n    // during the initial distribution phase, this would prevent token buyers\n    // from adding liquidity before the initial liquidity is seeded\n    // - only allowing removal of GMT liquidity and no other actions\n    // during the migration phase\n    mapping (address => bool) public allowedMsgSenders;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"GMT: forbidden\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"GMT: forbidden\");\n        _;\n    }\n\n    constructor(uint256 _initialSupply) public {\n        gov = msg.sender;\n        admins[msg.sender] = true;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function setGov(address _gov) external override onlyGov {\n        gov = _gov;\n    }\n\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n\n    function removeAdmin(address _account) external onlyGov {\n        admins[_account] = false;\n    }\n\n    function setNextMigrationTime(uint256 _migrationTime) external onlyGov {\n        require(_migrationTime > migrationTime, \"GMT: invalid _migrationTime\");\n        migrationTime = _migrationTime;\n    }\n\n    function beginMigration() external override onlyAdmin {\n        require(block.timestamp > migrationTime, \"GMT: migrationTime not yet passed\");\n        hasActiveMigration = true;\n    }\n\n    function endMigration() external override onlyAdmin {\n        hasActiveMigration = false;\n    }\n\n    function addBlockedRecipient(address _recipient) external onlyGov {\n        blockedRecipients[_recipient] = true;\n    }\n\n    function removeBlockedRecipient(address _recipient) external onlyGov {\n        blockedRecipients[_recipient] = false;\n    }\n\n    function addMsgSender(address _msgSender) external onlyGov {\n        allowedMsgSenders[_msgSender] = true;\n    }\n\n    function removeMsgSender(address _msgSender) external onlyGov {\n        allowedMsgSenders[_msgSender] = false;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external override onlyGov {\n        IERC20(_token).transfer(_account, _amount);\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"GMT: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"GMT: transfer from the zero address\");\n        require(_recipient != address(0), \"GMT: transfer to the zero address\");\n\n        if (hasActiveMigration) {\n            require(allowedMsgSenders[msg.sender], \"GMT: forbidden msg.sender\");\n            require(!blockedRecipients[_recipient], \"GMT: forbidden recipient\");\n        }\n\n        balances[_sender] = balances[_sender].sub(_amount, \"GMT: transfer amount exceeds balance\");\n        balances[_recipient] = balances[_recipient].add(_amount);\n\n        emit Transfer(_sender, _recipient,_amount);\n    }\n\n    function _mint(address _account, uint256 _amount) private {\n        require(_account != address(0), \"GMT: mint to the zero address\");\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"GMT: approve from the zero address\");\n        require(_spender != address(0), \"GMT: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n}\n"
    },
    "contracts/amm/PancakeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../tokens/Token.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"./interfaces/IPancakeRouter.sol\";\n\ncontract PancakeRouter is IPancakeRouter {\n    address public pair;\n\n    constructor(address _pair) public {\n        pair = _pair;\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 /*amountAMin*/,\n        uint256 /*amountBMin*/,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\n        require(deadline >= block.timestamp, 'PancakeRouter: EXPIRED');\n\n        Token(pair).mint(to, 1000);\n\n        IERC20(tokenA).transferFrom(msg.sender, pair, amountADesired);\n        IERC20(tokenB).transferFrom(msg.sender, pair, amountBDesired);\n\n        amountA = amountADesired;\n        amountB = amountBDesired;\n        liquidity = 1000;\n    }\n}\n"
    },
    "contracts/tokens/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract Token is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor() public {\n        _name = \"Token\";\n        _symbol = \"TOKEN\";\n        _decimals = 18;\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function withdrawToken(address token, address account, uint256 amount) public {\n        IERC20(token).transfer(account, amount);\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, \"Token: insufficient balance\");\n        _burn(msg.sender, amount);\n        msg.sender.transfer(amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n}\n"
    },
    "contracts/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract WETH is IERC20 {\n    using SafeMath for uint256;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function deposit() public payable {\n        _balances[msg.sender] = _balances[msg.sender].add(msg.value);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        msg.sender.transfer(amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n}\n"
    },
    "contracts/tokens/FaucetToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract FaucetToken is IERC20 {\n    using SafeMath for uint256;\n\n    uint256 public DROPLET_INTERVAL = 8 hours;\n\n    address public _gov;\n    uint256 public _dropletAmount;\n    bool public _isFaucetEnabled;\n\n    mapping (address => uint256) public _claimedAt;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 dropletAmount\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _gov = msg.sender;\n        _dropletAmount = dropletAmount;\n    }\n\n    function mint(address account, uint256 amount) public {\n        require(msg.sender == _gov, \"FaucetToken: forbidden\");\n        _mint(account, amount);\n    }\n\n    function enableFaucet() public {\n        require(msg.sender == _gov, \"FaucetToken: forbidden\");\n        _isFaucetEnabled = true;\n    }\n\n    function disableFaucet() public {\n        require(msg.sender == _gov, \"FaucetToken: forbidden\");\n        _isFaucetEnabled = false;\n    }\n\n    function setDropletAmount(uint256 dropletAmount) public {\n        require(msg.sender == _gov, \"FaucetToken: forbidden\");\n        _dropletAmount = dropletAmount;\n    }\n\n    function claimDroplet() public {\n        require(_isFaucetEnabled, \"FaucetToken: faucet not enabled\");\n        require(_claimedAt[msg.sender].add(DROPLET_INTERVAL) <= block.timestamp, \"FaucetToken: droplet not available yet\");\n        _claimedAt[msg.sender] = block.timestamp;\n        _mint(msg.sender, _dropletAmount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n}\n"
    },
    "contracts/peripherals/BatchSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\nimport \"../access/Governable.sol\";\n\ncontract BatchSender is Governable {\n    using SafeMath for uint256;\n\n    mapping (address => bool) public isHandler;\n\n    event BatchSend(\n        uint256 indexed typeId,\n        address indexed token,\n        address[] accounts,\n        uint256[] amounts\n    );\n\n    modifier onlyHandler() {\n        require(isHandler[msg.sender], \"BatchSender: forbidden\");\n        _;\n    }\n\n    constructor() public {\n        isHandler[msg.sender] = true;\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n\n    function send(IERC20 _token, address[] memory _accounts, uint256[] memory _amounts) public onlyHandler {\n        _send(_token, _accounts, _amounts, 0);\n    }\n\n    function sendAndEmit(IERC20 _token, address[] memory _accounts, uint256[] memory _amounts, uint256 _typeId) public onlyHandler {\n        _send(_token, _accounts, _amounts, _typeId);\n    }\n\n    function _send(IERC20 _token, address[] memory _accounts, uint256[] memory _amounts, uint256 _typeId) private {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 amount = _amounts[i];\n            _token.transferFrom(msg.sender, account, amount);\n        }\n\n        emit BatchSend(_typeId, address(_token), _accounts, _amounts);\n    }\n}\n"
    },
    "contracts/peripherals/BalanceUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../core/interfaces/IVault.sol\";\n\ncontract BalanceUpdater {\n    using SafeMath for uint256;\n\n    function updateBalance(\n        address _vault,\n        address _token,\n        address _usdg,\n        uint256 _usdgAmount\n    ) public {\n        IVault vault = IVault(_vault);\n        IERC20 token = IERC20(_token);\n        uint256 poolAmount = vault.poolAmounts(_token);\n        uint256 fee = vault.feeReserves(_token);\n        uint256 balance = token.balanceOf(_vault);\n\n        uint256 transferAmount = poolAmount.add(fee).sub(balance);\n        token.transferFrom(msg.sender, _vault, transferAmount);\n        IERC20(_usdg).transferFrom(msg.sender, _vault, _usdgAmount);\n\n        vault.sellUSDG(_token, msg.sender);\n    }\n}\n"
    },
    "contracts/core/VaultErrorController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IVault.sol\";\nimport \"../access/Governable.sol\";\n\ncontract VaultErrorController is Governable {\n    function setErrors(IVault _vault, string[] calldata _errors) external onlyGov {\n        for (uint256 i = 0; i < _errors.length; i++) {\n            _vault.setError(i, _errors[i]);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}